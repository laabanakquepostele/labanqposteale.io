/*!
 * jQuery JavaScript Library v1.11.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-04-28T16:19Z
 */

(function (global, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        // For CommonJS and CommonJS-like environments where a proper window is present,
        // execute the factory and get jQuery
        // For environments that do not inherently posses a window with a document
        // (such as Node.js), expose a jQuery-making factory as module.exports
        // This accentuates the need for the creation of a real window
        // e.g. var jQuery = require("jquery")(window);
        // See ticket #14549 for more info
        module.exports = global.document
            ? factory(global, true)
            : function (w) {
                  if (!w.document) {
                      throw new Error('jQuery requires a window with a document');
                  }
                  return factory(w);
              };
    } else {
        factory(global);
    }

    // Pass this if window is not defined yet
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
    // Can't do this because several apps including ASP.NET trace
    // the stack via arguments.caller.callee and Firefox dies if
    // you try to trace through "use strict" call chains. (#13335)
    // Support: Firefox 18+
    //

    var deletedIds = [];

    var slice = deletedIds.slice;

    var concat = deletedIds.concat;

    var push = deletedIds.push;

    var indexOf = deletedIds.indexOf;

    var class2type = {};

    var toString = class2type.toString;

    var hasOwn = class2type.hasOwnProperty;

    var support = {};

    var version = '1.11.3',
        // Define a local copy of jQuery
        jQuery = function (selector, context) {
            // The jQuery object is actually just the init constructor 'enhanced'
            // Need init if jQuery is called (just allow error to be thrown if not included)
            return new jQuery.fn.init(selector, context);
        },
        // Support: Android<4.1, IE<9
        // Make sure we trim BOM and NBSP
        rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
        // Matches dashed string for camelizing
        rmsPrefix = /^-ms-/,
        rdashAlpha = /-([\da-z])/gi,
        // Used by jQuery.camelCase as callback to replace()
        fcamelCase = function (all, letter) {
            return letter.toUpperCase();
        };

    jQuery.fn = jQuery.prototype = {
        // The current version of jQuery being used
        jquery: version,

        constructor: jQuery,

        // Start with an empty selector
        selector: '',

        // The default length of a jQuery object is 0
        length: 0,

        toArray: function () {
            return slice.call(this);
        },

        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function (num) {
            return num != null
                ? // Return just the one element from the set
                  num < 0
                    ? this[num + this.length]
                    : this[num]
                : // Return all the elements in a clean array
                  slice.call(this);
        },

        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function (elems) {
            // Build a new jQuery matched element set
            var ret = jQuery.merge(this.constructor(), elems);

            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;
            ret.context = this.context;

            // Return the newly-formed element set
            return ret;
        },

        // Execute a callback for every element in the matched set.
        // (You can seed the arguments with an array of args, but this is
        // only used internally.)
        each: function (callback, args) {
            return jQuery.each(this, callback, args);
        },

        map: function (callback) {
            return this.pushStack(
                jQuery.map(this, function (elem, i) {
                    return callback.call(elem, i, elem);
                })
            );
        },

        slice: function () {
            return this.pushStack(slice.apply(this, arguments));
        },

        first: function () {
            return this.eq(0);
        },

        last: function () {
            return this.eq(-1);
        },

        eq: function (i) {
            var len = this.length,
                j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },

        end: function () {
            return this.prevObject || this.constructor(null);
        },

        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push,
        sort: deletedIds.sort,
        splice: deletedIds.splice,
    };

    jQuery.extend = jQuery.fn.extend = function () {
        var src,
            copyIsArray,
            copy,
            name,
            options,
            clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;

        // Handle a deep copy situation
        if (typeof target === 'boolean') {
            deep = target;

            // skip the boolean and the target
            target = arguments[i] || {};
            i++;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if (typeof target !== 'object' && !jQuery.isFunction(target)) {
            target = {};
        }

        // extend jQuery itself if only one argument is passed
        if (i === length) {
            target = this;
            i--;
        }

        for (; i < length; i++) {
            // Only deal with non-null/undefined values
            if ((options = arguments[i]) != null) {
                // Extend the base object
                for (name in options) {
                    src = target[name];
                    copy = options[name];

                    // Prevent never-ending loop
                    if (target === copy) {
                        continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }

                        // Never move original objects, clone them
                        target[name] = jQuery.extend(deep, clone, copy);

                        // Don't bring in undefined values
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }

        // Return the modified object
        return target;
    };

    jQuery.extend({
        // Unique for each copy of jQuery on the page
        expando: 'jQuery' + (version + Math.random()).replace(/\D/g, ''),

        // Assume jQuery is ready without the ready module
        isReady: true,

        error: function (msg) {
            throw new Error(msg);
        },

        noop: function () {},

        // See test/unit/core.js for details concerning isFunction.
        // Since version 1.3, DOM methods and functions like alert
        // aren't supported. They return false on IE (#2968).
        isFunction: function (obj) {
            return jQuery.type(obj) === 'function';
        },

        isArray:
            Array.isArray ||
            function (obj) {
                return jQuery.type(obj) === 'array';
            },

        isWindow: function (obj) {
            /* jshint eqeqeq: false */
            return obj != null && obj == obj.window;
        },

        isNumeric: function (obj) {
            // parseFloat NaNs numeric-cast false positives (null|true|false|"")
            // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
            // subtraction forces infinities to NaN
            // adding 1 corrects loss of precision from parseFloat (#15100)
            return !jQuery.isArray(obj) && obj - parseFloat(obj) + 1 >= 0;
        },

        isEmptyObject: function (obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },

        isPlainObject: function (obj) {
            var key;

            // Must be an Object.
            // Because of IE, we also have to check the presence of the constructor property.
            // Make sure that DOM nodes and window objects don't pass through, as well
            if (!obj || jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) {
                return false;
            }

            try {
                // Not own constructor property must be Object
                if (obj.constructor && !hasOwn.call(obj, 'constructor') && !hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
                    return false;
                }
            } catch (e) {
                // IE8,9 Will throw exceptions on certain host objects #9897
                return false;
            }

            // Support: IE<9
            // Handle iteration over inherited properties before own properties.
            if (support.ownLast) {
                for (key in obj) {
                    return hasOwn.call(obj, key);
                }
            }

            // Own properties are enumerated firstly, so to speed up,
            // if last one is own, then all properties are own.
            for (key in obj) {
            }

            return key === undefined || hasOwn.call(obj, key);
        },

        type: function (obj) {
            if (obj == null) {
                return obj + '';
            }
            return typeof obj === 'object' || typeof obj === 'function' ? class2type[toString.call(obj)] || 'object' : typeof obj;
        },

        // Evaluates a script in a global context
        // Workarounds based on findings by Jim Driscoll
        // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
        globalEval: function (data) {
            if (data && jQuery.trim(data)) {
                // We use execScript on Internet Explorer
                // We use an anonymous function so that context is window
                // rather than jQuery in Firefox
                (
                    window.execScript ||
                    function (data) {
                        window['eval'].call(window, data);
                    }
                )(data);
            }
        },

        // Convert dashed to camelCase; used by the css and data modules
        // Microsoft forgot to hump their vendor prefix (#9572)
        camelCase: function (string) {
            return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
        },

        nodeName: function (elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },

        // args is for internal usage only
        each: function (obj, callback, args) {
            var value,
                i = 0,
                length = obj.length,
                isArray = isArraylike(obj);

            if (args) {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.apply(obj[i], args);

                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.apply(obj[i], args);

                        if (value === false) {
                            break;
                        }
                    }
                }

                // A special, fast, case for the most common use of each
            } else {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.call(obj[i], i, obj[i]);

                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.call(obj[i], i, obj[i]);

                        if (value === false) {
                            break;
                        }
                    }
                }
            }

            return obj;
        },

        // Support: Android<4.1, IE<9
        trim: function (text) {
            return text == null ? '' : (text + '').replace(rtrim, '');
        },

        // results is for internal usage only
        makeArray: function (arr, results) {
            var ret = results || [];

            if (arr != null) {
                if (isArraylike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
                } else {
                    push.call(ret, arr);
                }
            }

            return ret;
        },

        inArray: function (elem, arr, i) {
            var len;

            if (arr) {
                if (indexOf) {
                    return indexOf.call(arr, elem, i);
                }

                len = arr.length;
                i = i ? (i < 0 ? Math.max(0, len + i) : i) : 0;

                for (; i < len; i++) {
                    // Skip accessing in sparse arrays
                    if (i in arr && arr[i] === elem) {
                        return i;
                    }
                }
            }

            return -1;
        },

        merge: function (first, second) {
            var len = +second.length,
                j = 0,
                i = first.length;

            while (j < len) {
                first[i++] = second[j++];
            }

            // Support: IE<9
            // Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
            if (len !== len) {
                while (second[j] !== undefined) {
                    first[i++] = second[j++];
                }
            }

            first.length = i;

            return first;
        },

        grep: function (elems, callback, invert) {
            var callbackInverse,
                matches = [],
                i = 0,
                length = elems.length,
                callbackExpect = !invert;

            // Go through the array, only saving the items
            // that pass the validator function
            for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }

            return matches;
        },

        // arg is for internal usage only
        map: function (elems, callback, arg) {
            var value,
                i = 0,
                length = elems.length,
                isArray = isArraylike(elems),
                ret = [];

            // Go through the array, translating each of the items to their new values
            if (isArray) {
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);

                    if (value != null) {
                        ret.push(value);
                    }
                }

                // Go through every key on the object,
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);

                    if (value != null) {
                        ret.push(value);
                    }
                }
            }

            // Flatten any nested arrays
            return concat.apply([], ret);
        },

        // A global GUID counter for objects
        guid: 1,

        // Bind a function to a context, optionally partially applying any
        // arguments.
        proxy: function (fn, context) {
            var args, proxy, tmp;

            if (typeof context === 'string') {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }

            // Quick check to determine if target is callable, in the spec
            // this throws a TypeError, but we will just return undefined.
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }

            // Simulated bind
            args = slice.call(arguments, 2);
            proxy = function () {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            };

            // Set the guid of unique handler to the same of original handler, so it can be removed
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;

            return proxy;
        },

        now: function () {
            return +new Date();
        },

        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support,
    });

    // Populate the class2type map
    jQuery.each('Boolean Number String Function Array Date RegExp Object Error'.split(' '), function (i, name) {
        class2type['[object ' + name + ']'] = name.toLowerCase();
    });

    function isArraylike(obj) {
        // Support: iOS 8.2 (not reproducible in simulator)
        // `in` check used to prevent JIT error (gh-2145)
        // hasOwn isn't used here due to false negatives
        // regarding Nodelist length in IE
        var length = 'length' in obj && obj.length,
            type = jQuery.type(obj);

        if (type === 'function' || jQuery.isWindow(obj)) {
            return false;
        }

        if (obj.nodeType === 1 && length) {
            return true;
        }

        return type === 'array' || length === 0 || (typeof length === 'number' && length > 0 && length - 1 in obj);
    }
    var Sizzle =
        /*!
         * Sizzle CSS Selector Engine v2.2.0-pre
         * http://sizzlejs.com/
         *
         * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
         * Released under the MIT license
         * http://jquery.org/license
         *
         * Date: 2014-12-16
         */
        (function (window) {
            var i,
                support,
                Expr,
                getText,
                isXML,
                tokenize,
                compile,
                select,
                outermostContext,
                sortInput,
                hasDuplicate,
                // Local document vars
                setDocument,
                document,
                docElem,
                documentIsHTML,
                rbuggyQSA,
                rbuggyMatches,
                matches,
                contains,
                // Instance-specific data
                expando = 'sizzle' + 1 * new Date(),
                preferredDoc = window.document,
                dirruns = 0,
                done = 0,
                classCache = createCache(),
                tokenCache = createCache(),
                compilerCache = createCache(),
                sortOrder = function (a, b) {
                    if (a === b) {
                        hasDuplicate = true;
                    }
                    return 0;
                },
                // General-purpose constants
                MAX_NEGATIVE = 1 << 31,
                // Instance methods
                hasOwn = {}.hasOwnProperty,
                arr = [],
                pop = arr.pop,
                push_native = arr.push,
                push = arr.push,
                slice = arr.slice,
                // Use a stripped-down indexOf as it's faster than native
                // http://jsperf.com/thor-indexof-vs-for/5
                indexOf = function (list, elem) {
                    var i = 0,
                        len = list.length;
                    for (; i < len; i++) {
                        if (list[i] === elem) {
                            return i;
                        }
                    }
                    return -1;
                },
                booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped',
                // Regular expressions

                // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
                whitespace = '[\\x20\\t\\r\\n\\f]',
                // http://www.w3.org/TR/css3-syntax/#characters
                characterEncoding = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+',
                // Loosely modeled on CSS identifier characters
                // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
                // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
                identifier = characterEncoding.replace('w', 'w#'),
                // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
                attributes =
                    '\\[' +
                    whitespace +
                    '*(' +
                    characterEncoding +
                    ')(?:' +
                    whitespace +
                    // Operator (capture 2)
                    '*([*^$|!~]?=)' +
                    whitespace +
                    // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
                    '*(?:\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)"|(' +
                    identifier +
                    '))|)' +
                    whitespace +
                    '*\\]',
                pseudos =
                    ':(' +
                    characterEncoding +
                    ')(?:\\((' +
                    // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                    // 1. quoted (capture 3; capture 4 or capture 5)
                    '(\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)")|' +
                    // 2. simple (capture 6)
                    '((?:\\\\.|[^\\\\()[\\]]|' +
                    attributes +
                    ')*)|' +
                    // 3. anything else (capture 2)
                    '.*' +
                    ')\\)|)',
                // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                rwhitespace = new RegExp(whitespace + '+', 'g'),
                rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'),
                rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'),
                rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'),
                rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*?)' + whitespace + '*\\]', 'g'),
                rpseudo = new RegExp(pseudos),
                ridentifier = new RegExp('^' + identifier + '$'),
                matchExpr = {
                    'ID': new RegExp('^#(' + characterEncoding + ')'),
                    'CLASS': new RegExp('^\\.(' + characterEncoding + ')'),
                    'TAG': new RegExp('^(' + characterEncoding.replace('w', 'w*') + ')'),
                    'ATTR': new RegExp('^' + attributes),
                    'PSEUDO': new RegExp('^' + pseudos),
                    'CHILD': new RegExp(
                        '^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' +
                            whitespace +
                            '*(even|odd|(([+-]|)(\\d*)n|)' +
                            whitespace +
                            '*(?:([+-]|)' +
                            whitespace +
                            '*(\\d+)|))' +
                            whitespace +
                            '*\\)|)',
                        'i'
                    ),
                    'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
                    // For use in libraries implementing .is()
                    // We use this for POS matching in `select`
                    'needsContext': new RegExp(
                        '^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)',
                        'i'
                    ),
                },
                rinputs = /^(?:input|select|textarea|button)$/i,
                rheader = /^h\d$/i,
                rnative = /^[^{]+\{\s*\[native \w/,
                // Easily-parseable/retrievable ID or TAG or CLASS selectors
                rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                rsibling = /[+~]/,
                rescape = /'|\\/g,
                // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'),
                funescape = function (_, escaped, escapedWhitespace) {
                    var high = '0x' + escaped - 0x10000;
                    // NaN means non-codepoint
                    // Support: Firefox<24
                    // Workaround erroneous numeric interpretation of +"0x"
                    return high !== high || escapedWhitespace
                        ? escaped
                        : high < 0
                        ? // BMP codepoint
                          String.fromCharCode(high + 0x10000)
                        : // Supplemental Plane codepoint (surrogate pair)
                          String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);
                },
                // Used for iframes
                // See setDocument()
                // Removing the function wrapper causes a "Permission Denied"
                // error in IE
                unloadHandler = function () {
                    setDocument();
                };

            // Optimize for push.apply( _, NodeList )
            try {
                push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes);
                // Support: Android<4.0
                // Detect silently failing push.apply
                arr[preferredDoc.childNodes.length].nodeType;
            } catch (e) {
                push = {
                    apply: arr.length
                        ? // Leverage slice if possible
                          function (target, els) {
                              push_native.apply(target, slice.call(els));
                          }
                        : // Support: IE<9
                          // Otherwise append directly
                          function (target, els) {
                              var j = target.length,
                                  i = 0;
                              // Can't trust NodeList.length
                              while ((target[j++] = els[i++])) {}
                              target.length = j - 1;
                          },
                };
            }

            function Sizzle(selector, context, results, seed) {
                var match,
                    elem,
                    m,
                    nodeType,
                    // QSA vars
                    i,
                    groups,
                    old,
                    nid,
                    newContext,
                    newSelector;

                if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                    setDocument(context);
                }

                context = context || document;
                results = results || [];
                nodeType = context.nodeType;

                if (typeof selector !== 'string' || !selector || (nodeType !== 1 && nodeType !== 9 && nodeType !== 11)) {
                    return results;
                }

                if (!seed && documentIsHTML) {
                    // Try to shortcut find operations when possible (e.g., not under DocumentFragment)
                    if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                        // Speed-up: Sizzle("#ID")
                        if ((m = match[1])) {
                            if (nodeType === 9) {
                                elem = context.getElementById(m);
                                // Check parentNode to catch when Blackberry 4.6 returns
                                // nodes that are no longer in the document (jQuery #6963)
                                if (elem && elem.parentNode) {
                                    // Handle the case where IE, Opera, and Webkit return items
                                    // by name instead of ID
                                    if (elem.id === m) {
                                        results.push(elem);
                                        return results;
                                    }
                                } else {
                                    return results;
                                }
                            } else {
                                // Context is not a document
                                if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            }

                            // Speed-up: Sizzle("TAG")
                        } else if (match[2]) {
                            push.apply(results, context.getElementsByTagName(selector));
                            return results;

                            // Speed-up: Sizzle(".CLASS")
                        } else if ((m = match[3]) && support.getElementsByClassName) {
                            push.apply(results, context.getElementsByClassName(m));
                            return results;
                        }
                    }

                    // QSA path
                    if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                        nid = old = expando;
                        newContext = context;
                        newSelector = nodeType !== 1 && selector;

                        // qSA works strangely on Element-rooted queries
                        // We can work around this by specifying an extra ID on the root
                        // and working up from there (Thanks to Andrew Dupont for the technique)
                        // IE 8 doesn't work on object elements
                        if (nodeType === 1 && context.nodeName.toLowerCase() !== 'object') {
                            groups = tokenize(selector);

                            if ((old = context.getAttribute('id'))) {
                                nid = old.replace(rescape, '\\$&');
                            } else {
                                context.setAttribute('id', nid);
                            }
                            nid = "[id='" + nid + "'] ";

                            i = groups.length;
                            while (i--) {
                                groups[i] = nid + toSelector(groups[i]);
                            }
                            newContext = (rsibling.test(selector) && testContext(context.parentNode)) || context;
                            newSelector = groups.join(',');
                        }

                        if (newSelector) {
                            try {
                                push.apply(results, newContext.querySelectorAll(newSelector));
                                return results;
                            } catch (qsaError) {
                            } finally {
                                if (!old) {
                                    context.removeAttribute('id');
                                }
                            }
                        }
                    }
                }

                // All others
                return select(selector.replace(rtrim, '$1'), context, results, seed);
            }

            /**
             * Create key-value caches of limited size
             * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
             *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
             *	deleting the oldest entry
             */
            function createCache() {
                var keys = [];

                function cache(key, value) {
                    // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                    if (keys.push(key + ' ') > Expr.cacheLength) {
                        // Only keep the most recent entries
                        delete cache[keys.shift()];
                    }
                    return (cache[key + ' '] = value);
                }
                return cache;
            }

            /**
             * Mark a function for special use by Sizzle
             * @param {Function} fn The function to mark
             */
            function markFunction(fn) {
                fn[expando] = true;
                return fn;
            }

            /**
             * Support testing using an element
             * @param {Function} fn Passed the created div and expects a boolean result
             */
            function assert(fn) {
                var div = document.createElement('div');

                try {
                    return !!fn(div);
                } catch (e) {
                    return false;
                } finally {
                    // Remove from its parent by default
                    if (div.parentNode) {
                        div.parentNode.removeChild(div);
                    }
                    // release memory in IE
                    div = null;
                }
            }

            /**
             * Adds the same handler for all of the specified attrs
             * @param {String} attrs Pipe-separated list of attributes
             * @param {Function} handler The method that will be applied
             */
            function addHandle(attrs, handler) {
                var arr = attrs.split('|'),
                    i = attrs.length;

                while (i--) {
                    Expr.attrHandle[arr[i]] = handler;
                }
            }

            /**
             * Checks document order of two siblings
             * @param {Element} a
             * @param {Element} b
             * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
             */
            function siblingCheck(a, b) {
                var cur = b && a,
                    diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);

                // Use IE sourceIndex if available on both nodes
                if (diff) {
                    return diff;
                }

                // Check if b follows a
                if (cur) {
                    while ((cur = cur.nextSibling)) {
                        if (cur === b) {
                            return -1;
                        }
                    }
                }

                return a ? 1 : -1;
            }

            /**
             * Returns a function to use in pseudos for input types
             * @param {String} type
             */
            function createInputPseudo(type) {
                return function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === 'input' && elem.type === type;
                };
            }

            /**
             * Returns a function to use in pseudos for buttons
             * @param {String} type
             */
            function createButtonPseudo(type) {
                return function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === 'input' || name === 'button') && elem.type === type;
                };
            }

            /**
             * Returns a function to use in pseudos for positionals
             * @param {Function} fn
             */
            function createPositionalPseudo(fn) {
                return markFunction(function (argument) {
                    argument = +argument;
                    return markFunction(function (seed, matches) {
                        var j,
                            matchIndexes = fn([], seed.length, argument),
                            i = matchIndexes.length;

                        // Match elements found at the specified indexes
                        while (i--) {
                            if (seed[(j = matchIndexes[i])]) {
                                seed[j] = !(matches[j] = seed[j]);
                            }
                        }
                    });
                });
            }

            /**
             * Checks a node for validity as a Sizzle context
             * @param {Element|Object=} context
             * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
             */
            function testContext(context) {
                return context && typeof context.getElementsByTagName !== 'undefined' && context;
            }

            // Expose support vars for convenience
            support = Sizzle.support = {};

            /**
             * Detects XML nodes
             * @param {Element|Object} elem An element or a document
             * @returns {Boolean} True iff elem is a non-HTML XML node
             */
            isXML = Sizzle.isXML = function (elem) {
                // documentElement is verified for cases where it doesn't yet exist
                // (such as loading iframes in IE - #4833)
                var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                return documentElement ? documentElement.nodeName !== 'HTML' : false;
            };

            /**
             * Sets document-related variables once based on the current document
             * @param {Element|Object} [doc] An element or document object to use to set the document
             * @returns {Object} Returns the current document
             */
            setDocument = Sizzle.setDocument = function (node) {
                var hasCompare,
                    parent,
                    doc = node ? node.ownerDocument || node : preferredDoc;

                // If no document and documentElement is available, return
                if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                    return document;
                }

                // Set our document
                document = doc;
                docElem = doc.documentElement;
                parent = doc.defaultView;

                // Support: IE>8
                // If iframe document is assigned to "document" variable and if iframe has been reloaded,
                // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
                // IE6-8 do not support the defaultView property so parent will be undefined
                if (parent && parent !== parent.top) {
                    // IE11 does not have attachEvent, so all must suffer
                    if (parent.addEventListener) {
                        parent.addEventListener('unload', unloadHandler, false);
                    } else if (parent.attachEvent) {
                        parent.attachEvent('onunload', unloadHandler);
                    }
                }

                /* Support tests
	---------------------------------------------------------------------- */
                documentIsHTML = !isXML(doc);

                /* Attributes
	---------------------------------------------------------------------- */

                // Support: IE<8
                // Verify that getAttribute really returns attributes and not properties
                // (excepting IE8 booleans)
                support.attributes = assert(function (div) {
                    div.className = 'i';
                    return !div.getAttribute('className');
                });

                /* getElement(s)By*
	---------------------------------------------------------------------- */

                // Check if getElementsByTagName("*") returns only elements
                support.getElementsByTagName = assert(function (div) {
                    div.appendChild(doc.createComment(''));
                    return !div.getElementsByTagName('*').length;
                });

                // Support: IE<9
                support.getElementsByClassName = rnative.test(doc.getElementsByClassName);

                // Support: IE<10
                // Check if getElementById returns elements by name
                // The broken getElementById methods don't pick up programatically-set names,
                // so use a roundabout getElementsByName test
                support.getById = assert(function (div) {
                    docElem.appendChild(div).id = expando;
                    return !doc.getElementsByName || !doc.getElementsByName(expando).length;
                });

                // ID find and filter
                if (support.getById) {
                    Expr.find['ID'] = function (id, context) {
                        if (typeof context.getElementById !== 'undefined' && documentIsHTML) {
                            var m = context.getElementById(id);
                            // Check parentNode to catch when Blackberry 4.6 returns
                            // nodes that are no longer in the document #6963
                            return m && m.parentNode ? [m] : [];
                        }
                    };
                    Expr.filter['ID'] = function (id) {
                        var attrId = id.replace(runescape, funescape);
                        return function (elem) {
                            return elem.getAttribute('id') === attrId;
                        };
                    };
                } else {
                    // Support: IE6/7
                    // getElementById is not reliable as a find shortcut
                    delete Expr.find['ID'];

                    Expr.filter['ID'] = function (id) {
                        var attrId = id.replace(runescape, funescape);
                        return function (elem) {
                            var node = typeof elem.getAttributeNode !== 'undefined' && elem.getAttributeNode('id');
                            return node && node.value === attrId;
                        };
                    };
                }

                // Tag
                Expr.find['TAG'] = support.getElementsByTagName
                    ? function (tag, context) {
                          if (typeof context.getElementsByTagName !== 'undefined') {
                              return context.getElementsByTagName(tag);

                              // DocumentFragment nodes don't have gEBTN
                          } else if (support.qsa) {
                              return context.querySelectorAll(tag);
                          }
                      }
                    : function (tag, context) {
                          var elem,
                              tmp = [],
                              i = 0,
                              // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                              results = context.getElementsByTagName(tag);

                          // Filter out possible comments
                          if (tag === '*') {
                              while ((elem = results[i++])) {
                                  if (elem.nodeType === 1) {
                                      tmp.push(elem);
                                  }
                              }

                              return tmp;
                          }
                          return results;
                      };

                // Class
                Expr.find['CLASS'] =
                    support.getElementsByClassName &&
                    function (className, context) {
                        if (documentIsHTML) {
                            return context.getElementsByClassName(className);
                        }
                    };

                /* QSA/matchesSelector
	---------------------------------------------------------------------- */

                // QSA and matchesSelector support

                // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                rbuggyMatches = [];

                // qSa(:focus) reports false when true (Chrome 21)
                // We allow this because of a bug in IE8/9 that throws an error
                // whenever `document.activeElement` is accessed on an iframe
                // So, we allow :focus to pass through QSA all the time to avoid the IE error
                // See http://bugs.jquery.com/ticket/13378
                rbuggyQSA = [];

                if ((support.qsa = rnative.test(doc.querySelectorAll))) {
                    // Build QSA regex
                    // Regex strategy adopted from Diego Perini
                    assert(function (div) {
                        // Select is set to empty string on purpose
                        // This is to test IE's treatment of not explicitly
                        // setting a boolean content attribute,
                        // since its presence should be enough
                        // http://bugs.jquery.com/ticket/12359
                        docElem.appendChild(div).innerHTML =
                            "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\f]' msallowcapture=''>" + "<option selected=''></option></select>";

                        // Support: IE8, Opera 11-12.16
                        // Nothing should be selected when empty strings follow ^= or $= or *=
                        // The test attribute must be unknown in Opera but "safe" for WinRT
                        // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                        if (div.querySelectorAll("[msallowcapture^='']").length) {
                            rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
                        }

                        // Support: IE8
                        // Boolean attributes and "value" are not treated correctly
                        if (!div.querySelectorAll('[selected]').length) {
                            rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
                        }

                        // Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
                        if (!div.querySelectorAll('[id~=' + expando + '-]').length) {
                            rbuggyQSA.push('~=');
                        }

                        // Webkit/Opera - :checked should return selected option elements
                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                        // IE8 throws error here and will not see later tests
                        if (!div.querySelectorAll(':checked').length) {
                            rbuggyQSA.push(':checked');
                        }

                        // Support: Safari 8+, iOS 8+
                        // https://bugs.webkit.org/show_bug.cgi?id=136851
                        // In-page `selector#id sibing-combinator selector` fails
                        if (!div.querySelectorAll('a#' + expando + '+*').length) {
                            rbuggyQSA.push('.#.+[+~]');
                        }
                    });

                    assert(function (div) {
                        // Support: Windows 8 Native Apps
                        // The type and name attributes are restricted during .innerHTML assignment
                        var input = doc.createElement('input');
                        input.setAttribute('type', 'hidden');
                        div.appendChild(input).setAttribute('name', 'D');

                        // Support: IE8
                        // Enforce case-sensitivity of name attribute
                        if (div.querySelectorAll('[name=d]').length) {
                            rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?=');
                        }

                        // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                        // IE8 throws error here and will not see later tests
                        if (!div.querySelectorAll(':enabled').length) {
                            rbuggyQSA.push(':enabled', ':disabled');
                        }

                        // Opera 10-11 does not throw on post-comma invalid pseudos
                        div.querySelectorAll('*,:x');
                        rbuggyQSA.push(',.*:');
                    });
                }

                if (
                    (support.matchesSelector = rnative.test(
                        (matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)
                    ))
                ) {
                    assert(function (div) {
                        // Check to see if it's possible to do matchesSelector
                        // on a disconnected node (IE 9)
                        support.disconnectedMatch = matches.call(div, 'div');

                        // This should fail with an exception
                        // Gecko does not error, returns false instead
                        matches.call(div, "[s!='']:x");
                        rbuggyMatches.push('!=', pseudos);
                    });
                }

                rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
                rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));

                /* Contains
	---------------------------------------------------------------------- */
                hasCompare = rnative.test(docElem.compareDocumentPosition);

                // Element contains another
                // Purposefully does not implement inclusive descendent
                // As in, an element does not contain itself
                contains =
                    hasCompare || rnative.test(docElem.contains)
                        ? function (a, b) {
                              var adown = a.nodeType === 9 ? a.documentElement : a,
                                  bup = b && b.parentNode;
                              return (
                                  a === bup ||
                                  !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16))
                              );
                          }
                        : function (a, b) {
                              if (b) {
                                  while ((b = b.parentNode)) {
                                      if (b === a) {
                                          return true;
                                      }
                                  }
                              }
                              return false;
                          };

                /* Sorting
	---------------------------------------------------------------------- */

                // Document order sorting
                sortOrder = hasCompare
                    ? function (a, b) {
                          // Flag for duplicate removal
                          if (a === b) {
                              hasDuplicate = true;
                              return 0;
                          }

                          // Sort on method existence if only one input has compareDocumentPosition
                          var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                          if (compare) {
                              return compare;
                          }

                          // Calculate position if both inputs belong to the same document
                          compare =
                              (a.ownerDocument || a) === (b.ownerDocument || b)
                                  ? a.compareDocumentPosition(b)
                                  : // Otherwise we know they are disconnected
                                    1;

                          // Disconnected nodes
                          if (compare & 1 || (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {
                              // Choose the first element that is related to our preferred document
                              if (a === doc || (a.ownerDocument === preferredDoc && contains(preferredDoc, a))) {
                                  return -1;
                              }
                              if (b === doc || (b.ownerDocument === preferredDoc && contains(preferredDoc, b))) {
                                  return 1;
                              }

                              // Maintain original order
                              return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                          }

                          return compare & 4 ? -1 : 1;
                      }
                    : function (a, b) {
                          // Exit early if the nodes are identical
                          if (a === b) {
                              hasDuplicate = true;
                              return 0;
                          }

                          var cur,
                              i = 0,
                              aup = a.parentNode,
                              bup = b.parentNode,
                              ap = [a],
                              bp = [b];

                          // Parentless nodes are either documents or disconnected
                          if (!aup || !bup) {
                              return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;

                              // If the nodes are siblings, we can do a quick check
                          } else if (aup === bup) {
                              return siblingCheck(a, b);
                          }

                          // Otherwise we need full lists of their ancestors for comparison
                          cur = a;
                          while ((cur = cur.parentNode)) {
                              ap.unshift(cur);
                          }
                          cur = b;
                          while ((cur = cur.parentNode)) {
                              bp.unshift(cur);
                          }

                          // Walk down the tree looking for a discrepancy
                          while (ap[i] === bp[i]) {
                              i++;
                          }

                          return i
                              ? // Do a sibling check if the nodes have a common ancestor
                                siblingCheck(ap[i], bp[i])
                              : // Otherwise nodes in our document sort first
                              ap[i] === preferredDoc
                              ? -1
                              : bp[i] === preferredDoc
                              ? 1
                              : 0;
                      };

                return doc;
            };

            Sizzle.matches = function (expr, elements) {
                return Sizzle(expr, null, null, elements);
            };

            Sizzle.matchesSelector = function (elem, expr) {
                // Set document vars if needed
                if ((elem.ownerDocument || elem) !== document) {
                    setDocument(elem);
                }

                // Make sure that attribute selectors are quoted
                expr = expr.replace(rattributeQuotes, "='$1']");

                if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                    try {
                        var ret = matches.call(elem, expr);

                        // IE 9's matchesSelector returns false on disconnected nodes
                        if (
                            ret ||
                            support.disconnectedMatch ||
                            // As well, disconnected nodes are said to be in a document
                            // fragment in IE 9
                            (elem.document && elem.document.nodeType !== 11)
                        ) {
                            return ret;
                        }
                    } catch (e) {}
                }

                return Sizzle(expr, document, null, [elem]).length > 0;
            };

            Sizzle.contains = function (context, elem) {
                // Set document vars if needed
                if ((context.ownerDocument || context) !== document) {
                    setDocument(context);
                }
                return contains(context, elem);
            };

            Sizzle.attr = function (elem, name) {
                // Set document vars if needed
                if ((elem.ownerDocument || elem) !== document) {
                    setDocument(elem);
                }

                var fn = Expr.attrHandle[name.toLowerCase()],
                    // Don't get fooled by Object.prototype properties (jQuery #13807)
                    val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;

                return val !== undefined
                    ? val
                    : support.attributes || !documentIsHTML
                    ? elem.getAttribute(name)
                    : (val = elem.getAttributeNode(name)) && val.specified
                    ? val.value
                    : null;
            };

            Sizzle.error = function (msg) {
                throw new Error('Syntax error, unrecognized expression: ' + msg);
            };

            /**
             * Document sorting and removing duplicates
             * @param {ArrayLike} results
             */
            Sizzle.uniqueSort = function (results) {
                var elem,
                    duplicates = [],
                    j = 0,
                    i = 0;

                // Unless we *know* we can detect duplicates, assume their presence
                hasDuplicate = !support.detectDuplicates;
                sortInput = !support.sortStable && results.slice(0);
                results.sort(sortOrder);

                if (hasDuplicate) {
                    while ((elem = results[i++])) {
                        if (elem === results[i]) {
                            j = duplicates.push(i);
                        }
                    }
                    while (j--) {
                        results.splice(duplicates[j], 1);
                    }
                }

                // Clear input after sorting to release objects
                // See https://github.com/jquery/sizzle/pull/225
                sortInput = null;

                return results;
            };

            /**
             * Utility function for retrieving the text value of an array of DOM nodes
             * @param {Array|Element} elem
             */
            getText = Sizzle.getText = function (elem) {
                var node,
                    ret = '',
                    i = 0,
                    nodeType = elem.nodeType;

                if (!nodeType) {
                    // If no nodeType, this is expected to be an array
                    while ((node = elem[i++])) {
                        // Do not traverse comment nodes
                        ret += getText(node);
                    }
                } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                    // Use textContent for elements
                    // innerText usage removed for consistency of new lines (jQuery #11153)
                    if (typeof elem.textContent === 'string') {
                        return elem.textContent;
                    } else {
                        // Traverse its children
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            ret += getText(elem);
                        }
                    }
                } else if (nodeType === 3 || nodeType === 4) {
                    return elem.nodeValue;
                }
                // Do not include comment or processing instruction nodes

                return ret;
            };

            Expr = Sizzle.selectors = {
                // Can be adjusted by the user
                cacheLength: 50,

                createPseudo: markFunction,

                match: matchExpr,

                attrHandle: {},

                find: {},

                relative: {
                    '>': { dir: 'parentNode', first: true },
                    ' ': { dir: 'parentNode' },
                    '+': { dir: 'previousSibling', first: true },
                    '~': { dir: 'previousSibling' },
                },

                preFilter: {
                    'ATTR': function (match) {
                        match[1] = match[1].replace(runescape, funescape);

                        // Move the given value to match[3] whether quoted or unquoted
                        match[3] = (match[3] || match[4] || match[5] || '').replace(runescape, funescape);

                        if (match[2] === '~=') {
                            match[3] = ' ' + match[3] + ' ';
                        }

                        return match.slice(0, 4);
                    },

                    'CHILD': function (match) {
                        /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
                        match[1] = match[1].toLowerCase();

                        if (match[1].slice(0, 3) === 'nth') {
                            // nth-* requires argument
                            if (!match[3]) {
                                Sizzle.error(match[0]);
                            }

                            // numeric x and y parameters for Expr.filter.CHILD
                            // remember that false/true cast respectively to 0/1
                            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
                            match[5] = +(match[7] + match[8] || match[3] === 'odd');

                            // other types prohibit arguments
                        } else if (match[3]) {
                            Sizzle.error(match[0]);
                        }

                        return match;
                    },

                    'PSEUDO': function (match) {
                        var excess,
                            unquoted = !match[6] && match[2];

                        if (matchExpr['CHILD'].test(match[0])) {
                            return null;
                        }

                        // Accept quoted arguments as-is
                        if (match[3]) {
                            match[2] = match[4] || match[5] || '';

                            // Strip excess characters from unquoted arguments
                        } else if (
                            unquoted &&
                            rpseudo.test(unquoted) &&
                            // Get excess from tokenize (recursively)
                            (excess = tokenize(unquoted, true)) &&
                            // advance to the next closing parenthesis
                            (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)
                        ) {
                            // excess is a negative index
                            match[0] = match[0].slice(0, excess);
                            match[2] = unquoted.slice(0, excess);
                        }

                        // Return only captures needed by the pseudo filter method (type and argument)
                        return match.slice(0, 3);
                    },
                },

                filter: {
                    'TAG': function (nodeNameSelector) {
                        var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                        return nodeNameSelector === '*'
                            ? function () {
                                  return true;
                              }
                            : function (elem) {
                                  return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                              };
                    },

                    'CLASS': function (className) {
                        var pattern = classCache[className + ' '];

                        return (
                            pattern ||
                            ((pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) &&
                                classCache(className, function (elem) {
                                    return pattern.test(
                                        (typeof elem.className === 'string' && elem.className) || (typeof elem.getAttribute !== 'undefined' && elem.getAttribute('class')) || ''
                                    );
                                }))
                        );
                    },

                    'ATTR': function (name, operator, check) {
                        return function (elem) {
                            var result = Sizzle.attr(elem, name);

                            if (result == null) {
                                return operator === '!=';
                            }
                            if (!operator) {
                                return true;
                            }

                            result += '';

                            return operator === '='
                                ? result === check
                                : operator === '!='
                                ? result !== check
                                : operator === '^='
                                ? check && result.indexOf(check) === 0
                                : operator === '*='
                                ? check && result.indexOf(check) > -1
                                : operator === '$='
                                ? check && result.slice(-check.length) === check
                                : operator === '~='
                                ? (' ' + result.replace(rwhitespace, ' ') + ' ').indexOf(check) > -1
                                : operator === '|='
                                ? result === check || result.slice(0, check.length + 1) === check + '-'
                                : false;
                        };
                    },

                    'CHILD': function (type, what, argument, first, last) {
                        var simple = type.slice(0, 3) !== 'nth',
                            forward = type.slice(-4) !== 'last',
                            ofType = what === 'of-type';

                        return first === 1 && last === 0
                            ? // Shortcut for :nth-*(n)
                              function (elem) {
                                  return !!elem.parentNode;
                              }
                            : function (elem, context, xml) {
                                  var cache,
                                      outerCache,
                                      node,
                                      diff,
                                      nodeIndex,
                                      start,
                                      dir = simple !== forward ? 'nextSibling' : 'previousSibling',
                                      parent = elem.parentNode,
                                      name = ofType && elem.nodeName.toLowerCase(),
                                      useCache = !xml && !ofType;

                                  if (parent) {
                                      // :(first|last|only)-(child|of-type)
                                      if (simple) {
                                          while (dir) {
                                              node = elem;
                                              while ((node = node[dir])) {
                                                  if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                                      return false;
                                                  }
                                              }
                                              // Reverse direction for :only-* (if we haven't yet done so)
                                              start = dir = type === 'only' && !start && 'nextSibling';
                                          }
                                          return true;
                                      }

                                      start = [forward ? parent.firstChild : parent.lastChild];

                                      // non-xml :nth-child(...) stores cache data on `parent`
                                      if (forward && useCache) {
                                          // Seek `elem` from a previously-cached index
                                          outerCache = parent[expando] || (parent[expando] = {});
                                          cache = outerCache[type] || [];
                                          nodeIndex = cache[0] === dirruns && cache[1];
                                          diff = cache[0] === dirruns && cache[2];
                                          node = nodeIndex && parent.childNodes[nodeIndex];

                                          while (
                                              (node =
                                                  (++nodeIndex && node && node[dir]) ||
                                                  // Fallback to seeking `elem` from the start
                                                  (diff = nodeIndex = 0) ||
                                                  start.pop())
                                          ) {
                                              // When found, cache indexes on `parent` and break
                                              if (node.nodeType === 1 && ++diff && node === elem) {
                                                  outerCache[type] = [dirruns, nodeIndex, diff];
                                                  break;
                                              }
                                          }

                                          // Use previously-cached element index if available
                                      } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                                          diff = cache[1];

                                          // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                      } else {
                                          // Use the same loop as above to seek `elem` from the start
                                          while ((node = (++nodeIndex && node && node[dir]) || (diff = nodeIndex = 0) || start.pop())) {
                                              if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                                  // Cache the index of each encountered element
                                                  if (useCache) {
                                                      (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
                                                  }

                                                  if (node === elem) {
                                                      break;
                                                  }
                                              }
                                          }
                                      }

                                      // Incorporate the offset, then check against cycle size
                                      diff -= last;
                                      return diff === first || (diff % first === 0 && diff / first >= 0);
                                  }
                              };
                    },

                    'PSEUDO': function (pseudo, argument) {
                        // pseudo-class names are case-insensitive
                        // http://www.w3.org/TR/selectors/#pseudo-classes
                        // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                        // Remember that setFilters inherits from pseudos
                        var args,
                            fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);

                        // The user may use createPseudo to indicate that
                        // arguments are needed to create the filter function
                        // just as Sizzle does
                        if (fn[expando]) {
                            return fn(argument);
                        }

                        // But maintain support for old signatures
                        if (fn.length > 1) {
                            args = [pseudo, pseudo, '', argument];
                            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase())
                                ? markFunction(function (seed, matches) {
                                      var idx,
                                          matched = fn(seed, argument),
                                          i = matched.length;
                                      while (i--) {
                                          idx = indexOf(seed, matched[i]);
                                          seed[idx] = !(matches[idx] = matched[i]);
                                      }
                                  })
                                : function (elem) {
                                      return fn(elem, 0, args);
                                  };
                        }

                        return fn;
                    },
                },

                pseudos: {
                    // Potentially complex pseudos
                    'not': markFunction(function (selector) {
                        // Trim the selector passed to compile
                        // to avoid treating leading and trailing
                        // spaces as combinators
                        var input = [],
                            results = [],
                            matcher = compile(selector.replace(rtrim, '$1'));

                        return matcher[expando]
                            ? markFunction(function (seed, matches, context, xml) {
                                  var elem,
                                      unmatched = matcher(seed, null, xml, []),
                                      i = seed.length;

                                  // Match elements unmatched by `matcher`
                                  while (i--) {
                                      if ((elem = unmatched[i])) {
                                          seed[i] = !(matches[i] = elem);
                                      }
                                  }
                              })
                            : function (elem, context, xml) {
                                  input[0] = elem;
                                  matcher(input, null, xml, results);
                                  // Don't keep the element (issue #299)
                                  input[0] = null;
                                  return !results.pop();
                              };
                    }),

                    'has': markFunction(function (selector) {
                        return function (elem) {
                            return Sizzle(selector, elem).length > 0;
                        };
                    }),

                    'contains': markFunction(function (text) {
                        text = text.replace(runescape, funescape);
                        return function (elem) {
                            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                        };
                    }),

                    // "Whether an element is represented by a :lang() selector
                    // is based solely on the element's language value
                    // being equal to the identifier C,
                    // or beginning with the identifier C immediately followed by "-".
                    // The matching of C against the element's language value is performed case-insensitively.
                    // The identifier C does not have to be a valid language name."
                    // http://www.w3.org/TR/selectors/#lang-pseudo
                    'lang': markFunction(function (lang) {
                        // lang value must be a valid identifier
                        if (!ridentifier.test(lang || '')) {
                            Sizzle.error('unsupported lang: ' + lang);
                        }
                        lang = lang.replace(runescape, funescape).toLowerCase();
                        return function (elem) {
                            var elemLang;
                            do {
                                if ((elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang'))) {
                                    elemLang = elemLang.toLowerCase();
                                    return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
                                }
                            } while ((elem = elem.parentNode) && elem.nodeType === 1);
                            return false;
                        };
                    }),

                    // Miscellaneous
                    'target': function (elem) {
                        var hash = window.location && window.location.hash;
                        return hash && hash.slice(1) === elem.id;
                    },

                    'root': function (elem) {
                        return elem === docElem;
                    },

                    'focus': function (elem) {
                        return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                    },

                    // Boolean properties
                    'enabled': function (elem) {
                        return elem.disabled === false;
                    },

                    'disabled': function (elem) {
                        return elem.disabled === true;
                    },

                    'checked': function (elem) {
                        // In CSS3, :checked should return both checked and selected elements
                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                        var nodeName = elem.nodeName.toLowerCase();
                        return (nodeName === 'input' && !!elem.checked) || (nodeName === 'option' && !!elem.selected);
                    },

                    'selected': function (elem) {
                        // Accessing this property makes selected-by-default
                        // options in Safari work properly
                        if (elem.parentNode) {
                            elem.parentNode.selectedIndex;
                        }

                        return elem.selected === true;
                    },

                    // Contents
                    'empty': function (elem) {
                        // http://www.w3.org/TR/selectors/#empty-pseudo
                        // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                        //   but not by others (comment: 8; processing instruction: 7; etc.)
                        // nodeType < 6 works because attributes (2) do not appear as children
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            if (elem.nodeType < 6) {
                                return false;
                            }
                        }
                        return true;
                    },

                    'parent': function (elem) {
                        return !Expr.pseudos['empty'](elem);
                    },

                    // Element/input types
                    'header': function (elem) {
                        return rheader.test(elem.nodeName);
                    },

                    'input': function (elem) {
                        return rinputs.test(elem.nodeName);
                    },

                    'button': function (elem) {
                        var name = elem.nodeName.toLowerCase();
                        return (name === 'input' && elem.type === 'button') || name === 'button';
                    },

                    'text': function (elem) {
                        var attr;
                        return (
                            elem.nodeName.toLowerCase() === 'input' &&
                            elem.type === 'text' &&
                            // Support: IE<8
                            // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                            ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text')
                        );
                    },

                    // Position-in-collection
                    'first': createPositionalPseudo(function () {
                        return [0];
                    }),

                    'last': createPositionalPseudo(function (matchIndexes, length) {
                        return [length - 1];
                    }),

                    'eq': createPositionalPseudo(function (matchIndexes, length, argument) {
                        return [argument < 0 ? argument + length : argument];
                    }),

                    'even': createPositionalPseudo(function (matchIndexes, length) {
                        var i = 0;
                        for (; i < length; i += 2) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),

                    'odd': createPositionalPseudo(function (matchIndexes, length) {
                        var i = 1;
                        for (; i < length; i += 2) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),

                    'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
                        var i = argument < 0 ? argument + length : argument;
                        for (; --i >= 0; ) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),

                    'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
                        var i = argument < 0 ? argument + length : argument;
                        for (; ++i < length; ) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),
                },
            };

            Expr.pseudos['nth'] = Expr.pseudos['eq'];

            // Add button/input type pseudos
            for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
                Expr.pseudos[i] = createInputPseudo(i);
            }
            for (i in { submit: true, reset: true }) {
                Expr.pseudos[i] = createButtonPseudo(i);
            }

            // Easy API for creating new setFilters
            function setFilters() {}
            setFilters.prototype = Expr.filters = Expr.pseudos;
            Expr.setFilters = new setFilters();

            tokenize = Sizzle.tokenize = function (selector, parseOnly) {
                var matched,
                    match,
                    tokens,
                    type,
                    soFar,
                    groups,
                    preFilters,
                    cached = tokenCache[selector + ' '];

                if (cached) {
                    return parseOnly ? 0 : cached.slice(0);
                }

                soFar = selector;
                groups = [];
                preFilters = Expr.preFilter;

                while (soFar) {
                    // Comma and first run
                    if (!matched || (match = rcomma.exec(soFar))) {
                        if (match) {
                            // Don't consume trailing commas as valid
                            soFar = soFar.slice(match[0].length) || soFar;
                        }
                        groups.push((tokens = []));
                    }

                    matched = false;

                    // Combinators
                    if ((match = rcombinators.exec(soFar))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            // Cast descendant combinators to space
                            type: match[0].replace(rtrim, ' '),
                        });
                        soFar = soFar.slice(matched.length);
                    }

                    // Filters
                    for (type in Expr.filter) {
                        if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                            matched = match.shift();
                            tokens.push({
                                value: matched,
                                type: type,
                                matches: match,
                            });
                            soFar = soFar.slice(matched.length);
                        }
                    }

                    if (!matched) {
                        break;
                    }
                }

                // Return the length of the invalid excess
                // if we're just parsing
                // Otherwise, throw an error or return tokens
                return parseOnly
                    ? soFar.length
                    : soFar
                    ? Sizzle.error(selector)
                    : // Cache the tokens
                      tokenCache(selector, groups).slice(0);
            };

            function toSelector(tokens) {
                var i = 0,
                    len = tokens.length,
                    selector = '';
                for (; i < len; i++) {
                    selector += tokens[i].value;
                }
                return selector;
            }

            function addCombinator(matcher, combinator, base) {
                var dir = combinator.dir,
                    checkNonElements = base && dir === 'parentNode',
                    doneName = done++;

                return combinator.first
                    ? // Check against closest ancestor/preceding element
                      function (elem, context, xml) {
                          while ((elem = elem[dir])) {
                              if (elem.nodeType === 1 || checkNonElements) {
                                  return matcher(elem, context, xml);
                              }
                          }
                      }
                    : // Check against all ancestor/preceding elements
                      function (elem, context, xml) {
                          var oldCache,
                              outerCache,
                              newCache = [dirruns, doneName];

                          // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
                          if (xml) {
                              while ((elem = elem[dir])) {
                                  if (elem.nodeType === 1 || checkNonElements) {
                                      if (matcher(elem, context, xml)) {
                                          return true;
                                      }
                                  }
                              }
                          } else {
                              while ((elem = elem[dir])) {
                                  if (elem.nodeType === 1 || checkNonElements) {
                                      outerCache = elem[expando] || (elem[expando] = {});
                                      if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                          // Assign to newCache so results back-propagate to previous elements
                                          return (newCache[2] = oldCache[2]);
                                      } else {
                                          // Reuse newcache so results back-propagate to previous elements
                                          outerCache[dir] = newCache;

                                          // A match means we're done; a fail means we have to keep checking
                                          if ((newCache[2] = matcher(elem, context, xml))) {
                                              return true;
                                          }
                                      }
                                  }
                              }
                          }
                      };
            }

            function elementMatcher(matchers) {
                return matchers.length > 1
                    ? function (elem, context, xml) {
                          var i = matchers.length;
                          while (i--) {
                              if (!matchers[i](elem, context, xml)) {
                                  return false;
                              }
                          }
                          return true;
                      }
                    : matchers[0];
            }

            function multipleContexts(selector, contexts, results) {
                var i = 0,
                    len = contexts.length;
                for (; i < len; i++) {
                    Sizzle(selector, contexts[i], results);
                }
                return results;
            }

            function condense(unmatched, map, filter, context, xml) {
                var elem,
                    newUnmatched = [],
                    i = 0,
                    len = unmatched.length,
                    mapped = map != null;

                for (; i < len; i++) {
                    if ((elem = unmatched[i])) {
                        if (!filter || filter(elem, context, xml)) {
                            newUnmatched.push(elem);
                            if (mapped) {
                                map.push(i);
                            }
                        }
                    }
                }

                return newUnmatched;
            }

            function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                if (postFilter && !postFilter[expando]) {
                    postFilter = setMatcher(postFilter);
                }
                if (postFinder && !postFinder[expando]) {
                    postFinder = setMatcher(postFinder, postSelector);
                }
                return markFunction(function (seed, results, context, xml) {
                    var temp,
                        i,
                        elem,
                        preMap = [],
                        postMap = [],
                        preexisting = results.length,
                        // Get initial elements from seed or context
                        elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []),
                        // Prefilter to get matcher input, preserving a map for seed-results synchronization
                        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
                        matcherOut = matcher
                            ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                              postFinder || (seed ? preFilter : preexisting || postFilter)
                                ? // ...intermediate processing is necessary
                                  []
                                : // ...otherwise use results directly
                                  results
                            : matcherIn;

                    // Find primary matches
                    if (matcher) {
                        matcher(matcherIn, matcherOut, context, xml);
                    }

                    // Apply postFilter
                    if (postFilter) {
                        temp = condense(matcherOut, postMap);
                        postFilter(temp, [], context, xml);

                        // Un-match failing elements by moving them back to matcherIn
                        i = temp.length;
                        while (i--) {
                            if ((elem = temp[i])) {
                                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                            }
                        }
                    }

                    if (seed) {
                        if (postFinder || preFilter) {
                            if (postFinder) {
                                // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                temp = [];
                                i = matcherOut.length;
                                while (i--) {
                                    if ((elem = matcherOut[i])) {
                                        // Restore matcherIn since elem is not yet a final match
                                        temp.push((matcherIn[i] = elem));
                                    }
                                }
                                postFinder(null, (matcherOut = []), temp, xml);
                            }

                            // Move matched elements from seed to results to keep them synchronized
                            i = matcherOut.length;
                            while (i--) {
                                if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                                    seed[temp] = !(results[temp] = elem);
                                }
                            }
                        }

                        // Add elements to results, through postFinder if defined
                    } else {
                        matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                        if (postFinder) {
                            postFinder(null, results, matcherOut, xml);
                        } else {
                            push.apply(results, matcherOut);
                        }
                    }
                });
            }

            function matcherFromTokens(tokens) {
                var checkContext,
                    matcher,
                    j,
                    len = tokens.length,
                    leadingRelative = Expr.relative[tokens[0].type],
                    implicitRelative = leadingRelative || Expr.relative[' '],
                    i = leadingRelative ? 1 : 0,
                    // The foundational matcher ensures that elements are reachable from top-level context(s)
                    matchContext = addCombinator(
                        function (elem) {
                            return elem === checkContext;
                        },
                        implicitRelative,
                        true
                    ),
                    matchAnyContext = addCombinator(
                        function (elem) {
                            return indexOf(checkContext, elem) > -1;
                        },
                        implicitRelative,
                        true
                    ),
                    matchers = [
                        function (elem, context, xml) {
                            var ret =
                                (!leadingRelative && (xml || context !== outermostContext)) ||
                                ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                            // Avoid hanging onto element (issue #299)
                            checkContext = null;
                            return ret;
                        },
                    ];

                for (; i < len; i++) {
                    if ((matcher = Expr.relative[tokens[i].type])) {
                        matchers = [addCombinator(elementMatcher(matchers), matcher)];
                    } else {
                        matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

                        // Return special upon seeing a positional matcher
                        if (matcher[expando]) {
                            // Find the next relative operator (if any) for proper handling
                            j = ++i;
                            for (; j < len; j++) {
                                if (Expr.relative[tokens[j].type]) {
                                    break;
                                }
                            }
                            return setMatcher(
                                i > 1 && elementMatcher(matchers),
                                i > 1 &&
                                    toSelector(
                                        // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                                        tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })
                                    ).replace(rtrim, '$1'),
                                matcher,
                                i < j && matcherFromTokens(tokens.slice(i, j)),
                                j < len && matcherFromTokens((tokens = tokens.slice(j))),
                                j < len && toSelector(tokens)
                            );
                        }
                        matchers.push(matcher);
                    }
                }

                return elementMatcher(matchers);
            }

            function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                var bySet = setMatchers.length > 0,
                    byElement = elementMatchers.length > 0,
                    superMatcher = function (seed, context, xml, results, outermost) {
                        var elem,
                            j,
                            matcher,
                            matchedCount = 0,
                            i = '0',
                            unmatched = seed && [],
                            setMatched = [],
                            contextBackup = outermostContext,
                            // We must always have either seed elements or outermost context
                            elems = seed || (byElement && Expr.find['TAG']('*', outermost)),
                            // Use integer dirruns iff this is the outermost matcher
                            dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                            len = elems.length;

                        if (outermost) {
                            outermostContext = context !== document && context;
                        }

                        // Add elements passing elementMatchers directly to results
                        // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
                        // Support: IE<9, Safari
                        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                        for (; i !== len && (elem = elems[i]) != null; i++) {
                            if (byElement && elem) {
                                j = 0;
                                while ((matcher = elementMatchers[j++])) {
                                    if (matcher(elem, context, xml)) {
                                        results.push(elem);
                                        break;
                                    }
                                }
                                if (outermost) {
                                    dirruns = dirrunsUnique;
                                }
                            }

                            // Track unmatched elements for set filters
                            if (bySet) {
                                // They will have gone through all possible matchers
                                if ((elem = !matcher && elem)) {
                                    matchedCount--;
                                }

                                // Lengthen the array for every element, matched or not
                                if (seed) {
                                    unmatched.push(elem);
                                }
                            }
                        }

                        // Apply set filters to unmatched elements
                        matchedCount += i;
                        if (bySet && i !== matchedCount) {
                            j = 0;
                            while ((matcher = setMatchers[j++])) {
                                matcher(unmatched, setMatched, context, xml);
                            }

                            if (seed) {
                                // Reintegrate element matches to eliminate the need for sorting
                                if (matchedCount > 0) {
                                    while (i--) {
                                        if (!(unmatched[i] || setMatched[i])) {
                                            setMatched[i] = pop.call(results);
                                        }
                                    }
                                }

                                // Discard index placeholder values to get only actual matches
                                setMatched = condense(setMatched);
                            }

                            // Add matches to results
                            push.apply(results, setMatched);

                            // Seedless set matches succeeding multiple successful matchers stipulate sorting
                            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                                Sizzle.uniqueSort(results);
                            }
                        }

                        // Override manipulation of globals by nested matchers
                        if (outermost) {
                            dirruns = dirrunsUnique;
                            outermostContext = contextBackup;
                        }

                        return unmatched;
                    };

                return bySet ? markFunction(superMatcher) : superMatcher;
            }

            compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
                var i,
                    setMatchers = [],
                    elementMatchers = [],
                    cached = compilerCache[selector + ' '];

                if (!cached) {
                    // Generate a function of recursive functions that can be used to check each element
                    if (!match) {
                        match = tokenize(selector);
                    }
                    i = match.length;
                    while (i--) {
                        cached = matcherFromTokens(match[i]);
                        if (cached[expando]) {
                            setMatchers.push(cached);
                        } else {
                            elementMatchers.push(cached);
                        }
                    }

                    // Cache the compiled function
                    cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

                    // Save selector and tokenization
                    cached.selector = selector;
                }
                return cached;
            };

            /**
             * A low-level selection function that works with Sizzle's compiled
             *  selector functions
             * @param {String|Function} selector A selector or a pre-compiled
             *  selector function built with Sizzle.compile
             * @param {Element} context
             * @param {Array} [results]
             * @param {Array} [seed] A set of elements to match against
             */
            select = Sizzle.select = function (selector, context, results, seed) {
                var i,
                    tokens,
                    token,
                    type,
                    find,
                    compiled = typeof selector === 'function' && selector,
                    match = !seed && tokenize((selector = compiled.selector || selector));

                results = results || [];

                // Try to minimize operations if there is no seed and only one group
                if (match.length === 1) {
                    // Take a shortcut and set the context if the root selector is an ID
                    tokens = match[0] = match[0].slice(0);
                    if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                        context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
                        if (!context) {
                            return results;

                            // Precompiled matchers will still verify ancestry, so step up a level
                        } else if (compiled) {
                            context = context.parentNode;
                        }

                        selector = selector.slice(tokens.shift().value.length);
                    }

                    // Fetch a seed set for right-to-left matching
                    i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
                    while (i--) {
                        token = tokens[i];

                        // Abort if we hit a combinator
                        if (Expr.relative[(type = token.type)]) {
                            break;
                        }
                        if ((find = Expr.find[type])) {
                            // Search, expanding context for leading sibling combinators
                            if ((seed = find(token.matches[0].replace(runescape, funescape), (rsibling.test(tokens[0].type) && testContext(context.parentNode)) || context))) {
                                // If seed is empty or no tokens remain, we can return early
                                tokens.splice(i, 1);
                                selector = seed.length && toSelector(tokens);
                                if (!selector) {
                                    push.apply(results, seed);
                                    return results;
                                }

                                break;
                            }
                        }
                    }
                }

                // Compile and execute a filtering function if one is not provided
                // Provide `match` to avoid retokenization if we modified the selector above
                (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, (rsibling.test(selector) && testContext(context.parentNode)) || context);
                return results;
            };

            // One-time assignments

            // Sort stability
            support.sortStable = expando.split('').sort(sortOrder).join('') === expando;

            // Support: Chrome 14-35+
            // Always assume duplicates if they aren't passed to the comparison function
            support.detectDuplicates = !!hasDuplicate;

            // Initialize against the default document
            setDocument();

            // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
            // Detached nodes confoundingly follow *each other*
            support.sortDetached = assert(function (div1) {
                // Should return 1, but returns 4 (following)
                return div1.compareDocumentPosition(document.createElement('div')) & 1;
            });

            // Support: IE<8
            // Prevent attribute/property "interpolation"
            // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
            if (
                !assert(function (div) {
                    div.innerHTML = "<a href='#'></a>";
                    return div.firstChild.getAttribute('href') === '#';
                })
            ) {
                addHandle('type|href|height|width', function (elem, name, isXML) {
                    if (!isXML) {
                        return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
                    }
                });
            }

            // Support: IE<9
            // Use defaultValue in place of getAttribute("value")
            if (
                !support.attributes ||
                !assert(function (div) {
                    div.innerHTML = '<input/>';
                    div.firstChild.setAttribute('value', '');
                    return div.firstChild.getAttribute('value') === '';
                })
            ) {
                addHandle('value', function (elem, name, isXML) {
                    if (!isXML && elem.nodeName.toLowerCase() === 'input') {
                        return elem.defaultValue;
                    }
                });
            }

            // Support: IE<9
            // Use getAttributeNode to fetch booleans when getAttribute lies
            if (
                !assert(function (div) {
                    return div.getAttribute('disabled') == null;
                })
            ) {
                addHandle(booleans, function (elem, name, isXML) {
                    var val;
                    if (!isXML) {
                        return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                    }
                });
            }

            return Sizzle;
        })(window);

    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[':'] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;

    var rneedsContext = jQuery.expr.match.needsContext;

    var rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;

    var risSimple = /^.[^:#\[\.,]*$/;

    // Implement the identical functionality for filter and not
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                /* jshint -W018 */
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }

        if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem) {
                return (elem === qualifier) !== not;
            });
        }

        if (typeof qualifier === 'string') {
            if (risSimple.test(qualifier)) {
                return jQuery.filter(qualifier, elements, not);
            }

            qualifier = jQuery.filter(qualifier, elements);
        }

        return jQuery.grep(elements, function (elem) {
            return jQuery.inArray(elem, qualifier) >= 0 !== not;
        });
    }

    jQuery.filter = function (expr, elems, not) {
        var elem = elems[0];

        if (not) {
            expr = ':not(' + expr + ')';
        }

        return elems.length === 1 && elem.nodeType === 1
            ? jQuery.find.matchesSelector(elem, expr)
                ? [elem]
                : []
            : jQuery.find.matches(
                  expr,
                  jQuery.grep(elems, function (elem) {
                      return elem.nodeType === 1;
                  })
              );
    };

    jQuery.fn.extend({
        find: function (selector) {
            var i,
                ret = [],
                self = this,
                len = self.length;

            if (typeof selector !== 'string') {
                return this.pushStack(
                    jQuery(selector).filter(function () {
                        for (i = 0; i < len; i++) {
                            if (jQuery.contains(self[i], this)) {
                                return true;
                            }
                        }
                    })
                );
            }

            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }

            // Needed because $( selector, context ) becomes $( context ).find( selector )
            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
            ret.selector = this.selector ? this.selector + ' ' + selector : selector;
            return ret;
        },
        filter: function (selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function (selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function (selector) {
            return !!winnow(
                this,

                // If this is a positional/relative selector, check membership in the returned set
                // so $("p:first").is("p:last") won't return true for a doc with two "p".
                typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [],
                false
            ).length;
        },
    });

    // Initialize a jQuery object

    // A central reference to the root jQuery(document)
    var rootjQuery,
        // Use the correct document accordingly with window argument (sandbox)
        document = window.document,
        // A simple way to check for HTML strings
        // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
        // Strict HTML recognition (#11290: must start with <)
        rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
        init = (jQuery.fn.init = function (selector, context) {
            var match, elem;

            // HANDLE: $(""), $(null), $(undefined), $(false)
            if (!selector) {
                return this;
            }

            // Handle HTML strings
            if (typeof selector === 'string') {
                if (selector.charAt(0) === '<' && selector.charAt(selector.length - 1) === '>' && selector.length >= 3) {
                    // Assume that strings that start and end with <> are HTML and skip the regex check
                    match = [null, selector, null];
                } else {
                    match = rquickExpr.exec(selector);
                }

                // Match html or make sure no context is specified for #id
                if (match && (match[1] || !context)) {
                    // HANDLE: $(html) -> $(array)
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context;

                        // scripts is true for back-compat
                        // Intentionally let the error be thrown if parseHTML is not present
                        jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));

                        // HANDLE: $(html, props)
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                            for (match in context) {
                                // Properties of context are called as methods if possible
                                if (jQuery.isFunction(this[match])) {
                                    this[match](context[match]);

                                    // ...and otherwise set as attributes
                                } else {
                                    this.attr(match, context[match]);
                                }
                            }
                        }

                        return this;

                        // HANDLE: $(#id)
                    } else {
                        elem = document.getElementById(match[2]);

                        // Check parentNode to catch when Blackberry 4.6 returns
                        // nodes that are no longer in the document #6963
                        if (elem && elem.parentNode) {
                            // Handle the case where IE and Opera return items
                            // by name instead of ID
                            if (elem.id !== match[2]) {
                                return rootjQuery.find(selector);
                            }

                            // Otherwise, we inject the element directly into the jQuery object
                            this.length = 1;
                            this[0] = elem;
                        }

                        this.context = document;
                        this.selector = selector;
                        return this;
                    }

                    // HANDLE: $(expr, $(...))
                } else if (!context || context.jquery) {
                    return (context || rootjQuery).find(selector);

                    // HANDLE: $(expr, context)
                    // (which is just equivalent to: $(context).find(expr)
                } else {
                    return this.constructor(context).find(selector);
                }

                // HANDLE: $(DOMElement)
            } else if (selector.nodeType) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;

                // HANDLE: $(function)
                // Shortcut for document ready
            } else if (jQuery.isFunction(selector)) {
                return typeof rootjQuery.ready !== 'undefined'
                    ? rootjQuery.ready(selector)
                    : // Execute immediately if ready is not present
                      selector(jQuery);
            }

            if (selector.selector !== undefined) {
                this.selector = selector.selector;
                this.context = selector.context;
            }

            return jQuery.makeArray(selector, this);
        });

    // Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;

    // Initialize central reference
    rootjQuery = jQuery(document);

    var rparentsprev = /^(?:parents|prev(?:Until|All))/,
        // methods guaranteed to produce a unique set when starting from a unique set
        guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true,
        };

    jQuery.extend({
        dir: function (elem, dir, until) {
            var matched = [],
                cur = elem[dir];

            while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {
                if (cur.nodeType === 1) {
                    matched.push(cur);
                }
                cur = cur[dir];
            }
            return matched;
        },

        sibling: function (n, elem) {
            var r = [];

            for (; n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    r.push(n);
                }
            }

            return r;
        },
    });

    jQuery.fn.extend({
        has: function (target) {
            var i,
                targets = jQuery(target, this),
                len = targets.length;

            return this.filter(function () {
                for (i = 0; i < len; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },

        closest: function (selectors, context) {
            var cur,
                i = 0,
                l = this.length,
                matched = [],
                pos = rneedsContext.test(selectors) || typeof selectors !== 'string' ? jQuery(selectors, context || this.context) : 0;

            for (; i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                    // Always skip document fragments
                    if (
                        cur.nodeType < 11 &&
                        (pos
                            ? pos.index(cur) > -1
                            : // Don't pass non-elements to Sizzle
                              cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))
                    ) {
                        matched.push(cur);
                        break;
                    }
                }
            }

            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
        },

        // Determine the position of an element within
        // the matched set of elements
        index: function (elem) {
            // No argument, return index in parent
            if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }

            // index in selector
            if (typeof elem === 'string') {
                return jQuery.inArray(this[0], jQuery(elem));
            }

            // Locate the position of the desired element
            return jQuery.inArray(
                // If it receives a jQuery object, the first element is used
                elem.jquery ? elem[0] : elem,
                this
            );
        },

        add: function (selector, context) {
            return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
        },

        addBack: function (selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        },
    });

    function sibling(cur, dir) {
        do {
            cur = cur[dir];
        } while (cur && cur.nodeType !== 1);

        return cur;
    }

    jQuery.each(
        {
            parent: function (elem) {
                var parent = elem.parentNode;
                return parent && parent.nodeType !== 11 ? parent : null;
            },
            parents: function (elem) {
                return jQuery.dir(elem, 'parentNode');
            },
            parentsUntil: function (elem, i, until) {
                return jQuery.dir(elem, 'parentNode', until);
            },
            next: function (elem) {
                return sibling(elem, 'nextSibling');
            },
            prev: function (elem) {
                return sibling(elem, 'previousSibling');
            },
            nextAll: function (elem) {
                return jQuery.dir(elem, 'nextSibling');
            },
            prevAll: function (elem) {
                return jQuery.dir(elem, 'previousSibling');
            },
            nextUntil: function (elem, i, until) {
                return jQuery.dir(elem, 'nextSibling', until);
            },
            prevUntil: function (elem, i, until) {
                return jQuery.dir(elem, 'previousSibling', until);
            },
            siblings: function (elem) {
                return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
            },
            children: function (elem) {
                return jQuery.sibling(elem.firstChild);
            },
            contents: function (elem) {
                return jQuery.nodeName(elem, 'iframe') ? elem.contentDocument || elem.contentWindow.document : jQuery.merge([], elem.childNodes);
            },
        },
        function (name, fn) {
            jQuery.fn[name] = function (until, selector) {
                var ret = jQuery.map(this, fn, until);

                if (name.slice(-5) !== 'Until') {
                    selector = until;
                }

                if (selector && typeof selector === 'string') {
                    ret = jQuery.filter(selector, ret);
                }

                if (this.length > 1) {
                    // Remove duplicates
                    if (!guaranteedUnique[name]) {
                        ret = jQuery.unique(ret);
                    }

                    // Reverse order for parents* and prev-derivatives
                    if (rparentsprev.test(name)) {
                        ret = ret.reverse();
                    }
                }

                return this.pushStack(ret);
            };
        }
    );
    var rnotwhite = /\S+/g;

    // String to Object options format cache
    var optionsCache = {};

    // Convert String-formatted options into Object-formatted ones and store in cache
    function createOptions(options) {
        var object = (optionsCache[options] = {});
        jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
            object[flag] = true;
        });
        return object;
    }

    /*
     * Create a callback list using the following parameters:
     *
     *	options: an optional list of space-separated options that will change how
     *			the callback list behaves or a more traditional option object
     *
     * By default a callback list will act like an event callback list and can be
     * "fired" multiple times.
     *
     * Possible options:
     *
     *	once:			will ensure the callback list can only be fired once (like a Deferred)
     *
     *	memory:			will keep track of previous values and will call any callback added
     *					after the list has been fired right away with the latest "memorized"
     *					values (like a Deferred)
     *
     *	unique:			will ensure a callback can only be added once (no duplicate in the list)
     *
     *	stopOnFalse:	interrupt callings when a callback returns false
     *
     */
    jQuery.Callbacks = function (options) {
        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === 'string' ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);

        var // Flag to know if list is currently firing
            firing,
            // Last fire value (for non-forgettable lists)
            memory,
            // Flag to know if list was already fired
            fired,
            // End of the loop when firing
            firingLength,
            // Index of currently firing callback (modified by remove if needed)
            firingIndex,
            // First callback to fire (used internally by add and fireWith)
            firingStart,
            // Actual callback list
            list = [],
            // Stack of fire calls for repeatable lists
            stack = !options.once && [],
            // Fire callbacks
            fire = function (data) {
                memory = options.memory && data;
                fired = true;
                firingIndex = firingStart || 0;
                firingStart = 0;
                firingLength = list.length;
                firing = true;
                for (; list && firingIndex < firingLength; firingIndex++) {
                    if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                        memory = false; // To prevent further calls using add
                        break;
                    }
                }
                firing = false;
                if (list) {
                    if (stack) {
                        if (stack.length) {
                            fire(stack.shift());
                        }
                    } else if (memory) {
                        list = [];
                    } else {
                        self.disable();
                    }
                }
            },
            // Actual Callbacks object
            self = {
                // Add a callback or a collection of callbacks to the list
                add: function () {
                    if (list) {
                        // First, we save the current length
                        var start = list.length;
                        (function add(args) {
                            jQuery.each(args, function (_, arg) {
                                var type = jQuery.type(arg);
                                if (type === 'function') {
                                    if (!options.unique || !self.has(arg)) {
                                        list.push(arg);
                                    }
                                } else if (arg && arg.length && type !== 'string') {
                                    // Inspect recursively
                                    add(arg);
                                }
                            });
                        })(arguments);
                        // Do we need to add the callbacks to the
                        // current firing batch?
                        if (firing) {
                            firingLength = list.length;
                            // With memory, if we're not firing then
                            // we should call right away
                        } else if (memory) {
                            firingStart = start;
                            fire(memory);
                        }
                    }
                    return this;
                },
                // Remove a callback from the list
                remove: function () {
                    if (list) {
                        jQuery.each(arguments, function (_, arg) {
                            var index;
                            while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                list.splice(index, 1);
                                // Handle firing indexes
                                if (firing) {
                                    if (index <= firingLength) {
                                        firingLength--;
                                    }
                                    if (index <= firingIndex) {
                                        firingIndex--;
                                    }
                                }
                            }
                        });
                    }
                    return this;
                },
                // Check if a given callback is in the list.
                // If no argument is given, return whether or not list has callbacks attached.
                has: function (fn) {
                    return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
                },
                // Remove all callbacks from the list
                empty: function () {
                    list = [];
                    firingLength = 0;
                    return this;
                },
                // Have the list do nothing anymore
                disable: function () {
                    list = stack = memory = undefined;
                    return this;
                },
                // Is it disabled?
                disabled: function () {
                    return !list;
                },
                // Lock the list in its current state
                lock: function () {
                    stack = undefined;
                    if (!memory) {
                        self.disable();
                    }
                    return this;
                },
                // Is it locked?
                locked: function () {
                    return !stack;
                },
                // Call all callbacks with the given context and arguments
                fireWith: function (context, args) {
                    if (list && (!fired || stack)) {
                        args = args || [];
                        args = [context, args.slice ? args.slice() : args];
                        if (firing) {
                            stack.push(args);
                        } else {
                            fire(args);
                        }
                    }
                    return this;
                },
                // Call all the callbacks with the given arguments
                fire: function () {
                    self.fireWith(this, arguments);
                    return this;
                },
                // To know if the callbacks have already been called at least once
                fired: function () {
                    return !!fired;
                },
            };

        return self;
    };

    jQuery.extend({
        Deferred: function (func) {
            var tuples = [
                    // action, add listener, listener list, final state
                    ['resolve', 'done', jQuery.Callbacks('once memory'), 'resolved'],
                    ['reject', 'fail', jQuery.Callbacks('once memory'), 'rejected'],
                    ['notify', 'progress', jQuery.Callbacks('memory')],
                ],
                state = 'pending',
                promise = {
                    state: function () {
                        return state;
                    },
                    always: function () {
                        deferred.done(arguments).fail(arguments);
                        return this;
                    },
                    then: function (/* fnDone, fnFail, fnProgress */) {
                        var fns = arguments;
                        return jQuery
                            .Deferred(function (newDefer) {
                                jQuery.each(tuples, function (i, tuple) {
                                    var fn = jQuery.isFunction(fns[i]) && fns[i];
                                    // deferred[ done | fail | progress ] for forwarding actions to newDefer
                                    deferred[tuple[1]](function () {
                                        var returned = fn && fn.apply(this, arguments);
                                        if (returned && jQuery.isFunction(returned.promise)) {
                                            returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                                        } else {
                                            newDefer[tuple[0] + 'With'](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                                        }
                                    });
                                });
                                fns = null;
                            })
                            .promise();
                    },
                    // Get a promise for this deferred
                    // If obj is provided, the promise aspect is added to the object
                    promise: function (obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise;
                    },
                },
                deferred = {};

            // Keep pipe for back-compat
            promise.pipe = promise.then;

            // Add list-specific methods
            jQuery.each(tuples, function (i, tuple) {
                var list = tuple[2],
                    stateString = tuple[3];

                // promise[ done | fail | progress ] = list.add
                promise[tuple[1]] = list.add;

                // Handle state
                if (stateString) {
                    list.add(
                        function () {
                            // state = [ resolved | rejected ]
                            state = stateString;

                            // [ reject_list | resolve_list ].disable; progress_list.lock
                        },
                        tuples[i ^ 1][2].disable,
                        tuples[2][2].lock
                    );
                }

                // deferred[ resolve | reject | notify ]
                deferred[tuple[0]] = function () {
                    deferred[tuple[0] + 'With'](this === deferred ? promise : this, arguments);
                    return this;
                };
                deferred[tuple[0] + 'With'] = list.fireWith;
            });

            // Make the deferred a promise
            promise.promise(deferred);

            // Call given func if any
            if (func) {
                func.call(deferred, deferred);
            }

            // All done!
            return deferred;
        },

        // Deferred helper
        when: function (subordinate /* , ..., subordinateN */) {
            var i = 0,
                resolveValues = slice.call(arguments),
                length = resolveValues.length,
                // the count of uncompleted subordinates
                remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,
                // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
                deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
                // Update function for both resolve and progress values
                updateFunc = function (i, contexts, values) {
                    return function (value) {
                        contexts[i] = this;
                        values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                        if (values === progressValues) {
                            deferred.notifyWith(contexts, values);
                        } else if (!--remaining) {
                            deferred.resolveWith(contexts, values);
                        }
                    };
                },
                progressValues,
                progressContexts,
                resolveContexts;

            // add listeners to Deferred subordinates; treat others as resolved
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (; i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i]
                            .promise()
                            .done(updateFunc(i, resolveContexts, resolveValues))
                            .fail(deferred.reject)
                            .progress(updateFunc(i, progressContexts, progressValues));
                    } else {
                        --remaining;
                    }
                }
            }

            // if we're not waiting on anything, resolve the master
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues);
            }

            return deferred.promise();
        },
    });

    // The deferred used on DOM ready
    var readyList;

    jQuery.fn.ready = function (fn) {
        // Add the callback
        jQuery.ready.promise().done(fn);

        return this;
    };

    jQuery.extend({
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,

        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,

        // Hold (or release) the ready event
        holdReady: function (hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        },

        // Handle when the DOM is ready
        ready: function (wait) {
            // Abort if there are pending holds or we're already ready
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }

            // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
            if (!document.body) {
                return setTimeout(jQuery.ready);
            }

            // Remember that the DOM is ready
            jQuery.isReady = true;

            // If a normal DOM Ready event fired, decrement, and wait if need be
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }

            // If there are functions bound, to execute
            readyList.resolveWith(document, [jQuery]);

            // Trigger any bound ready events
            if (jQuery.fn.triggerHandler) {
                jQuery(document).triggerHandler('ready');
                jQuery(document).off('ready');
            }
        },
    });

    /**
     * Clean-up method for dom ready events
     */
    function detach() {
        if (document.addEventListener) {
            document.removeEventListener('DOMContentLoaded', completed, false);
            window.removeEventListener('load', completed, false);
        } else {
            document.detachEvent('onreadystatechange', completed);
            window.detachEvent('onload', completed);
        }
    }

    /**
     * The ready event handler and self cleanup method
     */
    function completed() {
        // readyState === "complete" is good enough for us to call the dom ready in oldIE
        if (document.addEventListener || event.type === 'load' || document.readyState === 'complete') {
            detach();
            jQuery.ready();
        }
    }

    jQuery.ready.promise = function (obj) {
        if (!readyList) {
            readyList = jQuery.Deferred();

            // Catch cases where $(document).ready() is called after the browser event has already occurred.
            // we once tried to use readyState "interactive" here, but it caused issues like the one
            // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
            if (document.readyState === 'complete') {
                // Handle it asynchronously to allow scripts the opportunity to delay ready
                setTimeout(jQuery.ready);

                // Standards-based browsers support DOMContentLoaded
            } else if (document.addEventListener) {
                // Use the handy event callback
                document.addEventListener('DOMContentLoaded', completed, false);

                // A fallback to window.onload, that will always work
                window.addEventListener('load', completed, false);

                // If IE event model is used
            } else {
                // Ensure firing before onload, maybe late but safe also for iframes
                document.attachEvent('onreadystatechange', completed);

                // A fallback to window.onload, that will always work
                window.attachEvent('onload', completed);

                // If IE and not a frame
                // continually check to see if the document is ready
                var top = false;

                try {
                    top = window.frameElement == null && document.documentElement;
                } catch (e) {}

                if (top && top.doScroll) {
                    (function doScrollCheck() {
                        if (!jQuery.isReady) {
                            try {
                                // Use the trick by Diego Perini
                                // http://javascript.nwbox.com/IEContentLoaded/
                                top.doScroll('left');
                            } catch (e) {
                                return setTimeout(doScrollCheck, 50);
                            }

                            // detach all dom ready events
                            detach();

                            // and execute any waiting functions
                            jQuery.ready();
                        }
                    })();
                }
            }
        }
        return readyList.promise(obj);
    };

    var strundefined = typeof undefined;

    // Support: IE<9
    // Iteration over object's inherited properties before its own
    var i;
    for (i in jQuery(support)) {
        break;
    }
    support.ownLast = i !== '0';

    // Note: most support tests are defined in their respective modules.
    // false until the test is run
    support.inlineBlockNeedsLayout = false;

    // Execute ASAP in case we need to set body.style.zoom
    jQuery(function () {
        // Minified: var a,b,c,d
        var val, div, body, container;

        body = document.getElementsByTagName('body')[0];
        if (!body || !body.style) {
            // Return for frameset docs that don't have a body
            return;
        }

        // Setup
        div = document.createElement('div');
        container = document.createElement('div');
        container.style.cssText = 'position:absolute;border:0;width:0;height:0;top:0;left:-9999px';
        body.appendChild(container).appendChild(div);

        if (typeof div.style.zoom !== strundefined) {
            // Support: IE<8
            // Check if natively block-level elements act like inline-block
            // elements when setting their display to 'inline' and giving
            // them layout
            div.style.cssText = 'display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1';

            support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;
            if (val) {
                // Prevent IE 6 from affecting layout for positioned elements #11048
                // Prevent IE from shrinking the body in IE 7 mode #12869
                // Support: IE<8
                body.style.zoom = 1;
            }
        }

        body.removeChild(container);
    });

    (function () {
        var div = document.createElement('div');

        // Execute the test only if not already executed in another module.
        if (support.deleteExpando == null) {
            // Support: IE<9
            support.deleteExpando = true;
            try {
                delete div.test;
            } catch (e) {
                support.deleteExpando = false;
            }
        }

        // Null elements to avoid leaks in IE.
        div = null;
    })();

    /**
     * Determines whether an object can have data
     */
    jQuery.acceptData = function (elem) {
        var noData = jQuery.noData[(elem.nodeName + ' ').toLowerCase()],
            nodeType = +elem.nodeType || 1;

        // Do not set data on non-element DOM nodes because it will not be cleared (#8335).
        return nodeType !== 1 && nodeType !== 9
            ? false
            : // Nodes accept data unless otherwise specified; rejection can be conditional
              !noData || (noData !== true && elem.getAttribute('classid') === noData);
    };

    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        rmultiDash = /([A-Z])/g;

    function dataAttr(elem, key, data) {
        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if (data === undefined && elem.nodeType === 1) {
            var name = 'data-' + key.replace(rmultiDash, '-$1').toLowerCase();

            data = elem.getAttribute(name);

            if (typeof data === 'string') {
                try {
                    data =
                        data === 'true'
                            ? true
                            : data === 'false'
                            ? false
                            : data === 'null'
                            ? null
                            : // Only convert to a number if it doesn't change the string
                            +data + '' === data
                            ? +data
                            : rbrace.test(data)
                            ? jQuery.parseJSON(data)
                            : data;
                } catch (e) {}

                // Make sure we set the data so it isn't changed later
                jQuery.data(elem, key, data);
            } else {
                data = undefined;
            }
        }

        return data;
    }

    // checks a cache object for emptiness
    function isEmptyDataObject(obj) {
        var name;
        for (name in obj) {
            // if the public data object is empty, the private is still empty
            if (name === 'data' && jQuery.isEmptyObject(obj[name])) {
                continue;
            }
            if (name !== 'toJSON') {
                return false;
            }
        }

        return true;
    }

    function internalData(elem, name, data, pvt /* Internal Use Only */) {
        if (!jQuery.acceptData(elem)) {
            return;
        }

        var ret,
            thisCache,
            internalKey = jQuery.expando,
            // We have to handle DOM nodes and JS objects differently because IE6-7
            // can't GC object references properly across the DOM-JS boundary
            isNode = elem.nodeType,
            // Only DOM nodes need the global jQuery cache; JS object data is
            // attached directly to the object so GC can occur automatically
            cache = isNode ? jQuery.cache : elem,
            // Only defining an ID for JS objects if its cache already exists allows
            // the code to shortcut on the same path as a DOM node with no cache
            id = isNode ? elem[internalKey] : elem[internalKey] && internalKey;

        // Avoid doing any more work than we need to when trying to get data on an
        // object that has no data at all
        if ((!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === 'string') {
            return;
        }

        if (!id) {
            // Only DOM nodes need a new unique ID for each element since their data
            // ends up in the global cache
            if (isNode) {
                id = elem[internalKey] = deletedIds.pop() || jQuery.guid++;
            } else {
                id = internalKey;
            }
        }

        if (!cache[id]) {
            // Avoid exposing jQuery metadata on plain JS objects when the object
            // is serialized using JSON.stringify
            cache[id] = isNode ? {} : { toJSON: jQuery.noop };
        }

        // An object can be passed to jQuery.data instead of a key/value pair; this gets
        // shallow copied over onto the existing cache
        if (typeof name === 'object' || typeof name === 'function') {
            if (pvt) {
                cache[id] = jQuery.extend(cache[id], name);
            } else {
                cache[id].data = jQuery.extend(cache[id].data, name);
            }
        }

        thisCache = cache[id];

        // jQuery data() is stored in a separate object inside the object's internal data
        // cache in order to avoid key collisions between internal data and user-defined
        // data.
        if (!pvt) {
            if (!thisCache.data) {
                thisCache.data = {};
            }

            thisCache = thisCache.data;
        }

        if (data !== undefined) {
            thisCache[jQuery.camelCase(name)] = data;
        }

        // Check for both converted-to-camel and non-converted data property names
        // If a data property was specified
        if (typeof name === 'string') {
            // First Try to find as-is property data
            ret = thisCache[name];

            // Test for null|undefined property data
            if (ret == null) {
                // Try to find the camelCased property
                ret = thisCache[jQuery.camelCase(name)];
            }
        } else {
            ret = thisCache;
        }

        return ret;
    }

    function internalRemoveData(elem, name, pvt) {
        if (!jQuery.acceptData(elem)) {
            return;
        }

        var thisCache,
            i,
            isNode = elem.nodeType,
            // See jQuery.data for more information
            cache = isNode ? jQuery.cache : elem,
            id = isNode ? elem[jQuery.expando] : jQuery.expando;

        // If there is already no cache entry for this object, there is no
        // purpose in continuing
        if (!cache[id]) {
            return;
        }

        if (name) {
            thisCache = pvt ? cache[id] : cache[id].data;

            if (thisCache) {
                // Support array or space separated string names for data keys
                if (!jQuery.isArray(name)) {
                    // try the string as a key before any manipulation
                    if (name in thisCache) {
                        name = [name];
                    } else {
                        // split the camel cased version by spaces unless a key with the spaces exists
                        name = jQuery.camelCase(name);
                        if (name in thisCache) {
                            name = [name];
                        } else {
                            name = name.split(' ');
                        }
                    }
                } else {
                    // If "name" is an array of keys...
                    // When data is initially created, via ("key", "val") signature,
                    // keys will be converted to camelCase.
                    // Since there is no way to tell _how_ a key was added, remove
                    // both plain key and camelCase key. #12786
                    // This will only penalize the array argument path.
                    name = name.concat(jQuery.map(name, jQuery.camelCase));
                }

                i = name.length;
                while (i--) {
                    delete thisCache[name[i]];
                }

                // If there is no data left in the cache, we want to continue
                // and let the cache object itself get destroyed
                if (pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache)) {
                    return;
                }
            }
        }

        // See jQuery.data for more information
        if (!pvt) {
            delete cache[id].data;

            // Don't destroy the parent cache unless the internal data object
            // had been the only thing left in it
            if (!isEmptyDataObject(cache[id])) {
                return;
            }
        }

        // Destroy the cache
        if (isNode) {
            jQuery.cleanData([elem], true);

            // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
            /* jshint eqeqeq: false */
        } else if (support.deleteExpando || cache != cache.window) {
            /* jshint eqeqeq: true */
            delete cache[id];

            // When all else fails, null
        } else {
            cache[id] = null;
        }
    }

    jQuery.extend({
        cache: {},

        // The following elements (space-suffixed to avoid Object.prototype collisions)
        // throw uncatchable exceptions if you attempt to set expando properties
        noData: {
            'applet ': true,
            'embed ': true,
            // ...but Flash objects (which have this classid) *can* handle expandos
            'object ': 'clsid:D27CDB6E-AE6D-11cf-96B8-444553540000',
        },

        hasData: function (elem) {
            elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];
            return !!elem && !isEmptyDataObject(elem);
        },

        data: function (elem, name, data) {
            return internalData(elem, name, data);
        },

        removeData: function (elem, name) {
            return internalRemoveData(elem, name);
        },

        // For internal use only.
        _data: function (elem, name, data) {
            return internalData(elem, name, data, true);
        },

        _removeData: function (elem, name) {
            return internalRemoveData(elem, name, true);
        },
    });

    jQuery.fn.extend({
        data: function (key, value) {
            var i,
                name,
                data,
                elem = this[0],
                attrs = elem && elem.attributes;

            // Special expections of .data basically thwart jQuery.access,
            // so implement the relevant behavior ourselves

            // Gets all values
            if (key === undefined) {
                if (this.length) {
                    data = jQuery.data(elem);

                    if (elem.nodeType === 1 && !jQuery._data(elem, 'parsedAttrs')) {
                        i = attrs.length;
                        while (i--) {
                            // Support: IE11+
                            // The attrs elements can be null (#14894)
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf('data-') === 0) {
                                    name = jQuery.camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        jQuery._data(elem, 'parsedAttrs', true);
                    }
                }

                return data;
            }

            // Sets multiple values
            if (typeof key === 'object') {
                return this.each(function () {
                    jQuery.data(this, key);
                });
            }

            return arguments.length > 1
                ? // Sets one value
                  this.each(function () {
                      jQuery.data(this, key, value);
                  })
                : // Gets one value
                // Try to fetch any internally stored data first
                elem
                ? dataAttr(elem, key, jQuery.data(elem, key))
                : undefined;
        },

        removeData: function (key) {
            return this.each(function () {
                jQuery.removeData(this, key);
            });
        },
    });

    jQuery.extend({
        queue: function (elem, type, data) {
            var queue;

            if (elem) {
                type = (type || 'fx') + 'queue';
                queue = jQuery._data(elem, type);

                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = jQuery._data(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },

        dequeue: function (elem, type) {
            type = type || 'fx';

            var queue = jQuery.queue(elem, type),
                startLength = queue.length,
                fn = queue.shift(),
                hooks = jQuery._queueHooks(elem, type),
                next = function () {
                    jQuery.dequeue(elem, type);
                };

            // If the fx queue is dequeued, always remove the progress sentinel
            if (fn === 'inprogress') {
                fn = queue.shift();
                startLength--;
            }

            if (fn) {
                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === 'fx') {
                    queue.unshift('inprogress');
                }

                // clear up the last queue stop function
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }

            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },

        // not intended for public consumption - generates a queueHooks object, or returns the current one
        _queueHooks: function (elem, type) {
            var key = type + 'queueHooks';
            return (
                jQuery._data(elem, key) ||
                jQuery._data(elem, key, {
                    empty: jQuery.Callbacks('once memory').add(function () {
                        jQuery._removeData(elem, type + 'queue');
                        jQuery._removeData(elem, key);
                    }),
                })
            );
        },
    });

    jQuery.fn.extend({
        queue: function (type, data) {
            var setter = 2;

            if (typeof type !== 'string') {
                data = type;
                type = 'fx';
                setter--;
            }

            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }

            return data === undefined
                ? this
                : this.each(function () {
                      var queue = jQuery.queue(this, type, data);

                      // ensure a hooks for this queue
                      jQuery._queueHooks(this, type);

                      if (type === 'fx' && queue[0] !== 'inprogress') {
                          jQuery.dequeue(this, type);
                      }
                  });
        },
        dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function (type) {
            return this.queue(type || 'fx', []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function (type, obj) {
            var tmp,
                count = 1,
                defer = jQuery.Deferred(),
                elements = this,
                i = this.length,
                resolve = function () {
                    if (!--count) {
                        defer.resolveWith(elements, [elements]);
                    }
                };

            if (typeof type !== 'string') {
                obj = type;
                type = undefined;
            }
            type = type || 'fx';

            while (i--) {
                tmp = jQuery._data(elements[i], type + 'queueHooks');
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        },
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;

    var cssExpand = ['Top', 'Right', 'Bottom', 'Left'];

    var isHidden = function (elem, el) {
        // isHidden might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem;
        return jQuery.css(elem, 'display') === 'none' || !jQuery.contains(elem.ownerDocument, elem);
    };

    // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it's a function
    var access = (jQuery.access = function (elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0,
            length = elems.length,
            bulk = key == null;

        // Sets many values
        if (jQuery.type(key) === 'object') {
            chainable = true;
            for (i in key) {
                jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
            }

            // Sets one value
        } else if (value !== undefined) {
            chainable = true;

            if (!jQuery.isFunction(value)) {
                raw = true;
            }

            if (bulk) {
                // Bulk operations run against the entire set
                if (raw) {
                    fn.call(elems, value);
                    fn = null;

                    // ...except when executing function values
                } else {
                    bulk = fn;
                    fn = function (elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }

            if (fn) {
                for (; i < length; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }

        return chainable
            ? elems
            : // Gets
            bulk
            ? fn.call(elems)
            : length
            ? fn(elems[0], key)
            : emptyGet;
    });
    var rcheckableType = /^(?:checkbox|radio)$/i;

    (function () {
        // Minified: var a,b,c
        var input = document.createElement('input'),
            div = document.createElement('div'),
            fragment = document.createDocumentFragment();

        // Setup
        div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

        // IE strips leading whitespace when .innerHTML is used
        support.leadingWhitespace = div.firstChild.nodeType === 3;

        // Make sure that tbody elements aren't automatically inserted
        // IE will insert them into empty tables
        support.tbody = !div.getElementsByTagName('tbody').length;

        // Make sure that link elements get serialized correctly by innerHTML
        // This requires a wrapper element in IE
        support.htmlSerialize = !!div.getElementsByTagName('link').length;

        // Makes sure cloning an html5 element does not cause problems
        // Where outerHTML is undefined, this still works
        support.html5Clone = document.createElement('nav').cloneNode(true).outerHTML !== '<:nav></:nav>';

        // Check if a disconnected checkbox will retain its checked
        // value of true after appended to the DOM (IE6/7)
        input.type = 'checkbox';
        input.checked = true;
        fragment.appendChild(input);
        support.appendChecked = input.checked;

        // Make sure textarea (and checkbox) defaultValue is properly cloned
        // Support: IE6-IE11+
        div.innerHTML = '<textarea>x</textarea>';
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;

        // #11217 - WebKit loses check when the name is after the checked attribute
        fragment.appendChild(div);
        div.innerHTML = "<input type='radio' checked='checked' name='t'/>";

        // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
        // old WebKit doesn't clone checked state correctly in fragments
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

        // Support: IE<9
        // Opera does not clone events (and typeof div.attachEvent === undefined).
        // IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
        support.noCloneEvent = true;
        if (div.attachEvent) {
            div.attachEvent('onclick', function () {
                support.noCloneEvent = false;
            });

            div.cloneNode(true).click();
        }

        // Execute the test only if not already executed in another module.
        if (support.deleteExpando == null) {
            // Support: IE<9
            support.deleteExpando = true;
            try {
                delete div.test;
            } catch (e) {
                support.deleteExpando = false;
            }
        }
    })();

    (function () {
        var i,
            eventName,
            div = document.createElement('div');

        // Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin event)
        for (i in { submit: true, change: true, focusin: true }) {
            eventName = 'on' + i;

            if (!(support[i + 'Bubbles'] = eventName in window)) {
                // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
                div.setAttribute(eventName, 't');
                support[i + 'Bubbles'] = div.attributes[eventName].expando === false;
            }
        }

        // Null elements to avoid leaks in IE.
        div = null;
    })();

    var rformElems = /^(?:input|select|textarea)$/i,
        rkeyEvent = /^key/,
        rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
        rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
        rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

    function returnTrue() {
        return true;
    }

    function returnFalse() {
        return false;
    }

    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {}
    }

    /*
     * Helper functions for managing events -- not part of the public interface.
     * Props to Dean Edwards' addEvent library for many of the ideas.
     */
    jQuery.event = {
        global: {},

        add: function (elem, types, handler, data, selector) {
            var tmp,
                events,
                t,
                handleObjIn,
                special,
                eventHandle,
                handleObj,
                handlers,
                type,
                namespaces,
                origType,
                elemData = jQuery._data(elem);

            // Don't attach events to noData or text/comment nodes (but allow plain objects)
            if (!elemData) {
                return;
            }

            // Caller can pass in an object of custom data in lieu of the handler
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }

            // Make sure that the handler has a unique ID, used to find/remove it later
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }

            // Init the element's event structure and main handler, if this is the first
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function (e) {
                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined;
                };
                // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
                eventHandle.elem = elem;
            }

            // Handle multiple events separated by a space
            types = (types || '').match(rnotwhite) || [''];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || '').split('.').sort();

                // There *must* be a type, no attaching namespace-only handlers
                if (!type) {
                    continue;
                }

                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[type] || {};

                // If selector defined, determine special event api type, otherwise given type
                type = (selector ? special.delegateType : special.bindType) || type;

                // Update special based on newly reset type
                special = jQuery.event.special[type] || {};

                // handleObj is passed to all event handlers
                handleObj = jQuery.extend(
                    {
                        type: type,
                        origType: origType,
                        data: data,
                        handler: handler,
                        guid: handler.guid,
                        selector: selector,
                        needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                        namespace: namespaces.join('.'),
                    },
                    handleObjIn
                );

                // Init the event handler queue if we're the first
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;

                    // Only use addEventListener/attachEvent if the special events handler returns false
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        // Bind the global event handler to the element
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);
                        } else if (elem.attachEvent) {
                            elem.attachEvent('on' + type, eventHandle);
                        }
                    }
                }

                if (special.add) {
                    special.add.call(elem, handleObj);

                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }

                // Add to the element's handler list, delegates in front
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }

                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[type] = true;
            }

            // Nullify elem to prevent memory leaks in IE
            elem = null;
        },

        // Detach an event or set of events from an element
        remove: function (elem, types, handler, selector, mappedTypes) {
            var j,
                handleObj,
                tmp,
                origCount,
                t,
                events,
                special,
                handlers,
                type,
                namespaces,
                origType,
                elemData = jQuery.hasData(elem) && jQuery._data(elem);

            if (!elemData || !(events = elemData.events)) {
                return;
            }

            // Once for each type.namespace in types; type may be omitted
            types = (types || '').match(rnotwhite) || [''];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || '').split('.').sort();

                // Unbind all events (on this namespace, if provided) for the element
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }

                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');

                // Remove matching events
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];

                    if (
                        (mappedTypes || origType === handleObj.origType) &&
                        (!handler || handler.guid === handleObj.guid) &&
                        (!tmp || tmp.test(handleObj.namespace)) &&
                        (!selector || selector === handleObj.selector || (selector === '**' && handleObj.selector))
                    ) {
                        handlers.splice(j, 1);

                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }

                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }

                    delete events[type];
                }
            }

            // Remove the expando if it's no longer used
            if (jQuery.isEmptyObject(events)) {
                delete elemData.handle;

                // removeData also checks for emptiness and clears the expando if empty
                // so use it instead of delete
                jQuery._removeData(elem, 'events');
            }
        },

        trigger: function (event, data, elem, onlyHandlers) {
            var handle,
                ontype,
                cur,
                bubbleType,
                special,
                tmp,
                i,
                eventPath = [elem || document],
                type = hasOwn.call(event, 'type') ? event.type : event,
                namespaces = hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];

            cur = tmp = elem = elem || document;

            // Don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }

            if (type.indexOf('.') >= 0) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split('.');
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(':') < 0 && 'on' + type;

            // Caller can pass in a jQuery.Event object, Object, or just an event type string
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event);

            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join('.');
            event.namespace_re = event.namespace ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;

            // Clean up the event in case it is being reused
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }

            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data == null ? [event] : jQuery.makeArray(data, [event]);

            // Allow special events to draw outside the lines
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }

            // Determine event propagation path in advance, per W3C events spec (#9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (; cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }

                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }

            // Fire handlers on the event path
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                event.type = i > 1 ? bubbleType : special.bindType || type;

                // jQuery handler
                handle = (jQuery._data(cur, 'events') || {})[event.type] && jQuery._data(cur, 'handle');
                if (handle) {
                    handle.apply(cur, data);
                }

                // Native handler
                handle = ontype && cur[ontype];
                if (handle && handle.apply && jQuery.acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;

            // If nobody prevented the default action, do it now
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
                    // Call a native DOM method on the target with the same name name as the event.
                    // Can't use an .isFunction() check here because IE6/7 fails that test.
                    // Don't do default actions on window, that's where global variables be (#6170)
                    if (ontype && elem[type] && !jQuery.isWindow(elem)) {
                        // Don't re-trigger an onFOO event when we call its FOO() method
                        tmp = elem[ontype];

                        if (tmp) {
                            elem[ontype] = null;
                        }

                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;
                        try {
                            elem[type]();
                        } catch (e) {
                            // IE<9 dies on focus/blur to hidden element (#1486,#12518)
                            // only reproducible on winXP IE8 native, not IE9 in IE8 mode
                        }
                        jQuery.event.triggered = undefined;

                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }

            return event.result;
        },

        dispatch: function (event) {
            // Make a writable jQuery.Event from the native event object
            event = jQuery.event.fix(event);

            var i,
                ret,
                handleObj,
                matched,
                j,
                handlerQueue = [],
                args = slice.call(arguments),
                handlers = (jQuery._data(this, 'events') || {})[event.type] || [],
                special = jQuery.event.special[event.type] || {};

            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[0] = event;
            event.delegateTarget = this;

            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }

            // Determine handlers
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);

            // Run delegates first; they may want to stop propagation beneath us
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;

                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                    // Triggered event must either 1) have no namespace, or
                    // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
                    if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
                        event.handleObj = handleObj;
                        event.data = handleObj.data;

                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }

            // Call the postDispatch hook for the mapped type
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }

            return event.result;
        },

        handlers: function (event, handlers) {
            var sel,
                handleObj,
                matches,
                i,
                handlerQueue = [],
                delegateCount = handlers.delegateCount,
                cur = event.target;

            // Find delegate handlers
            // Black-hole SVG <use> instance trees (#13180)
            // Avoid non-left-click bubbling in Firefox (#3861)
            if (delegateCount && cur.nodeType && (!event.button || event.type !== 'click')) {
                /* jshint eqeqeq: false */
                for (; cur != this; cur = cur.parentNode || this) {
                    /* jshint eqeqeq: true */

                    // Don't check non-elements (#13208)
                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                    if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== 'click')) {
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];

                            // Don't conflict with Object.prototype properties (#13203)
                            sel = handleObj.selector + ' ';

                            if (matches[sel] === undefined) {
                                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
                            }
                            if (matches[sel]) {
                                matches.push(handleObj);
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({ elem: cur, handlers: matches });
                        }
                    }
                }
            }

            // Add the remaining (directly-bound) handlers
            if (delegateCount < handlers.length) {
                handlerQueue.push({ elem: this, handlers: handlers.slice(delegateCount) });
            }

            return handlerQueue;
        },

        fix: function (event) {
            if (event[jQuery.expando]) {
                return event;
            }

            // Create a writable copy of the event object and normalize some properties
            var i,
                prop,
                copy,
                type = event.type,
                originalEvent = event,
                fixHook = this.fixHooks[type];

            if (!fixHook) {
                this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

            event = new jQuery.Event(originalEvent);

            i = copy.length;
            while (i--) {
                prop = copy[i];
                event[prop] = originalEvent[prop];
            }

            // Support: IE<9
            // Fix target property (#1925)
            if (!event.target) {
                event.target = originalEvent.srcElement || document;
            }

            // Support: Chrome 23+, Safari?
            // Target should not be a text node (#504, #13143)
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }

            // Support: IE<9
            // For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
            event.metaKey = !!event.metaKey;

            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },

        // Includes some event props shared by KeyEvent and MouseEvent
        props: 'altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which'.split(' '),

        fixHooks: {},

        keyHooks: {
            props: 'char charCode key keyCode'.split(' '),
            filter: function (event, original) {
                // Add which for key events
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }

                return event;
            },
        },

        mouseHooks: {
            props: 'button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement'.split(' '),
            filter: function (event, original) {
                var body,
                    eventDoc,
                    doc,
                    button = original.button,
                    fromElement = original.fromElement;

                // Calculate pageX/Y if missing and clientX/Y available
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;

                    event.pageX = original.clientX + ((doc && doc.scrollLeft) || (body && body.scrollLeft) || 0) - ((doc && doc.clientLeft) || (body && body.clientLeft) || 0);
                    event.pageY = original.clientY + ((doc && doc.scrollTop) || (body && body.scrollTop) || 0) - ((doc && doc.clientTop) || (body && body.clientTop) || 0);
                }

                // Add relatedTarget, if necessary
                if (!event.relatedTarget && fromElement) {
                    event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
                }

                // Add which for click: 1 === left; 2 === middle; 3 === right
                // Note: button is not normalized, so don't use it
                if (!event.which && button !== undefined) {
                    event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                }

                return event;
            },
        },

        special: {
            load: {
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true,
            },
            focus: {
                // Fire native event if possible so blur/focus sequence is correct
                trigger: function () {
                    if (this !== safeActiveElement() && this.focus) {
                        try {
                            this.focus();
                            return false;
                        } catch (e) {
                            // Support: IE<9
                            // If we error on focus to hidden element (#1486, #12518),
                            // let .trigger() run the handlers
                        }
                    }
                },
                delegateType: 'focusin',
            },
            blur: {
                trigger: function () {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: 'focusout',
            },
            click: {
                // For checkbox, fire native event so checked state will be right
                trigger: function () {
                    if (jQuery.nodeName(this, 'input') && this.type === 'checkbox' && this.click) {
                        this.click();
                        return false;
                    }
                },

                // For cross-browser consistency, don't fire native .click() on links
                _default: function (event) {
                    return jQuery.nodeName(event.target, 'a');
                },
            },

            beforeunload: {
                postDispatch: function (event) {
                    // Support: Firefox 20+
                    // Firefox doesn't alert if the returnValue field is not set.
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                },
            },
        },

        simulate: function (type, elem, event, bubble) {
            // Piggyback on a donor event to simulate a different one.
            // Fake originalEvent to avoid donor's stopPropagation, but if the
            // simulated event prevents default then we do the same on the donor.
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true,
                originalEvent: {},
            });
            if (bubble) {
                jQuery.event.trigger(e, null, elem);
            } else {
                jQuery.event.dispatch.call(elem, e);
            }
            if (e.isDefaultPrevented()) {
                event.preventDefault();
            }
        },
    };

    jQuery.removeEvent = document.removeEventListener
        ? function (elem, type, handle) {
              if (elem.removeEventListener) {
                  elem.removeEventListener(type, handle, false);
              }
          }
        : function (elem, type, handle) {
              var name = 'on' + type;

              if (elem.detachEvent) {
                  // #8545, #7054, preventing memory leaks for custom events in IE6-8
                  // detachEvent needed property on element, by name of that event, to properly expose it to GC
                  if (typeof elem[name] === strundefined) {
                      elem[name] = null;
                  }

                  elem.detachEvent(name, handle);
              }
          };

    jQuery.Event = function (src, props) {
        // Allow instantiation without the 'new' keyword
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }

        // Event object
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;

            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented =
                src.defaultPrevented ||
                (src.defaultPrevented === undefined &&
                    // Support: IE < 9, Android < 4.0
                    src.returnValue === false)
                    ? returnTrue
                    : returnFalse;

            // Event type
        } else {
            this.type = src;
        }

        // Put explicitly provided properties onto the event object
        if (props) {
            jQuery.extend(this, props);
        }

        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = (src && src.timeStamp) || jQuery.now();

        // Mark it as fixed
        this[jQuery.expando] = true;
    };

    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,

        preventDefault: function () {
            var e = this.originalEvent;

            this.isDefaultPrevented = returnTrue;
            if (!e) {
                return;
            }

            // If preventDefault exists, run it on the original event
            if (e.preventDefault) {
                e.preventDefault();

                // Support: IE
                // Otherwise set the returnValue property of the original event to false
            } else {
                e.returnValue = false;
            }
        },
        stopPropagation: function () {
            var e = this.originalEvent;

            this.isPropagationStopped = returnTrue;
            if (!e) {
                return;
            }
            // If stopPropagation exists, run it on the original event
            if (e.stopPropagation) {
                e.stopPropagation();
            }

            // Support: IE
            // Set the cancelBubble property of the original event to true
            e.cancelBubble = true;
        },
        stopImmediatePropagation: function () {
            var e = this.originalEvent;

            this.isImmediatePropagationStopped = returnTrue;

            if (e && e.stopImmediatePropagation) {
                e.stopImmediatePropagation();
            }

            this.stopPropagation();
        },
    };

    // Create mouseenter/leave events using mouseover/out and event-time checks
    jQuery.each(
        {
            mouseenter: 'mouseover',
            mouseleave: 'mouseout',
            pointerenter: 'pointerover',
            pointerleave: 'pointerout',
        },
        function (orig, fix) {
            jQuery.event.special[orig] = {
                delegateType: fix,
                bindType: fix,

                handle: function (event) {
                    var ret,
                        target = this,
                        related = event.relatedTarget,
                        handleObj = event.handleObj;

                    // For mousenter/leave call the handler if related is outside the target.
                    // NB: No relatedTarget if the mouse left/entered the browser window
                    if (!related || (related !== target && !jQuery.contains(target, related))) {
                        event.type = handleObj.origType;
                        ret = handleObj.handler.apply(this, arguments);
                        event.type = fix;
                    }
                    return ret;
                },
            };
        }
    );

    // IE submit delegation
    if (!support.submitBubbles) {
        jQuery.event.special.submit = {
            setup: function () {
                // Only need this for delegated form submit events
                if (jQuery.nodeName(this, 'form')) {
                    return false;
                }

                // Lazy-add a submit handler when a descendant form may potentially be submitted
                jQuery.event.add(this, 'click._submit keypress._submit', function (e) {
                    // Node name check avoids a VML-related crash in IE (#9807)
                    var elem = e.target,
                        form = jQuery.nodeName(elem, 'input') || jQuery.nodeName(elem, 'button') ? elem.form : undefined;
                    if (form && !jQuery._data(form, 'submitBubbles')) {
                        jQuery.event.add(form, 'submit._submit', function (event) {
                            event._submit_bubble = true;
                        });
                        jQuery._data(form, 'submitBubbles', true);
                    }
                });
                // return undefined since we don't need an event listener
            },

            postDispatch: function (event) {
                // If form was submitted by the user, bubble the event up the tree
                if (event._submit_bubble) {
                    delete event._submit_bubble;
                    if (this.parentNode && !event.isTrigger) {
                        jQuery.event.simulate('submit', this.parentNode, event, true);
                    }
                }
            },

            teardown: function () {
                // Only need this for delegated form submit events
                if (jQuery.nodeName(this, 'form')) {
                    return false;
                }

                // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
                jQuery.event.remove(this, '._submit');
            },
        };
    }

    // IE change delegation and checkbox/radio fix
    if (!support.changeBubbles) {
        jQuery.event.special.change = {
            setup: function () {
                if (rformElems.test(this.nodeName)) {
                    // IE doesn't fire change on a check/radio until blur; trigger it on click
                    // after a propertychange. Eat the blur-change in special.change.handle.
                    // This still fires onchange a second time for check/radio after blur.
                    if (this.type === 'checkbox' || this.type === 'radio') {
                        jQuery.event.add(this, 'propertychange._change', function (event) {
                            if (event.originalEvent.propertyName === 'checked') {
                                this._just_changed = true;
                            }
                        });
                        jQuery.event.add(this, 'click._change', function (event) {
                            if (this._just_changed && !event.isTrigger) {
                                this._just_changed = false;
                            }
                            // Allow triggered, simulated change events (#11500)
                            jQuery.event.simulate('change', this, event, true);
                        });
                    }
                    return false;
                }
                // Delegated event; lazy-add a change handler on descendant inputs
                jQuery.event.add(this, 'beforeactivate._change', function (e) {
                    var elem = e.target;

                    if (rformElems.test(elem.nodeName) && !jQuery._data(elem, 'changeBubbles')) {
                        jQuery.event.add(elem, 'change._change', function (event) {
                            if (this.parentNode && !event.isSimulated && !event.isTrigger) {
                                jQuery.event.simulate('change', this.parentNode, event, true);
                            }
                        });
                        jQuery._data(elem, 'changeBubbles', true);
                    }
                });
            },

            handle: function (event) {
                var elem = event.target;

                // Swallow native change events from checkbox/radio, we already triggered them above
                if (this !== elem || event.isSimulated || event.isTrigger || (elem.type !== 'radio' && elem.type !== 'checkbox')) {
                    return event.handleObj.handler.apply(this, arguments);
                }
            },

            teardown: function () {
                jQuery.event.remove(this, '._change');

                return !rformElems.test(this.nodeName);
            },
        };
    }

    // Create "bubbling" focus and blur events
    if (!support.focusinBubbles) {
        jQuery.each({ focus: 'focusin', blur: 'focusout' }, function (orig, fix) {
            // Attach a single capturing handler on the document while someone wants focusin/focusout
            var handler = function (event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
            };

            jQuery.event.special[fix] = {
                setup: function () {
                    var doc = this.ownerDocument || this,
                        attaches = jQuery._data(doc, fix);

                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    jQuery._data(doc, fix, (attaches || 0) + 1);
                },
                teardown: function () {
                    var doc = this.ownerDocument || this,
                        attaches = jQuery._data(doc, fix) - 1;

                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        jQuery._removeData(doc, fix);
                    } else {
                        jQuery._data(doc, fix, attaches);
                    }
                },
            };
        });
    }

    jQuery.fn.extend({
        on: function (types, selector, data, fn, /*INTERNAL*/ one) {
            var type, origFn;

            // Types can be a map of types/handlers
            if (typeof types === 'object') {
                // ( types-Object, selector, data )
                if (typeof selector !== 'string') {
                    // ( types-Object, data )
                    data = data || selector;
                    selector = undefined;
                }
                for (type in types) {
                    this.on(type, selector, data, types[type], one);
                }
                return this;
            }

            if (data == null && fn == null) {
                // ( types, fn )
                fn = selector;
                data = selector = undefined;
            } else if (fn == null) {
                if (typeof selector === 'string') {
                    // ( types, selector, fn )
                    fn = data;
                    data = undefined;
                } else {
                    // ( types, data, fn )
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if (fn === false) {
                fn = returnFalse;
            } else if (!fn) {
                return this;
            }

            if (one === 1) {
                origFn = fn;
                fn = function (event) {
                    // Can use an empty set, since event contains the info
                    jQuery().off(event);
                    return origFn.apply(this, arguments);
                };
                // Use same guid so caller can remove using origFn
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
            }
            return this.each(function () {
                jQuery.event.add(this, types, fn, data, selector);
            });
        },
        one: function (types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1);
        },
        off: function (types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === 'object') {
                // ( types-object [, selector] )
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === 'function') {
                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function () {
                jQuery.event.remove(this, types, fn, selector);
            });
        },

        trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function (type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        },
    });

    function createSafeFragment(document) {
        var list = nodeNames.split('|'),
            safeFrag = document.createDocumentFragment();

        if (safeFrag.createElement) {
            while (list.length) {
                safeFrag.createElement(list.pop());
            }
        }
        return safeFrag;
    }

    var nodeNames =
            'abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|' + 'header|hgroup|mark|meter|nav|output|progress|section|summary|time|video',
        rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
        rnoshimcache = new RegExp('<(?:' + nodeNames + ')[\\s/>]', 'i'),
        rleadingWhitespace = /^\s+/,
        rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
        rtagName = /<([\w:]+)/,
        rtbody = /<tbody/i,
        rhtml = /<|&#?\w+;/,
        rnoInnerhtml = /<(?:script|style|link)/i,
        // checked="checked" or checked
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rscriptType = /^$|\/(?:java|ecma)script/i,
        rscriptTypeMasked = /^true\/(.*)/,
        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
        // We have to close these tags to support XHTML (#13200)
        wrapMap = {
            option: [1, "<select multiple='multiple'>", '</select>'],
            legend: [1, '<fieldset>', '</fieldset>'],
            area: [1, '<map>', '</map>'],
            param: [1, '<object>', '</object>'],
            thead: [1, '<table>', '</table>'],
            tr: [2, '<table><tbody>', '</tbody></table>'],
            col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
            td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],

            // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
            // unless wrapped in a div with non-breaking characters in front of it.
            _default: support.htmlSerialize ? [0, '', ''] : [1, 'X<div>', '</div>'],
        },
        safeFragment = createSafeFragment(document),
        fragmentDiv = safeFragment.appendChild(document.createElement('div'));

    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

    function getAll(context, tag) {
        var elems,
            elem,
            i = 0,
            found =
                typeof context.getElementsByTagName !== strundefined
                    ? context.getElementsByTagName(tag || '*')
                    : typeof context.querySelectorAll !== strundefined
                    ? context.querySelectorAll(tag || '*')
                    : undefined;

        if (!found) {
            for (found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++) {
                if (!tag || jQuery.nodeName(elem, tag)) {
                    found.push(elem);
                } else {
                    jQuery.merge(found, getAll(elem, tag));
                }
            }
        }

        return tag === undefined || (tag && jQuery.nodeName(context, tag)) ? jQuery.merge([context], found) : found;
    }

    // Used in buildFragment, fixes the defaultChecked property
    function fixDefaultChecked(elem) {
        if (rcheckableType.test(elem.type)) {
            elem.defaultChecked = elem.checked;
        }
    }

    // Support: IE<8
    // Manipulating tables requires a tbody
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, 'table') && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, 'tr')
            ? elem.getElementsByTagName('tbody')[0] || elem.appendChild(elem.ownerDocument.createElement('tbody'))
            : elem;
    }

    // Replace/restore the type attribute of script elements for safe DOM manipulation
    function disableScript(elem) {
        elem.type = (jQuery.find.attr(elem, 'type') !== null) + '/' + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        if (match) {
            elem.type = match[1];
        } else {
            elem.removeAttribute('type');
        }
        return elem;
    }

    // Mark scripts as having already been evaluated
    function setGlobalEval(elems, refElements) {
        var elem,
            i = 0;
        for (; (elem = elems[i]) != null; i++) {
            jQuery._data(elem, 'globalEval', !refElements || jQuery._data(refElements[i], 'globalEval'));
        }
    }

    function cloneCopyEvent(src, dest) {
        if (dest.nodeType !== 1 || !jQuery.hasData(src)) {
            return;
        }

        var type,
            i,
            l,
            oldData = jQuery._data(src),
            curData = jQuery._data(dest, oldData),
            events = oldData.events;

        if (events) {
            delete curData.handle;
            curData.events = {};

            for (type in events) {
                for (i = 0, l = events[type].length; i < l; i++) {
                    jQuery.event.add(dest, type, events[type][i]);
                }
            }
        }

        // make the cloned public data object a copy from the original
        if (curData.data) {
            curData.data = jQuery.extend({}, curData.data);
        }
    }

    function fixCloneNodeIssues(src, dest) {
        var nodeName, e, data;

        // We do not need to do anything for non-Elements
        if (dest.nodeType !== 1) {
            return;
        }

        nodeName = dest.nodeName.toLowerCase();

        // IE6-8 copies events bound via attachEvent when using cloneNode.
        if (!support.noCloneEvent && dest[jQuery.expando]) {
            data = jQuery._data(dest);

            for (e in data.events) {
                jQuery.removeEvent(dest, e, data.handle);
            }

            // Event data gets referenced instead of copied if the expando gets copied too
            dest.removeAttribute(jQuery.expando);
        }

        // IE blanks contents when cloning scripts, and tries to evaluate newly-set text
        if (nodeName === 'script' && dest.text !== src.text) {
            disableScript(dest).text = src.text;
            restoreScript(dest);

            // IE6-10 improperly clones children of object elements using classid.
            // IE10 throws NoModificationAllowedError if parent is null, #12132.
        } else if (nodeName === 'object') {
            if (dest.parentNode) {
                dest.outerHTML = src.outerHTML;
            }

            // This path appears unavoidable for IE9. When cloning an object
            // element in IE9, the outerHTML strategy above is not sufficient.
            // If the src has innerHTML and the destination does not,
            // copy the src.innerHTML into the dest.innerHTML. #10324
            if (support.html5Clone && src.innerHTML && !jQuery.trim(dest.innerHTML)) {
                dest.innerHTML = src.innerHTML;
            }
        } else if (nodeName === 'input' && rcheckableType.test(src.type)) {
            // IE6-8 fails to persist the checked state of a cloned checkbox
            // or radio button. Worse, IE6-7 fail to give the cloned element
            // a checked appearance if the defaultChecked value isn't also set

            dest.defaultChecked = dest.checked = src.checked;

            // IE6-7 get confused and end up setting the value of a cloned
            // checkbox/radio button to an empty string instead of "on"
            if (dest.value !== src.value) {
                dest.value = src.value;
            }

            // IE6-8 fails to return the selected option to the default selected
            // state when cloning options
        } else if (nodeName === 'option') {
            dest.defaultSelected = dest.selected = src.defaultSelected;

            // IE6-8 fails to set the defaultValue to the correct value when
            // cloning other types of input fields
        } else if (nodeName === 'input' || nodeName === 'textarea') {
            dest.defaultValue = src.defaultValue;
        }
    }

    jQuery.extend({
        clone: function (elem, dataAndEvents, deepDataAndEvents) {
            var destElements,
                node,
                clone,
                i,
                srcElements,
                inPage = jQuery.contains(elem.ownerDocument, elem);

            if (support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test('<' + elem.nodeName + '>')) {
                clone = elem.cloneNode(true);

                // IE<=8 does not properly clone detached, unknown element nodes
            } else {
                fragmentDiv.innerHTML = elem.outerHTML;
                fragmentDiv.removeChild((clone = fragmentDiv.firstChild));
            }

            if ((!support.noCloneEvent || !support.noCloneChecked) && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
                destElements = getAll(clone);
                srcElements = getAll(elem);

                // Fix all IE cloning issues
                for (i = 0; (node = srcElements[i]) != null; ++i) {
                    // Ensure that the destination node is not null; Fixes #9587
                    if (destElements[i]) {
                        fixCloneNodeIssues(node, destElements[i]);
                    }
                }
            }

            // Copy the events from the original to the clone
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);

                    for (i = 0; (node = srcElements[i]) != null; i++) {
                        cloneCopyEvent(node, destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }

            // Preserve script evaluation history
            destElements = getAll(clone, 'script');
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
            }

            destElements = srcElements = node = null;

            // Return the cloned set
            return clone;
        },

        buildFragment: function (elems, context, scripts, selection) {
            var j,
                elem,
                contains,
                tmp,
                tag,
                tbody,
                wrap,
                l = elems.length,
                // Ensure a safe fragment
                safe = createSafeFragment(context),
                nodes = [],
                i = 0;

            for (; i < l; i++) {
                elem = elems[i];

                if (elem || elem === 0) {
                    // Add nodes directly
                    if (jQuery.type(elem) === 'object') {
                        jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

                        // Convert non-html into a text node
                    } else if (!rhtml.test(elem)) {
                        nodes.push(context.createTextNode(elem));

                        // Convert html into DOM nodes
                    } else {
                        tmp = tmp || safe.appendChild(context.createElement('div'));

                        // Deserialize a standard representation
                        tag = (rtagName.exec(elem) || ['', ''])[1].toLowerCase();
                        wrap = wrapMap[tag] || wrapMap._default;

                        tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, '<$1></$2>') + wrap[2];

                        // Descend through wrappers to the right content
                        j = wrap[0];
                        while (j--) {
                            tmp = tmp.lastChild;
                        }

                        // Manually add leading whitespace removed by IE
                        if (!support.leadingWhitespace && rleadingWhitespace.test(elem)) {
                            nodes.push(context.createTextNode(rleadingWhitespace.exec(elem)[0]));
                        }

                        // Remove IE's autoinserted <tbody> from table fragments
                        if (!support.tbody) {
                            // String was a <table>, *may* have spurious <tbody>
                            elem =
                                tag === 'table' && !rtbody.test(elem)
                                    ? tmp.firstChild
                                    : // String was a bare <thead> or <tfoot>
                                    wrap[1] === '<table>' && !rtbody.test(elem)
                                    ? tmp
                                    : 0;

                            j = elem && elem.childNodes.length;
                            while (j--) {
                                if (jQuery.nodeName((tbody = elem.childNodes[j]), 'tbody') && !tbody.childNodes.length) {
                                    elem.removeChild(tbody);
                                }
                            }
                        }

                        jQuery.merge(nodes, tmp.childNodes);

                        // Fix #12392 for WebKit and IE > 9
                        tmp.textContent = '';

                        // Fix #12392 for oldIE
                        while (tmp.firstChild) {
                            tmp.removeChild(tmp.firstChild);
                        }

                        // Remember the top-level container for proper cleanup
                        tmp = safe.lastChild;
                    }
                }
            }

            // Fix #11356: Clear elements from fragment
            if (tmp) {
                safe.removeChild(tmp);
            }

            // Reset defaultChecked for any radios and checkboxes
            // about to be appended to the DOM in IE 6/7 (#8060)
            if (!support.appendChecked) {
                jQuery.grep(getAll(nodes, 'input'), fixDefaultChecked);
            }

            i = 0;
            while ((elem = nodes[i++])) {
                // #4087 - If origin and destination elements are the same, and this is
                // that element, do not do anything
                if (selection && jQuery.inArray(elem, selection) !== -1) {
                    continue;
                }

                contains = jQuery.contains(elem.ownerDocument, elem);

                // Append to fragment
                tmp = getAll(safe.appendChild(elem), 'script');

                // Preserve script evaluation history
                if (contains) {
                    setGlobalEval(tmp);
                }

                // Capture executables
                if (scripts) {
                    j = 0;
                    while ((elem = tmp[j++])) {
                        if (rscriptType.test(elem.type || '')) {
                            scripts.push(elem);
                        }
                    }
                }
            }

            tmp = null;

            return safe;
        },

        cleanData: function (elems, /* internal */ acceptData) {
            var elem,
                type,
                id,
                data,
                i = 0,
                internalKey = jQuery.expando,
                cache = jQuery.cache,
                deleteExpando = support.deleteExpando,
                special = jQuery.event.special;

            for (; (elem = elems[i]) != null; i++) {
                if (acceptData || jQuery.acceptData(elem)) {
                    id = elem[internalKey];
                    data = id && cache[id];

                    if (data) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);

                                    // This is a shortcut to avoid jQuery.event.remove's overhead
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }

                        // Remove cache only if it was not already removed by jQuery.event.remove
                        if (cache[id]) {
                            delete cache[id];

                            // IE does not allow us to delete expando properties from nodes,
                            // nor does it have a removeAttribute function on Document nodes;
                            // we must handle all of these cases
                            if (deleteExpando) {
                                delete elem[internalKey];
                            } else if (typeof elem.removeAttribute !== strundefined) {
                                elem.removeAttribute(internalKey);
                            } else {
                                elem[internalKey] = null;
                            }

                            deletedIds.push(id);
                        }
                    }
                }
            }
        },
    });

    jQuery.fn.extend({
        text: function (value) {
            return access(
                this,
                function (value) {
                    return value === undefined ? jQuery.text(this) : this.empty().append(((this[0] && this[0].ownerDocument) || document).createTextNode(value));
                },
                null,
                value,
                arguments.length
            );
        },

        append: function () {
            return this.domManip(arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },

        prepend: function () {
            return this.domManip(arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },

        before: function () {
            return this.domManip(arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },

        after: function () {
            return this.domManip(arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },

        remove: function (selector, keepData /* Internal Use Only */) {
            var elem,
                elems = selector ? jQuery.filter(selector, this) : this,
                i = 0;

            for (; (elem = elems[i]) != null; i++) {
                if (!keepData && elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem));
                }

                if (elem.parentNode) {
                    if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                        setGlobalEval(getAll(elem, 'script'));
                    }
                    elem.parentNode.removeChild(elem);
                }
            }

            return this;
        },

        empty: function () {
            var elem,
                i = 0;

            for (; (elem = this[i]) != null; i++) {
                // Remove element nodes and prevent memory leaks
                if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                }

                // Remove any remaining nodes
                while (elem.firstChild) {
                    elem.removeChild(elem.firstChild);
                }

                // If this is a select, ensure that it displays empty (#12336)
                // Support: IE<9
                if (elem.options && jQuery.nodeName(elem, 'select')) {
                    elem.options.length = 0;
                }
            }

            return this;
        },

        clone: function (dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

            return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },

        html: function (value) {
            return access(
                this,
                function (value) {
                    var elem = this[0] || {},
                        i = 0,
                        l = this.length;

                    if (value === undefined) {
                        return elem.nodeType === 1 ? elem.innerHTML.replace(rinlinejQuery, '') : undefined;
                    }

                    // See if we can take a shortcut and just use innerHTML
                    if (
                        typeof value === 'string' &&
                        !rnoInnerhtml.test(value) &&
                        (support.htmlSerialize || !rnoshimcache.test(value)) &&
                        (support.leadingWhitespace || !rleadingWhitespace.test(value)) &&
                        !wrapMap[(rtagName.exec(value) || ['', ''])[1].toLowerCase()]
                    ) {
                        value = value.replace(rxhtmlTag, '<$1></$2>');

                        try {
                            for (; i < l; i++) {
                                // Remove element nodes and prevent memory leaks
                                elem = this[i] || {};
                                if (elem.nodeType === 1) {
                                    jQuery.cleanData(getAll(elem, false));
                                    elem.innerHTML = value;
                                }
                            }

                            elem = 0;

                            // If using innerHTML throws an exception, use the fallback method
                        } catch (e) {}
                    }

                    if (elem) {
                        this.empty().append(value);
                    }
                },
                null,
                value,
                arguments.length
            );
        },

        replaceWith: function () {
            var arg = arguments[0];

            // Make the changes, replacing each context element with the new content
            this.domManip(arguments, function (elem) {
                arg = this.parentNode;

                jQuery.cleanData(getAll(this));

                if (arg) {
                    arg.replaceChild(elem, this);
                }
            });

            // Force removal if there was no new content (e.g., from empty arguments)
            return arg && (arg.length || arg.nodeType) ? this : this.remove();
        },

        detach: function (selector) {
            return this.remove(selector, true);
        },

        domManip: function (args, callback) {
            // Flatten any nested arrays
            args = concat.apply([], args);

            var first,
                node,
                hasScripts,
                scripts,
                doc,
                fragment,
                i = 0,
                l = this.length,
                set = this,
                iNoClone = l - 1,
                value = args[0],
                isFunction = jQuery.isFunction(value);

            // We can't cloneNode fragments that contain checked, in WebKit
            if (isFunction || (l > 1 && typeof value === 'string' && !support.checkClone && rchecked.test(value))) {
                return this.each(function (index) {
                    var self = set.eq(index);
                    if (isFunction) {
                        args[0] = value.call(this, index, self.html());
                    }
                    self.domManip(args, callback);
                });
            }

            if (l) {
                fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
                first = fragment.firstChild;

                if (fragment.childNodes.length === 1) {
                    fragment = first;
                }

                if (first) {
                    scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
                    hasScripts = scripts.length;

                    // Use the original fragment for the last item instead of the first because it can end up
                    // being emptied incorrectly in certain situations (#8070).
                    for (; i < l; i++) {
                        node = fragment;

                        if (i !== iNoClone) {
                            node = jQuery.clone(node, true, true);

                            // Keep references to cloned scripts for later restoration
                            if (hasScripts) {
                                jQuery.merge(scripts, getAll(node, 'script'));
                            }
                        }

                        callback.call(this[i], node, i);
                    }

                    if (hasScripts) {
                        doc = scripts[scripts.length - 1].ownerDocument;

                        // Reenable scripts
                        jQuery.map(scripts, restoreScript);

                        // Evaluate executable scripts on first document insertion
                        for (i = 0; i < hasScripts; i++) {
                            node = scripts[i];
                            if (rscriptType.test(node.type || '') && !jQuery._data(node, 'globalEval') && jQuery.contains(doc, node)) {
                                if (node.src) {
                                    // Optional AJAX dependency, but won't run scripts if not present
                                    if (jQuery._evalUrl) {
                                        jQuery._evalUrl(node.src);
                                    }
                                } else {
                                    jQuery.globalEval((node.text || node.textContent || node.innerHTML || '').replace(rcleanScript, ''));
                                }
                            }
                        }
                    }

                    // Fix #11809: Avoid leaking memory
                    fragment = first = null;
                }
            }

            return this;
        },
    });

    jQuery.each(
        {
            appendTo: 'append',
            prependTo: 'prepend',
            insertBefore: 'before',
            insertAfter: 'after',
            replaceAll: 'replaceWith',
        },
        function (name, original) {
            jQuery.fn[name] = function (selector) {
                var elems,
                    i = 0,
                    ret = [],
                    insert = jQuery(selector),
                    last = insert.length - 1;

                for (; i <= last; i++) {
                    elems = i === last ? this : this.clone(true);
                    jQuery(insert[i])[original](elems);

                    // Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
                    push.apply(ret, elems.get());
                }

                return this.pushStack(ret);
            };
        }
    );

    var iframe,
        elemdisplay = {};

    /**
     * Retrieve the actual display of a element
     * @param {String} name nodeName of the element
     * @param {Object} doc Document object
     */
    // Called only from within defaultDisplay
    function actualDisplay(name, doc) {
        var style,
            elem = jQuery(doc.createElement(name)).appendTo(doc.body),
            // getDefaultComputedStyle might be reliably used only on attached element
            display =
                window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0]))
                    ? // Use of this method is a temporary fix (more like optmization) until something better comes along,
                      // since it was removed from specification and supported only in FF
                      style.display
                    : jQuery.css(elem[0], 'display');

        // We don't have any data stored on the element,
        // so use "detach" method as fast way to get rid of the element
        elem.detach();

        return display;
    }

    /**
     * Try to determine the default display value of an element
     * @param {String} nodeName
     */
    function defaultDisplay(nodeName) {
        var doc = document,
            display = elemdisplay[nodeName];

        if (!display) {
            display = actualDisplay(nodeName, doc);

            // If the simple way fails, read from inside an iframe
            if (display === 'none' || !display) {
                // Use the already-created iframe if possible
                iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);

                // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
                doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;

                // Support: IE
                doc.write();
                doc.close();

                display = actualDisplay(nodeName, doc);
                iframe.detach();
            }

            // Store the correct default display
            elemdisplay[nodeName] = display;
        }

        return display;
    }

    (function () {
        var shrinkWrapBlocksVal;

        support.shrinkWrapBlocks = function () {
            if (shrinkWrapBlocksVal != null) {
                return shrinkWrapBlocksVal;
            }

            // Will be changed later if needed.
            shrinkWrapBlocksVal = false;

            // Minified: var b,c,d
            var div, body, container;

            body = document.getElementsByTagName('body')[0];
            if (!body || !body.style) {
                // Test fired too early or in an unsupported environment, exit.
                return;
            }

            // Setup
            div = document.createElement('div');
            container = document.createElement('div');
            container.style.cssText = 'position:absolute;border:0;width:0;height:0;top:0;left:-9999px';
            body.appendChild(container).appendChild(div);

            // Support: IE6
            // Check if elements with layout shrink-wrap their children
            if (typeof div.style.zoom !== strundefined) {
                // Reset CSS: box-sizing; display; margin; border
                div.style.cssText =
                    // Support: Firefox<29, Android 2.3
                    // Vendor-prefix box-sizing
                    '-webkit-box-sizing:content-box;-moz-box-sizing:content-box;' + 'box-sizing:content-box;display:block;margin:0;border:0;' + 'padding:1px;width:1px;zoom:1';
                div.appendChild(document.createElement('div')).style.width = '5px';
                shrinkWrapBlocksVal = div.offsetWidth !== 3;
            }

            body.removeChild(container);

            return shrinkWrapBlocksVal;
        };
    })();
    var rmargin = /^margin/;

    var rnumnonpx = new RegExp('^(' + pnum + ')(?!px)[a-z%]+$', 'i');

    var getStyles,
        curCSS,
        rposition = /^(top|right|bottom|left)$/;

    if (window.getComputedStyle) {
        getStyles = function (elem) {
            // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
            // IE throws on elements created in popups
            // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
            if (elem.ownerDocument.defaultView.opener) {
                return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
            }

            return window.getComputedStyle(elem, null);
        };

        curCSS = function (elem, name, computed) {
            var width,
                minWidth,
                maxWidth,
                ret,
                style = elem.style;

            computed = computed || getStyles(elem);

            // getPropertyValue is only needed for .css('filter') in IE9, see #12537
            ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;

            if (computed) {
                if (ret === '' && !jQuery.contains(elem.ownerDocument, elem)) {
                    ret = jQuery.style(elem, name);
                }

                // A tribute to the "awesome hack by Dean Edwards"
                // Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
                // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
                // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
                if (rnumnonpx.test(ret) && rmargin.test(name)) {
                    // Remember the original values
                    width = style.width;
                    minWidth = style.minWidth;
                    maxWidth = style.maxWidth;

                    // Put in the new values to get a computed value out
                    style.minWidth = style.maxWidth = style.width = ret;
                    ret = computed.width;

                    // Revert the changed values
                    style.width = width;
                    style.minWidth = minWidth;
                    style.maxWidth = maxWidth;
                }
            }

            // Support: IE
            // IE returns zIndex value as an integer.
            return ret === undefined ? ret : ret + '';
        };
    } else if (document.documentElement.currentStyle) {
        getStyles = function (elem) {
            return elem.currentStyle;
        };

        curCSS = function (elem, name, computed) {
            var left,
                rs,
                rsLeft,
                ret,
                style = elem.style;

            computed = computed || getStyles(elem);
            ret = computed ? computed[name] : undefined;

            // Avoid setting ret to empty string here
            // so we don't default to auto
            if (ret == null && style && style[name]) {
                ret = style[name];
            }

            // From the awesome hack by Dean Edwards
            // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

            // If we're not dealing with a regular pixel number
            // but a number that has a weird ending, we need to convert it to pixels
            // but not position css attributes, as those are proportional to the parent element instead
            // and we can't measure the parent instead because it might trigger a "stacking dolls" problem
            if (rnumnonpx.test(ret) && !rposition.test(name)) {
                // Remember the original values
                left = style.left;
                rs = elem.runtimeStyle;
                rsLeft = rs && rs.left;

                // Put in the new values to get a computed value out
                if (rsLeft) {
                    rs.left = elem.currentStyle.left;
                }
                style.left = name === 'fontSize' ? '1em' : ret;
                ret = style.pixelLeft + 'px';

                // Revert the changed values
                style.left = left;
                if (rsLeft) {
                    rs.left = rsLeft;
                }
            }

            // Support: IE
            // IE returns zIndex value as an integer.
            return ret === undefined ? ret : ret + '' || 'auto';
        };
    }

    function addGetHookIf(conditionFn, hookFn) {
        // Define the hook, we'll check on the first run if it's really needed.
        return {
            get: function () {
                var condition = conditionFn();

                if (condition == null) {
                    // The test was not ready at this point; screw the hook this time
                    // but check again when needed next time.
                    return;
                }

                if (condition) {
                    // Hook not needed (or it's not possible to use it due to missing dependency),
                    // remove it.
                    // Since there are no other hooks for marginRight, remove the whole object.
                    delete this.get;
                    return;
                }

                // Hook needed; redefine it so that the support test is not executed again.

                return (this.get = hookFn).apply(this, arguments);
            },
        };
    }

    (function () {
        // Minified: var b,c,d,e,f,g, h,i
        var div, style, a, pixelPositionVal, boxSizingReliableVal, reliableHiddenOffsetsVal, reliableMarginRightVal;

        // Setup
        div = document.createElement('div');
        div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
        a = div.getElementsByTagName('a')[0];
        style = a && a.style;

        // Finish early in limited (non-browser) environments
        if (!style) {
            return;
        }

        style.cssText = 'float:left;opacity:.5';

        // Support: IE<9
        // Make sure that element opacity exists (as opposed to filter)
        support.opacity = style.opacity === '0.5';

        // Verify style float existence
        // (IE uses styleFloat instead of cssFloat)
        support.cssFloat = !!style.cssFloat;

        div.style.backgroundClip = 'content-box';
        div.cloneNode(true).style.backgroundClip = '';
        support.clearCloneStyle = div.style.backgroundClip === 'content-box';

        // Support: Firefox<29, Android 2.3
        // Vendor-prefix box-sizing
        support.boxSizing = style.boxSizing === '' || style.MozBoxSizing === '' || style.WebkitBoxSizing === '';

        jQuery.extend(support, {
            reliableHiddenOffsets: function () {
                if (reliableHiddenOffsetsVal == null) {
                    computeStyleTests();
                }
                return reliableHiddenOffsetsVal;
            },

            boxSizingReliable: function () {
                if (boxSizingReliableVal == null) {
                    computeStyleTests();
                }
                return boxSizingReliableVal;
            },

            pixelPosition: function () {
                if (pixelPositionVal == null) {
                    computeStyleTests();
                }
                return pixelPositionVal;
            },

            // Support: Android 2.3
            reliableMarginRight: function () {
                if (reliableMarginRightVal == null) {
                    computeStyleTests();
                }
                return reliableMarginRightVal;
            },
        });

        function computeStyleTests() {
            // Minified: var b,c,d,j
            var div, body, container, contents;

            body = document.getElementsByTagName('body')[0];
            if (!body || !body.style) {
                // Test fired too early or in an unsupported environment, exit.
                return;
            }

            // Setup
            div = document.createElement('div');
            container = document.createElement('div');
            container.style.cssText = 'position:absolute;border:0;width:0;height:0;top:0;left:-9999px';
            body.appendChild(container).appendChild(div);

            div.style.cssText =
                // Support: Firefox<29, Android 2.3
                // Vendor-prefix box-sizing
                '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;' +
                'box-sizing:border-box;display:block;margin-top:1%;top:1%;' +
                'border:1px;padding:1px;width:4px;position:absolute';

            // Support: IE<9
            // Assume reasonable values in the absence of getComputedStyle
            pixelPositionVal = boxSizingReliableVal = false;
            reliableMarginRightVal = true;

            // Check for getComputedStyle so that this code is not run in IE<9.
            if (window.getComputedStyle) {
                pixelPositionVal = (window.getComputedStyle(div, null) || {}).top !== '1%';
                boxSizingReliableVal = (window.getComputedStyle(div, null) || { width: '4px' }).width === '4px';

                // Support: Android 2.3
                // Div with explicit width and no margin-right incorrectly
                // gets computed margin-right based on width of container (#3333)
                // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                contents = div.appendChild(document.createElement('div'));

                // Reset CSS: box-sizing; display; margin; border; padding
                contents.style.cssText = div.style.cssText =
                    // Support: Firefox<29, Android 2.3
                    // Vendor-prefix box-sizing
                    '-webkit-box-sizing:content-box;-moz-box-sizing:content-box;' + 'box-sizing:content-box;display:block;margin:0;border:0;padding:0';
                contents.style.marginRight = contents.style.width = '0';
                div.style.width = '1px';

                reliableMarginRightVal = !parseFloat((window.getComputedStyle(contents, null) || {}).marginRight);

                div.removeChild(contents);
            }

            // Support: IE8
            // Check if table cells still have offsetWidth/Height when they are set
            // to display:none and there are still other visible table cells in a
            // table row; if so, offsetWidth/Height are not reliable for use when
            // determining if an element has been hidden directly using
            // display:none (it is still safe to use offsets if a parent element is
            // hidden; don safety goggles and see bug #4512 for more information).
            div.innerHTML = '<table><tr><td></td><td>t</td></tr></table>';
            contents = div.getElementsByTagName('td');
            contents[0].style.cssText = 'margin:0;border:0;padding:0;display:none';
            reliableHiddenOffsetsVal = contents[0].offsetHeight === 0;
            if (reliableHiddenOffsetsVal) {
                contents[0].style.display = '';
                contents[1].style.display = 'none';
                reliableHiddenOffsetsVal = contents[0].offsetHeight === 0;
            }

            body.removeChild(container);
        }
    })();

    // A method for quickly swapping in/out CSS properties to get correct calculations.
    jQuery.swap = function (elem, options, callback, args) {
        var ret,
            name,
            old = {};

        // Remember the old values, and insert the new ones
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }

        ret = callback.apply(elem, args || []);

        // Revert the old values
        for (name in options) {
            elem.style[name] = old[name];
        }

        return ret;
    };

    var ralpha = /alpha\([^)]*\)/i,
        ropacity = /opacity\s*=\s*([^)]*)/,
        // swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
        // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
        rdisplayswap = /^(none|table(?!-c[ea]).+)/,
        rnumsplit = new RegExp('^(' + pnum + ')(.*)$', 'i'),
        rrelNum = new RegExp('^([+-])=(' + pnum + ')', 'i'),
        cssShow = { position: 'absolute', visibility: 'hidden', display: 'block' },
        cssNormalTransform = {
            letterSpacing: '0',
            fontWeight: '400',
        },
        cssPrefixes = ['Webkit', 'O', 'Moz', 'ms'];

    // return a css property mapped to a potentially vendor prefixed property
    function vendorPropName(style, name) {
        // shortcut for names that are not vendor prefixed
        if (name in style) {
            return name;
        }

        // check for vendor prefixed names
        var capName = name.charAt(0).toUpperCase() + name.slice(1),
            origName = name,
            i = cssPrefixes.length;

        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in style) {
                return name;
            }
        }

        return origName;
    }

    function showHide(elements, show) {
        var display,
            elem,
            hidden,
            values = [],
            index = 0,
            length = elements.length;

        for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }

            values[index] = jQuery._data(elem, 'olddisplay');
            display = elem.style.display;
            if (show) {
                // Reset the inline display of this element to learn if it is
                // being hidden by cascaded rules or not
                if (!values[index] && display === 'none') {
                    elem.style.display = '';
                }

                // Set elements which have been overridden with display: none
                // in a stylesheet to whatever the default browser style is
                // for such an element
                if (elem.style.display === '' && isHidden(elem)) {
                    values[index] = jQuery._data(elem, 'olddisplay', defaultDisplay(elem.nodeName));
                }
            } else {
                hidden = isHidden(elem);

                if ((display && display !== 'none') || !hidden) {
                    jQuery._data(elem, 'olddisplay', hidden ? display : jQuery.css(elem, 'display'));
                }
            }
        }

        // Set the display of most of the elements in a second loop
        // to avoid the constant reflow
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            if (!show || elem.style.display === 'none' || elem.style.display === '') {
                elem.style.display = show ? values[index] || '' : 'none';
            }
        }

        return elements;
    }

    function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value);
        return matches
            ? // Guard against undefined "subtract", e.g., when used as in cssHooks
              Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || 'px')
            : value;
    }

    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i =
                extra === (isBorderBox ? 'border' : 'content')
                    ? // If we already have the right measurement, avoid augmentation
                      4
                    : // Otherwise initialize for horizontal or vertical properties
                    name === 'width'
                    ? 1
                    : 0,
            val = 0;

        for (; i < 4; i += 2) {
            // both box models exclude margin, so add it if we want it
            if (extra === 'margin') {
                val += jQuery.css(elem, extra + cssExpand[i], true, styles);
            }

            if (isBorderBox) {
                // border-box includes padding, so remove it if we want content
                if (extra === 'content') {
                    val -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                }

                // at this point, extra isn't border nor margin, so remove border
                if (extra !== 'margin') {
                    val -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                }
            } else {
                // at this point, extra isn't content, so add padding
                val += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);

                // at this point, extra isn't content nor padding, so add border
                if (extra !== 'padding') {
                    val += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                }
            }
        }

        return val;
    }

    function getWidthOrHeight(elem, name, extra) {
        // Start with offset property, which is equivalent to the border-box value
        var valueIsBorderBox = true,
            val = name === 'width' ? elem.offsetWidth : elem.offsetHeight,
            styles = getStyles(elem),
            isBorderBox = support.boxSizing && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';

        // some non-html elements return undefined for offsetWidth, so check for null/undefined
        // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
        // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
        if (val <= 0 || val == null) {
            // Fall back to computed then uncomputed css if necessary
            val = curCSS(elem, name, styles);
            if (val < 0 || val == null) {
                val = elem.style[name];
            }

            // Computed unit is not pixels. Stop here and return.
            if (rnumnonpx.test(val)) {
                return val;
            }

            // we need the check for style in case a browser which returns unreliable values
            // for getComputedStyle silently falls back to the reliable elem.style
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);

            // Normalize "", auto, and prepare for extra
            val = parseFloat(val) || 0;
        }

        // use the active box-sizing model to add/subtract irrelevant styles
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles) + 'px';
    }

    jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function (elem, computed) {
                    if (computed) {
                        // We should always get a number back from opacity
                        var ret = curCSS(elem, 'opacity');
                        return ret === '' ? '1' : ret;
                    }
                },
            },
        },

        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
            'columnCount': true,
            'fillOpacity': true,
            'flexGrow': true,
            'flexShrink': true,
            'fontWeight': true,
            'lineHeight': true,
            'opacity': true,
            'order': true,
            'orphans': true,
            'widows': true,
            'zIndex': true,
            'zoom': true,
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
            // normalize float css property
            'float': support.cssFloat ? 'cssFloat' : 'styleFloat',
        },

        // Get and set the style property on a DOM Node
        style: function (elem, name, value, extra) {
            // Don't set styles on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }

            // Make sure that we're working with the right name
            var ret,
                type,
                hooks,
                origName = jQuery.camelCase(name),
                style = elem.style;

            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));

            // gets hook for the prefixed version
            // followed by the unprefixed version
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

            // Check if we're setting a value
            if (value !== undefined) {
                type = typeof value;

                // convert relative number strings (+= or -=) to relative numbers. #7345
                if (type === 'string' && (ret = rrelNum.exec(value))) {
                    value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                    // Fixes bug #9237
                    type = 'number';
                }

                // Make sure that null and NaN values aren't set. See: #7116
                if (value == null || value !== value) {
                    return;
                }

                // If a number was passed in, add 'px' to the (except for certain CSS properties)
                if (type === 'number' && !jQuery.cssNumber[origName]) {
                    value += 'px';
                }

                // Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
                // but it would mean to define eight (for every problematic property) identical functions
                if (!support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
                    style[name] = 'inherit';
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    // Support: IE
                    // Swallow errors from 'invalid' CSS values (#5509)
                    try {
                        style[name] = value;
                    } catch (e) {}
                }
            } else {
                // If a hook was provided get the non-computed value from there
                if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }

                // Otherwise just get the value from the style object
                return style[name];
            }
        },

        css: function (elem, name, extra, styles) {
            var num,
                val,
                hooks,
                origName = jQuery.camelCase(name);

            // Make sure that we're working with the right name
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));

            // gets hook for the prefixed version
            // followed by the unprefixed version
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

            // If a hook was provided get the computed value from there
            if (hooks && 'get' in hooks) {
                val = hooks.get(elem, true, extra);
            }

            // Otherwise, if a way to get the computed value exists, use that
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }

            //convert "normal" to computed value
            if (val === 'normal' && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }

            // Return, converting to number if forced or a qualifier was provided and val looks numeric
            if (extra === '' || extra) {
                num = parseFloat(val);
                return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
            }
            return val;
        },
    });

    jQuery.each(['height', 'width'], function (i, name) {
        jQuery.cssHooks[name] = {
            get: function (elem, computed, extra) {
                if (computed) {
                    // certain elements can have dimension info if we invisibly show them
                    // however, it must have a current display style that would benefit from this
                    return rdisplayswap.test(jQuery.css(elem, 'display')) && elem.offsetWidth === 0
                        ? jQuery.swap(elem, cssShow, function () {
                              return getWidthOrHeight(elem, name, extra);
                          })
                        : getWidthOrHeight(elem, name, extra);
                }
            },

            set: function (elem, value, extra) {
                var styles = extra && getStyles(elem);
                return setPositiveNumber(
                    elem,
                    value,
                    extra ? augmentWidthOrHeight(elem, name, extra, support.boxSizing && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', styles) : 0
                );
            },
        };
    });

    if (!support.opacity) {
        jQuery.cssHooks.opacity = {
            get: function (elem, computed) {
                // IE uses filters for opacity
                return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || '')
                    ? 0.01 * parseFloat(RegExp.$1) + ''
                    : computed
                    ? '1'
                    : '';
            },

            set: function (elem, value) {
                var style = elem.style,
                    currentStyle = elem.currentStyle,
                    opacity = jQuery.isNumeric(value) ? 'alpha(opacity=' + value * 100 + ')' : '',
                    filter = (currentStyle && currentStyle.filter) || style.filter || '';

                // IE has trouble with opacity if it does not have layout
                // Force it by setting the zoom level
                style.zoom = 1;

                // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
                // if value === "", then remove inline opacity #12685
                if ((value >= 1 || value === '') && jQuery.trim(filter.replace(ralpha, '')) === '' && style.removeAttribute) {
                    // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
                    // if "filter:" is present at all, clearType is disabled, we want to avoid this
                    // style.removeAttribute is IE Only, but so apparently is this code path...
                    style.removeAttribute('filter');

                    // if there is no filter style applied in a css rule or unset inline opacity, we are done
                    if (value === '' || (currentStyle && !currentStyle.filter)) {
                        return;
                    }
                }

                // otherwise, set new filter values
                style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : filter + ' ' + opacity;
            },
        };
    }

    jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {
        if (computed) {
            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
            // Work around by temporarily setting element display to inline-block
            return jQuery.swap(elem, { 'display': 'inline-block' }, curCSS, [elem, 'marginRight']);
        }
    });

    // These hooks are used by animate to expand properties
    jQuery.each(
        {
            margin: '',
            padding: '',
            border: 'Width',
        },
        function (prefix, suffix) {
            jQuery.cssHooks[prefix + suffix] = {
                expand: function (value) {
                    var i = 0,
                        expanded = {},
                        // assumes a single number if not a string
                        parts = typeof value === 'string' ? value.split(' ') : [value];

                    for (; i < 4; i++) {
                        expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                    }

                    return expanded;
                },
            };

            if (!rmargin.test(prefix)) {
                jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
            }
        }
    );

    jQuery.fn.extend({
        css: function (name, value) {
            return access(
                this,
                function (elem, name, value) {
                    var styles,
                        len,
                        map = {},
                        i = 0;

                    if (jQuery.isArray(name)) {
                        styles = getStyles(elem);
                        len = name.length;

                        for (; i < len; i++) {
                            map[name[i]] = jQuery.css(elem, name[i], false, styles);
                        }

                        return map;
                    }

                    return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
                },
                name,
                value,
                arguments.length > 1
            );
        },
        show: function () {
            return showHide(this, true);
        },
        hide: function () {
            return showHide(this);
        },
        toggle: function (state) {
            if (typeof state === 'boolean') {
                return state ? this.show() : this.hide();
            }

            return this.each(function () {
                if (isHidden(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        },
    });

    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;

    Tween.prototype = {
        constructor: Tween,
        init: function (elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || 'swing';
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
        },
        cur: function () {
            var hooks = Tween.propHooks[this.prop];

            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function (percent) {
            var eased,
                hooks = Tween.propHooks[this.prop];

            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;

            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }

            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        },
    };

    Tween.prototype.init.prototype = Tween.prototype;

    Tween.propHooks = {
        _default: {
            get: function (tween) {
                var result;

                if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                    return tween.elem[tween.prop];
                }

                // passing an empty string as a 3rd parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails
                // so, simple values such as "10px" are parsed to Float.
                // complex values such as "rotate(1rad)" are returned as is.
                result = jQuery.css(tween.elem, tween.prop, '');
                // Empty strings, null, undefined and "auto" are converted to 0.
                return !result || result === 'auto' ? 0 : result;
            },
            set: function (tween) {
                // use step hook for back compat - use cssHook if its there - use .style if its
                // available and use plain properties where available
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            },
        },
    };

    // Support: IE <=9
    // Panic based approach to setting things on disconnected nodes

    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function (tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        },
    };

    jQuery.easing = {
        linear: function (p) {
            return p;
        },
        swing: function (p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        },
    };

    jQuery.fx = Tween.prototype.init;

    // Back Compat <1.8 extension point
    jQuery.fx.step = {};

    var fxNow,
        timerId,
        rfxtypes = /^(?:toggle|show|hide)$/,
        rfxnum = new RegExp('^(?:([+-])=|)(' + pnum + ')([a-z%]*)$', 'i'),
        rrun = /queueHooks$/,
        animationPrefilters = [defaultPrefilter],
        tweeners = {
            '*': [
                function (prop, value) {
                    var tween = this.createTween(prop, value),
                        target = tween.cur(),
                        parts = rfxnum.exec(value),
                        unit = (parts && parts[3]) || (jQuery.cssNumber[prop] ? '' : 'px'),
                        // Starting value computation is required for potential unit mismatches
                        start = (jQuery.cssNumber[prop] || (unit !== 'px' && +target)) && rfxnum.exec(jQuery.css(tween.elem, prop)),
                        scale = 1,
                        maxIterations = 20;

                    if (start && start[3] !== unit) {
                        // Trust units reported by jQuery.css
                        unit = unit || start[3];

                        // Make sure we update the tween properties later on
                        parts = parts || [];

                        // Iteratively approximate from a nonzero starting point
                        start = +target || 1;

                        do {
                            // If previous iteration zeroed out, double until we get *something*
                            // Use a string for doubling factor so we don't accidentally see scale as unchanged below
                            scale = scale || '.5';

                            // Adjust and apply
                            start = start / scale;
                            jQuery.style(tween.elem, prop, start + unit);

                            // Update scale, tolerating zero or NaN from tween.cur()
                            // And breaking the loop if scale is unchanged or perfect, or if we've just had enough
                        } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
                    }

                    // Update tween properties
                    if (parts) {
                        start = tween.start = +start || +target || 0;
                        tween.unit = unit;
                        // If a +=/-= token was provided, we're doing a relative animation
                        tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
                    }

                    return tween;
                },
            ],
        };

    // Animations created synchronously will run synchronously
    function createFxNow() {
        setTimeout(function () {
            fxNow = undefined;
        });
        return (fxNow = jQuery.now());
    }

    // Generate parameters to create a standard animation
    function genFx(type, includeWidth) {
        var which,
            attrs = { height: type },
            i = 0;

        // if we include width, step value is 1 to do all cssExpand values,
        // if we don't include width, step value is 2 to skip over Left and Right
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs['margin' + which] = attrs['padding' + which] = type;
        }

        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }

        return attrs;
    }

    function createTween(value, prop, animation) {
        var tween,
            collection = (tweeners[prop] || []).concat(tweeners['*']),
            index = 0,
            length = collection.length;
        for (; index < length; index++) {
            if ((tween = collection[index].call(animation, prop, value))) {
                // we're done with this property
                return tween;
            }
        }
    }

    function defaultPrefilter(elem, props, opts) {
        /* jshint validthis: true */
        var prop,
            value,
            toggle,
            tween,
            hooks,
            oldfire,
            display,
            checkDisplay,
            anim = this,
            orig = {},
            style = elem.style,
            hidden = elem.nodeType && isHidden(elem),
            dataShow = jQuery._data(elem, 'fxshow');

        // handle queue: false promises
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, 'fx');
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function () {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;

            anim.always(function () {
                // doing this makes sure that the complete handler will be called
                // before this completes
                anim.always(function () {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, 'fx').length) {
                        hooks.empty.fire();
                    }
                });
            });
        }

        // height/width overflow pass
        if (elem.nodeType === 1 && ('height' in props || 'width' in props)) {
            // Make sure that nothing sneaks out
            // Record all 3 overflow attributes because IE does not
            // change the overflow attribute when overflowX and
            // overflowY are set to the same value
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];

            // Set display property to inline-block for height/width
            // animations on inline elements that are having width/height animated
            display = jQuery.css(elem, 'display');

            // Test default display if display is currently "none"
            checkDisplay = display === 'none' ? jQuery._data(elem, 'olddisplay') || defaultDisplay(elem.nodeName) : display;

            if (checkDisplay === 'inline' && jQuery.css(elem, 'float') === 'none') {
                // inline-level elements accept inline-block;
                // block-level elements need to be inline with layout
                if (!support.inlineBlockNeedsLayout || defaultDisplay(elem.nodeName) === 'inline') {
                    style.display = 'inline-block';
                } else {
                    style.zoom = 1;
                }
            }
        }

        if (opts.overflow) {
            style.overflow = 'hidden';
            if (!support.shrinkWrapBlocks()) {
                anim.always(function () {
                    style.overflow = opts.overflow[0];
                    style.overflowX = opts.overflow[1];
                    style.overflowY = opts.overflow[2];
                });
            }
        }

        // show/hide pass
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.exec(value)) {
                delete props[prop];
                toggle = toggle || value === 'toggle';
                if (value === (hidden ? 'hide' : 'show')) {
                    // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
                    if (value === 'show' && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[prop] = (dataShow && dataShow[prop]) || jQuery.style(elem, prop);

                // Any non-fx value stops us from restoring the original display value
            } else {
                display = undefined;
            }
        }

        if (!jQuery.isEmptyObject(orig)) {
            if (dataShow) {
                if ('hidden' in dataShow) {
                    hidden = dataShow.hidden;
                }
            } else {
                dataShow = jQuery._data(elem, 'fxshow', {});
            }

            // store state if its toggle - enables .stop().toggle() to "reverse"
            if (toggle) {
                dataShow.hidden = !hidden;
            }
            if (hidden) {
                jQuery(elem).show();
            } else {
                anim.done(function () {
                    jQuery(elem).hide();
                });
            }
            anim.done(function () {
                var prop;
                jQuery._removeData(elem, 'fxshow');
                for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                }
            });
            for (prop in orig) {
                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

                if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                        tween.end = tween.start;
                        tween.start = prop === 'width' || prop === 'height' ? 1 : 0;
                    }
                }
            }

            // If this is a noop like .hide().hide(), restore an overwritten display value
        } else if ((display === 'none' ? defaultDisplay(elem.nodeName) : display) === 'inline') {
            style.display = display;
        }
    }

    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;

        // camelCase, specialEasing and expand cssHook pass
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }

            if (index !== name) {
                props[name] = value;
                delete props[index];
            }

            hooks = jQuery.cssHooks[name];
            if (hooks && 'expand' in hooks) {
                value = hooks.expand(value);
                delete props[name];

                // not quite $.extend, this wont overwrite keys already present.
                // also - reusing 'index' from above because we have the correct "name"
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }

    function Animation(elem, properties, options) {
        var result,
            stopped,
            index = 0,
            length = animationPrefilters.length,
            deferred = jQuery.Deferred().always(function () {
                // don't match elem in the :animated selector
                delete tick.elem;
            }),
            tick = function () {
                if (stopped) {
                    return false;
                }
                var currentTime = fxNow || createFxNow(),
                    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
                    // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
                    temp = remaining / animation.duration || 0,
                    percent = 1 - temp,
                    index = 0,
                    length = animation.tweens.length;

                for (; index < length; index++) {
                    animation.tweens[index].run(percent);
                }

                deferred.notifyWith(elem, [animation, percent, remaining]);

                if (percent < 1 && length) {
                    return remaining;
                } else {
                    deferred.resolveWith(elem, [animation]);
                    return false;
                }
            },
            animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(true, { specialEasing: {} }, options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function (prop, end) {
                    var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                    animation.tweens.push(tween);
                    return tween;
                },
                stop: function (gotoEnd) {
                    var index = 0,
                        // if we are going to the end, we want to run all the tweens
                        // otherwise we skip this part
                        length = gotoEnd ? animation.tweens.length : 0;
                    if (stopped) {
                        return this;
                    }
                    stopped = true;
                    for (; index < length; index++) {
                        animation.tweens[index].run(1);
                    }

                    // resolve when we played the last frame
                    // otherwise, reject
                    if (gotoEnd) {
                        deferred.resolveWith(elem, [animation, gotoEnd]);
                    } else {
                        deferred.rejectWith(elem, [animation, gotoEnd]);
                    }
                    return this;
                },
            }),
            props = animation.props;

        propFilter(props, animation.opts.specialEasing);

        for (; index < length; index++) {
            result = animationPrefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                return result;
            }
        }

        jQuery.map(props, createTween, animation);

        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }

        jQuery.fx.timer(
            jQuery.extend(tick, {
                elem: elem,
                anim: animation,
                queue: animation.opts.queue,
            })
        );

        // attach callbacks from options
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }

    jQuery.Animation = jQuery.extend(Animation, {
        tweener: function (props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = ['*'];
            } else {
                props = props.split(' ');
            }

            var prop,
                index = 0,
                length = props.length;

            for (; index < length; index++) {
                prop = props[index];
                tweeners[prop] = tweeners[prop] || [];
                tweeners[prop].unshift(callback);
            }
        },

        prefilter: function (callback, prepend) {
            if (prepend) {
                animationPrefilters.unshift(callback);
            } else {
                animationPrefilters.push(callback);
            }
        },
    });

    jQuery.speed = function (speed, easing, fn) {
        var opt =
            speed && typeof speed === 'object'
                ? jQuery.extend({}, speed)
                : {
                      complete: fn || (!fn && easing) || (jQuery.isFunction(speed) && speed),
                      duration: speed,
                      easing: (fn && easing) || (easing && !jQuery.isFunction(easing) && easing),
                  };

        opt.duration = jQuery.fx.off
            ? 0
            : typeof opt.duration === 'number'
            ? opt.duration
            : opt.duration in jQuery.fx.speeds
            ? jQuery.fx.speeds[opt.duration]
            : jQuery.fx.speeds._default;

        // normalize opt.queue - true/undefined/null -> "fx"
        if (opt.queue == null || opt.queue === true) {
            opt.queue = 'fx';
        }

        // Queueing
        opt.old = opt.complete;

        opt.complete = function () {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }

            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };

        return opt;
    };

    jQuery.fn.extend({
        fadeTo: function (speed, to, easing, callback) {
            // show any hidden elements after setting opacity to 0
            return (
                this.filter(isHidden)
                    .css('opacity', 0)
                    .show()

                    // animate to the value specified
                    .end()
                    .animate({ opacity: to }, speed, easing, callback)
            );
        },
        animate: function (prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop),
                optall = jQuery.speed(speed, easing, callback),
                doAnimation = function () {
                    // Operate on a copy of prop so per-property easing won't be lost
                    var anim = Animation(this, jQuery.extend({}, prop), optall);

                    // Empty animations, or finishing resolves immediately
                    if (empty || jQuery._data(this, 'finish')) {
                        anim.stop(true);
                    }
                };
            doAnimation.finish = doAnimation;

            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function (type, clearQueue, gotoEnd) {
            var stopQueue = function (hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };

            if (typeof type !== 'string') {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || 'fx', []);
            }

            return this.each(function () {
                var dequeue = true,
                    index = type != null && type + 'queueHooks',
                    timers = jQuery.timers,
                    data = jQuery._data(this);

                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }

                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }

                // start the next in the queue if the last step wasn't forced
                // timers currently will call their complete callbacks, which will dequeue
                // but only if they were gotoEnd
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function (type) {
            if (type !== false) {
                type = type || 'fx';
            }
            return this.each(function () {
                var index,
                    data = jQuery._data(this),
                    queue = data[type + 'queue'],
                    hooks = data[type + 'queueHooks'],
                    timers = jQuery.timers,
                    length = queue ? queue.length : 0;

                // enable finishing flag on private data
                data.finish = true;

                // empty the queue first
                jQuery.queue(this, type, []);

                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }

                // look for any active animations, and finish them
                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }

                // look for any animations in the old queue and finish them
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }

                // turn off finishing flag
                delete data.finish;
            });
        },
    });

    jQuery.each(['toggle', 'show', 'hide'], function (i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function (speed, easing, callback) {
            return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });

    // Generate shortcuts for custom animations
    jQuery.each(
        {
            slideDown: genFx('show'),
            slideUp: genFx('hide'),
            slideToggle: genFx('toggle'),
            fadeIn: { opacity: 'show' },
            fadeOut: { opacity: 'hide' },
            fadeToggle: { opacity: 'toggle' },
        },
        function (name, props) {
            jQuery.fn[name] = function (speed, easing, callback) {
                return this.animate(props, speed, easing, callback);
            };
        }
    );

    jQuery.timers = [];
    jQuery.fx.tick = function () {
        var timer,
            timers = jQuery.timers,
            i = 0;

        fxNow = jQuery.now();

        for (; i < timers.length; i++) {
            timer = timers[i];
            // Checks the timer has not already been removed
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }

        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };

    jQuery.fx.timer = function (timer) {
        jQuery.timers.push(timer);
        if (timer()) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    };

    jQuery.fx.interval = 13;

    jQuery.fx.start = function () {
        if (!timerId) {
            timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
    };

    jQuery.fx.stop = function () {
        clearInterval(timerId);
        timerId = null;
    };

    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400,
    };

    // Based off of the plugin by Clint Helfers, with permission.
    // http://blindsignals.com/index.php/2009/07/jquery-delay/
    jQuery.fn.delay = function (time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || 'fx';

        return this.queue(type, function (next, hooks) {
            var timeout = setTimeout(next, time);
            hooks.stop = function () {
                clearTimeout(timeout);
            };
        });
    };

    (function () {
        // Minified: var a,b,c,d,e
        var input, div, select, a, opt;

        // Setup
        div = document.createElement('div');
        div.setAttribute('className', 't');
        div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
        a = div.getElementsByTagName('a')[0];

        // First batch of tests.
        select = document.createElement('select');
        opt = select.appendChild(document.createElement('option'));
        input = div.getElementsByTagName('input')[0];

        a.style.cssText = 'top:1px';

        // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
        support.getSetAttribute = div.className !== 't';

        // Get the style information from getAttribute
        // (IE uses .cssText instead)
        support.style = /top/.test(a.getAttribute('style'));

        // Make sure that URLs aren't manipulated
        // (IE normalizes it by default)
        support.hrefNormalized = a.getAttribute('href') === '/a';

        // Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
        support.checkOn = !!input.value;

        // Make sure that a selected-by-default option has a working selected property.
        // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
        support.optSelected = opt.selected;

        // Tests for enctype support on a form (#6743)
        support.enctype = !!document.createElement('form').enctype;

        // Make sure that the options inside disabled selects aren't marked as disabled
        // (WebKit marks them as disabled)
        select.disabled = true;
        support.optDisabled = !opt.disabled;

        // Support: IE8 only
        // Check if we can trust getAttribute("value")
        input = document.createElement('input');
        input.setAttribute('value', '');
        support.input = input.getAttribute('value') === '';

        // Check if an input maintains its value after becoming a radio
        input.value = 't';
        input.setAttribute('type', 'radio');
        support.radioValue = input.value === 't';
    })();

    var rreturn = /\r/g;

    jQuery.fn.extend({
        val: function (value) {
            var hooks,
                ret,
                isFunction,
                elem = this[0];

            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

                    if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
                        return ret;
                    }

                    ret = elem.value;

                    return typeof ret === 'string'
                        ? // handle most common string cases
                          ret.replace(rreturn, '')
                        : // handle cases where value is null/undef or number
                        ret == null
                        ? ''
                        : ret;
                }

                return;
            }

            isFunction = jQuery.isFunction(value);

            return this.each(function (i) {
                var val;

                if (this.nodeType !== 1) {
                    return;
                }

                if (isFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }

                // Treat null/undefined as ""; convert numbers to string
                if (val == null) {
                    val = '';
                } else if (typeof val === 'number') {
                    val += '';
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? '' : value + '';
                    });
                }

                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

                // If set returns undefined, fall back to normal setting
                if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
                    this.value = val;
                }
            });
        },
    });

    jQuery.extend({
        valHooks: {
            option: {
                get: function (elem) {
                    var val = jQuery.find.attr(elem, 'value');
                    return val != null
                        ? val
                        : // Support: IE10-11+
                          // option.text throws exceptions (#14686, #14858)
                          jQuery.trim(jQuery.text(elem));
                },
            },
            select: {
                get: function (elem) {
                    var value,
                        option,
                        options = elem.options,
                        index = elem.selectedIndex,
                        one = elem.type === 'select-one' || index < 0,
                        values = one ? null : [],
                        max = one ? index + 1 : options.length,
                        i = index < 0 ? max : one ? index : 0;

                    // Loop through all the selected options
                    for (; i < max; i++) {
                        option = options[i];

                        // oldIE doesn't update selected after form reset (#2551)
                        if (
                            (option.selected || i === index) &&
                            // Don't return options that are disabled or in a disabled optgroup
                            (support.optDisabled ? !option.disabled : option.getAttribute('disabled') === null) &&
                            (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, 'optgroup'))
                        ) {
                            // Get the specific value for the option
                            value = jQuery(option).val();

                            // We don't need an array for one selects
                            if (one) {
                                return value;
                            }

                            // Multi-Selects return an array
                            values.push(value);
                        }
                    }

                    return values;
                },

                set: function (elem, value) {
                    var optionSet,
                        option,
                        options = elem.options,
                        values = jQuery.makeArray(value),
                        i = options.length;

                    while (i--) {
                        option = options[i];

                        if (jQuery.inArray(jQuery.valHooks.option.get(option), values) >= 0) {
                            // Support: IE6
                            // When new option element is added to select box we need to
                            // force reflow of newly added node in order to workaround delay
                            // of initialization properties
                            try {
                                option.selected = optionSet = true;
                            } catch (_) {
                                // Will be executed only in IE6
                                option.scrollHeight;
                            }
                        } else {
                            option.selected = false;
                        }
                    }

                    // Force browsers to behave consistently when non-matching value is set
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }

                    return options;
                },
            },
        },
    });

    // Radios and checkboxes getter/setter
    jQuery.each(['radio', 'checkbox'], function () {
        jQuery.valHooks[this] = {
            set: function (elem, value) {
                if (jQuery.isArray(value)) {
                    return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0);
                }
            },
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function (elem) {
                // Support: Webkit
                // "" is returned instead of "on" if a value isn't specified
                return elem.getAttribute('value') === null ? 'on' : elem.value;
            };
        }
    });

    var nodeHook,
        boolHook,
        attrHandle = jQuery.expr.attrHandle,
        ruseDefault = /^(?:checked|selected)$/i,
        getSetAttribute = support.getSetAttribute,
        getSetInput = support.input;

    jQuery.fn.extend({
        attr: function (name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },

        removeAttr: function (name) {
            return this.each(function () {
                jQuery.removeAttr(this, name);
            });
        },
    });

    jQuery.extend({
        attr: function (elem, name, value) {
            var hooks,
                ret,
                nType = elem.nodeType;

            // don't get/set attributes on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }

            // Fallback to prop when attributes are not supported
            if (typeof elem.getAttribute === strundefined) {
                return jQuery.prop(elem, name, value);
            }

            // All attributes are lowercase
            // Grab necessary hook if one is defined
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
            }

            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                } else if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                } else {
                    elem.setAttribute(name, value + '');
                    return value;
                }
            } else if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            } else {
                ret = jQuery.find.attr(elem, name);

                // Non-existent attributes return null, we normalize to undefined
                return ret == null ? undefined : ret;
            }
        },

        removeAttr: function (elem, value) {
            var name,
                propName,
                i = 0,
                attrNames = value && value.match(rnotwhite);

            if (attrNames && elem.nodeType === 1) {
                while ((name = attrNames[i++])) {
                    propName = jQuery.propFix[name] || name;

                    // Boolean attributes get special treatment (#10870)
                    if (jQuery.expr.match.bool.test(name)) {
                        // Set corresponding property to false
                        if ((getSetInput && getSetAttribute) || !ruseDefault.test(name)) {
                            elem[propName] = false;
                            // Support: IE<9
                            // Also clear defaultChecked/defaultSelected (if appropriate)
                        } else {
                            elem[jQuery.camelCase('default-' + name)] = elem[propName] = false;
                        }

                        // See #9699 for explanation of this approach (setting first, then removal)
                    } else {
                        jQuery.attr(elem, name, '');
                    }

                    elem.removeAttribute(getSetAttribute ? name : propName);
                }
            }
        },

        attrHooks: {
            type: {
                set: function (elem, value) {
                    if (!support.radioValue && value === 'radio' && jQuery.nodeName(elem, 'input')) {
                        // Setting the type on a radio button after the value resets the value in IE6-9
                        // Reset value to default in case type is set after value during creation
                        var val = elem.value;
                        elem.setAttribute('type', value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                },
            },
        },
    });

    // Hook for boolean attributes
    boolHook = {
        set: function (elem, value, name) {
            if (value === false) {
                // Remove boolean attributes when set to false
                jQuery.removeAttr(elem, name);
            } else if ((getSetInput && getSetAttribute) || !ruseDefault.test(name)) {
                // IE<8 needs the *property* name
                elem.setAttribute((!getSetAttribute && jQuery.propFix[name]) || name, name);

                // Use defaultChecked and defaultSelected for oldIE
            } else {
                elem[jQuery.camelCase('default-' + name)] = elem[name] = true;
            }

            return name;
        },
    };

    // Retrieve booleans specially
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;

        attrHandle[name] =
            (getSetInput && getSetAttribute) || !ruseDefault.test(name)
                ? function (elem, name, isXML) {
                      var ret, handle;
                      if (!isXML) {
                          // Avoid an infinite loop by temporarily removing this function from the getter
                          handle = attrHandle[name];
                          attrHandle[name] = ret;
                          ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
                          attrHandle[name] = handle;
                      }
                      return ret;
                  }
                : function (elem, name, isXML) {
                      if (!isXML) {
                          return elem[jQuery.camelCase('default-' + name)] ? name.toLowerCase() : null;
                      }
                  };
    });

    // fix oldIE attroperties
    if (!getSetInput || !getSetAttribute) {
        jQuery.attrHooks.value = {
            set: function (elem, value, name) {
                if (jQuery.nodeName(elem, 'input')) {
                    // Does not return so that setAttribute is also used
                    elem.defaultValue = value;
                } else {
                    // Use nodeHook if defined (#1954); otherwise setAttribute is fine
                    return nodeHook && nodeHook.set(elem, value, name);
                }
            },
        };
    }

    // IE6/7 do not support getting/setting some attributes with get/setAttribute
    if (!getSetAttribute) {
        // Use this for any attribute in IE6/7
        // This fixes almost every IE6/7 issue
        nodeHook = {
            set: function (elem, value, name) {
                // Set the existing or create a new attribute node
                var ret = elem.getAttributeNode(name);
                if (!ret) {
                    elem.setAttributeNode((ret = elem.ownerDocument.createAttribute(name)));
                }

                ret.value = value += '';

                // Break association with cloned elements by also using setAttribute (#9646)
                if (name === 'value' || value === elem.getAttribute(name)) {
                    return value;
                }
            },
        };

        // Some attributes are constructed with empty-string values when not defined
        attrHandle.id =
            attrHandle.name =
            attrHandle.coords =
                function (elem, name, isXML) {
                    var ret;
                    if (!isXML) {
                        return (ret = elem.getAttributeNode(name)) && ret.value !== '' ? ret.value : null;
                    }
                };

        // Fixing value retrieval on a button requires this module
        jQuery.valHooks.button = {
            get: function (elem, name) {
                var ret = elem.getAttributeNode(name);
                if (ret && ret.specified) {
                    return ret.value;
                }
            },
            set: nodeHook.set,
        };

        // Set contenteditable to false on removals(#10429)
        // Setting to empty string throws an error as an invalid value
        jQuery.attrHooks.contenteditable = {
            set: function (elem, value, name) {
                nodeHook.set(elem, value === '' ? false : value, name);
            },
        };

        // Set width and height to auto instead of 0 on empty string( Bug #8150 )
        // This is for removals
        jQuery.each(['width', 'height'], function (i, name) {
            jQuery.attrHooks[name] = {
                set: function (elem, value) {
                    if (value === '') {
                        elem.setAttribute(name, 'auto');
                        return value;
                    }
                },
            };
        });
    }

    if (!support.style) {
        jQuery.attrHooks.style = {
            get: function (elem) {
                // Return undefined in the case of empty string
                // Note: IE uppercases css property names, but if we were to .toLowerCase()
                // .cssText, that would destroy case senstitivity in URL's, like in "background"
                return elem.style.cssText || undefined;
            },
            set: function (elem, value) {
                return (elem.style.cssText = value + '');
            },
        };
    }

    var rfocusable = /^(?:input|select|textarea|button|object)$/i,
        rclickable = /^(?:a|area)$/i;

    jQuery.fn.extend({
        prop: function (name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },

        removeProp: function (name) {
            name = jQuery.propFix[name] || name;
            return this.each(function () {
                // try/catch handles cases where IE balks (such as removing a property on window)
                try {
                    this[name] = undefined;
                    delete this[name];
                } catch (e) {}
            });
        },
    });

    jQuery.extend({
        propFix: {
            'for': 'htmlFor',
            'class': 'className',
        },

        prop: function (elem, name, value) {
            var ret,
                hooks,
                notxml,
                nType = elem.nodeType;

            // don't get/set properties on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }

            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

            if (notxml) {
                // Fix name and attach hooks
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }

            if (value !== undefined) {
                return hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : (elem[name] = value);
            } else {
                return hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
            }
        },

        propHooks: {
            tabIndex: {
                get: function (elem) {
                    // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                    // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    // Use proper attribute retrieval(#12072)
                    var tabindex = jQuery.find.attr(elem, 'tabindex');

                    return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || (rclickable.test(elem.nodeName) && elem.href) ? 0 : -1;
                },
            },
        },
    });

    // Some attributes require a special call on IE
    // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
    if (!support.hrefNormalized) {
        // href/src property should get the full normalized URL (#10299/#12915)
        jQuery.each(['href', 'src'], function (i, name) {
            jQuery.propHooks[name] = {
                get: function (elem) {
                    return elem.getAttribute(name, 4);
                },
            };
        });
    }

    // Support: Safari, IE9+
    // mis-reports the default selected property of an option
    // Accessing the parent's selectedIndex property fixes it
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function (elem) {
                var parent = elem.parentNode;

                if (parent) {
                    parent.selectedIndex;

                    // Make sure that it also works with optgroups, see #5701
                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
                return null;
            },
        };
    }

    jQuery.each(['tabIndex', 'readOnly', 'maxLength', 'cellSpacing', 'cellPadding', 'rowSpan', 'colSpan', 'useMap', 'frameBorder', 'contentEditable'], function () {
        jQuery.propFix[this.toLowerCase()] = this;
    });

    // IE6/7 call enctype encoding
    if (!support.enctype) {
        jQuery.propFix.enctype = 'encoding';
    }

    var rclass = /[\t\r\n\f]/g;

    jQuery.fn.extend({
        addClass: function (value) {
            var classes,
                elem,
                cur,
                clazz,
                j,
                finalValue,
                i = 0,
                len = this.length,
                proceed = typeof value === 'string' && value;

            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, this.className));
                });
            }

            if (proceed) {
                // The disjunction here is for better compressibility (see removeClass)
                classes = (value || '').match(rnotwhite) || [];

                for (; i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : ' ');

                    if (cur) {
                        j = 0;
                        while ((clazz = classes[j++])) {
                            if (cur.indexOf(' ' + clazz + ' ') < 0) {
                                cur += clazz + ' ';
                            }
                        }

                        // only assign if different to avoid unneeded rendering.
                        finalValue = jQuery.trim(cur);
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }

            return this;
        },

        removeClass: function (value) {
            var classes,
                elem,
                cur,
                clazz,
                j,
                finalValue,
                i = 0,
                len = this.length,
                proceed = arguments.length === 0 || (typeof value === 'string' && value);

            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                classes = (value || '').match(rnotwhite) || [];

                for (; i < len; i++) {
                    elem = this[i];
                    // This expression is here for better compressibility (see addClass)
                    cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : '');

                    if (cur) {
                        j = 0;
                        while ((clazz = classes[j++])) {
                            // Remove *all* instances
                            while (cur.indexOf(' ' + clazz + ' ') >= 0) {
                                cur = cur.replace(' ' + clazz + ' ', ' ');
                            }
                        }

                        // only assign if different to avoid unneeded rendering.
                        finalValue = value ? jQuery.trim(cur) : '';
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }

            return this;
        },

        toggleClass: function (value, stateVal) {
            var type = typeof value;

            if (typeof stateVal === 'boolean' && type === 'string') {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }

            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                });
            }

            return this.each(function () {
                if (type === 'string') {
                    // toggle individual class names
                    var className,
                        i = 0,
                        self = jQuery(this),
                        classNames = value.match(rnotwhite) || [];

                    while ((className = classNames[i++])) {
                        // check each className given, space separated list
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }

                    // Toggle whole class name
                } else if (type === strundefined || type === 'boolean') {
                    if (this.className) {
                        // store className if set
                        jQuery._data(this, '__className__', this.className);
                    }

                    // If the element has a class name or if we're passed "false",
                    // then remove the whole classname (if there was one, the above saved it).
                    // Otherwise bring back whatever was previously saved (if anything),
                    // falling back to the empty string if nothing was stored.
                    this.className = this.className || value === false ? '' : jQuery._data(this, '__className__') || '';
                }
            });
        },

        hasClass: function (selector) {
            var className = ' ' + selector + ' ',
                i = 0,
                l = this.length;
            for (; i < l; i++) {
                if (this[i].nodeType === 1 && (' ' + this[i].className + ' ').replace(rclass, ' ').indexOf(className) >= 0) {
                    return true;
                }
            }

            return false;
        },
    });

    // Return jQuery for attributes-only inclusion

    jQuery.each(
        (
            'blur focus focusin focusout load resize scroll unload click dblclick ' +
            'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' +
            'change select submit keydown keypress keyup error contextmenu'
        ).split(' '),
        function (i, name) {
            // Handle event binding
            jQuery.fn[name] = function (data, fn) {
                return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
            };
        }
    );

    jQuery.fn.extend({
        hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        },

        bind: function (types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function (types, fn) {
            return this.off(types, null, fn);
        },

        delegate: function (selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function (selector, types, fn) {
            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
        },
    });

    var nonce = jQuery.now();

    var rquery = /\?/;

    var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;

    jQuery.parseJSON = function (data) {
        // Attempt to parse using the native JSON parser first
        if (window.JSON && window.JSON.parse) {
            // Support: Android 2.3
            // Workaround failure to string-cast null input
            return window.JSON.parse(data + '');
        }

        var requireNonComma,
            depth = null,
            str = jQuery.trim(data + '');

        // Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
        // after removing valid tokens
        return str &&
            !jQuery.trim(
                str.replace(rvalidtokens, function (token, comma, open, close) {
                    // Force termination if we see a misplaced comma
                    if (requireNonComma && comma) {
                        depth = 0;
                    }

                    // Perform no more replacements after returning to outermost depth
                    if (depth === 0) {
                        return token;
                    }

                    // Commas must not follow "[", "{", or ","
                    requireNonComma = open || comma;

                    // Determine new depth
                    // array/object open ("[" or "{"): depth += true - false (increment)
                    // array/object close ("]" or "}"): depth += false - true (decrement)
                    // other cases ("," or primitive): depth += true - true (numeric cast)
                    depth += !close - !open;

                    // Remove this token
                    return '';
                })
            )
            ? Function('return ' + str)()
            : jQuery.error('Invalid JSON: ' + data);
    };

    // Cross-browser xml parsing
    jQuery.parseXML = function (data) {
        var xml, tmp;
        if (!data || typeof data !== 'string') {
            return null;
        }
        try {
            if (window.DOMParser) {
                // Standard
                tmp = new DOMParser();
                xml = tmp.parseFromString(data, 'text/xml');
            } else {
                // IE
                xml = new ActiveXObject('Microsoft.XMLDOM');
                xml.async = 'false';
                xml.loadXML(data);
            }
        } catch (e) {
            xml = undefined;
        }
        if (!xml || !xml.documentElement || xml.getElementsByTagName('parsererror').length) {
            jQuery.error('Invalid XML: ' + data);
        }
        return xml;
    };

    var // Document location
        ajaxLocParts,
        ajaxLocation,
        rhash = /#.*$/,
        rts = /([?&])_=[^&]*/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm, // IE leaves an \r character at EOL
        // #7653, #8125, #8152: local protocol detection
        rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,
        rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
        /* Prefilters
         * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
         * 2) These are called:
         *    - BEFORE asking for a transport
         *    - AFTER param serialization (s.data is a string if s.processData is true)
         * 3) key is the dataType
         * 4) the catchall symbol "*" can be used
         * 5) execution will start with transport dataType and THEN continue down to "*" if needed
         */
        prefilters = {},
        /* Transports bindings
         * 1) key is the dataType
         * 2) the catchall symbol "*" can be used
         * 3) selection will start with transport dataType and THEN go to "*" if needed
         */
        transports = {},
        // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
        allTypes = '*/'.concat('*');

    // #8138, IE may throw an exception when accessing
    // a field from window.location if document.domain has been set
    try {
        ajaxLocation = location.href;
    } catch (e) {
        // Use the href attribute of an A element
        // since IE will modify it given document.location
        ajaxLocation = document.createElement('a');
        ajaxLocation.href = '';
        ajaxLocation = ajaxLocation.href;
    }

    // Segment location into parts
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {
        // dataTypeExpression is optional and defaults to "*"
        return function (dataTypeExpression, func) {
            if (typeof dataTypeExpression !== 'string') {
                func = dataTypeExpression;
                dataTypeExpression = '*';
            }

            var dataType,
                i = 0,
                dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

            if (jQuery.isFunction(func)) {
                // For each dataType in the dataTypeExpression
                while ((dataType = dataTypes[i++])) {
                    // Prepend if requested
                    if (dataType.charAt(0) === '+') {
                        dataType = dataType.slice(1) || '*';
                        (structure[dataType] = structure[dataType] || []).unshift(func);

                        // Otherwise append
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }

    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {},
            seekingTransport = structure === transports;

        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }

        return inspect(options.dataTypes[0]) || (!inspected['*'] && inspect('*'));
    }

    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887
    function ajaxExtend(target, src) {
        var deep,
            key,
            flatOptions = jQuery.ajaxSettings.flatOptions || {};

        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }

        return target;
    }

    /* Handles responses to an ajax request:
     * - finds the right dataType (mediates between content-type and expected dataType)
     * - returns the corresponding response
     */
    function ajaxHandleResponses(s, jqXHR, responses) {
        var firstDataType,
            ct,
            finalDataType,
            type,
            contents = s.contents,
            dataTypes = s.dataTypes;

        // Remove auto dataType and get content-type in the process
        while (dataTypes[0] === '*') {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
            }
        }

        // Check if we're dealing with a known content-type
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }

        // Check to see if we have a response for the expected dataType
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            // Try convertible dataTypes
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }

        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }

    /* Chain conversions given the request and the original response
     * Also sets the responseXXX fields on the jqXHR instance
     */
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2,
            current,
            conv,
            tmp,
            prev,
            converters = {},
            // Work with a copy of dataTypes in case we need to modify it for conversion
            dataTypes = s.dataTypes.slice();

        // Create converters map with lowercased keys
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }

        current = dataTypes.shift();

        // Convert to each sequential dataType
        while (current) {
            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }

            // Apply the dataFilter if provided
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }

            prev = current;
            current = dataTypes.shift();

            if (current) {
                // There's only work to do if current dataType is non-auto
                if (current === '*') {
                    current = prev;

                    // Convert response if prev dataType is non-auto and differs from current
                } else if (prev !== '*' && prev !== current) {
                    // Seek a direct converter
                    conv = converters[prev + ' ' + current] || converters['* ' + current];

                    // If none found, seek a pair
                    if (!conv) {
                        for (conv2 in converters) {
                            // If conv2 outputs current
                            tmp = conv2.split(' ');
                            if (tmp[1] === current) {
                                // If prev can be converted to accepted input
                                conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
                                if (conv) {
                                    // Condense equivalence converters
                                    if (conv === true) {
                                        conv = converters[conv2];

                                        // Otherwise, insert the intermediate dataType
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }

                    // Apply converter (if not an equivalence)
                    if (conv !== true) {
                        // Unless errors are allowed to bubble, catch and return them
                        if (conv && s['throws']) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return { state: 'parsererror', error: conv ? e : 'No conversion from ' + prev + ' to ' + current };
                            }
                        }
                    }
                }
            }
        }

        return { state: 'success', data: response };
    }

    jQuery.extend({
        // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},

        ajaxSettings: {
            url: ajaxLocation,
            type: 'GET',
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            processData: true,
            async: true,
            contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
            /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

            accepts: {
                '*': allTypes,
                text: 'text/plain',
                html: 'text/html',
                xml: 'application/xml, text/xml',
                json: 'application/json, text/javascript',
            },

            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/,
            },

            responseFields: {
                xml: 'responseXML',
                text: 'responseText',
                json: 'responseJSON',
            },

            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {
                // Convert anything to text
                '* text': String,

                // Text to html (true = no transformation)
                'text html': true,

                // Evaluate text as a json expression
                'text json': jQuery.parseJSON,

                // Parse text as xml
                'text xml': jQuery.parseXML,
            },

            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                url: true,
                context: true,
            },
        },

        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function (target, settings) {
            return settings
                ? // Building a settings object
                  ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings)
                : // Extending ajaxSettings
                  ajaxExtend(jQuery.ajaxSettings, target);
        },

        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),

        // Main method
        ajax: function (url, options) {
            // If url is an object, simulate pre-1.5 signature
            if (typeof url === 'object') {
                options = url;
                url = undefined;
            }

            // Force options to be an object
            options = options || {};

            var // Cross-domain detection vars
                parts,
                // Loop variable
                i,
                // URL without anti-cache param
                cacheURL,
                // Response headers as string
                responseHeadersString,
                // timeout handle
                timeoutTimer,
                // To know if global events are to be dispatched
                fireGlobals,
                transport,
                // Response headers
                responseHeaders,
                // Create the final options object
                s = jQuery.ajaxSetup({}, options),
                // Callbacks context
                callbackContext = s.context || s,
                // Context for global events is callbackContext if it is a DOM node or jQuery collection
                globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
                // Deferreds
                deferred = jQuery.Deferred(),
                completeDeferred = jQuery.Callbacks('once memory'),
                // Status-dependent callbacks
                statusCode = s.statusCode || {},
                // Headers (they are sent all at once)
                requestHeaders = {},
                requestHeadersNames = {},
                // The jqXHR state
                state = 0,
                // Default abort message
                strAbort = 'canceled',
                // Fake xhr
                jqXHR = {
                    readyState: 0,

                    // Builds headers hashtable if needed
                    getResponseHeader: function (key) {
                        var match;
                        if (state === 2) {
                            if (!responseHeaders) {
                                responseHeaders = {};
                                while ((match = rheaders.exec(responseHeadersString))) {
                                    responseHeaders[match[1].toLowerCase()] = match[2];
                                }
                            }
                            match = responseHeaders[key.toLowerCase()];
                        }
                        return match == null ? null : match;
                    },

                    // Raw string
                    getAllResponseHeaders: function () {
                        return state === 2 ? responseHeadersString : null;
                    },

                    // Caches the header
                    setRequestHeader: function (name, value) {
                        var lname = name.toLowerCase();
                        if (!state) {
                            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                            requestHeaders[name] = value;
                        }
                        return this;
                    },

                    // Overrides response content-type header
                    overrideMimeType: function (type) {
                        if (!state) {
                            s.mimeType = type;
                        }
                        return this;
                    },

                    // Status-dependent callbacks
                    statusCode: function (map) {
                        var code;
                        if (map) {
                            if (state < 2) {
                                for (code in map) {
                                    // Lazy-add the new callback in a way that preserves old ones
                                    statusCode[code] = [statusCode[code], map[code]];
                                }
                            } else {
                                // Execute the appropriate callbacks
                                jqXHR.always(map[jqXHR.status]);
                            }
                        }
                        return this;
                    },

                    // Cancel the request
                    abort: function (statusText) {
                        var finalText = statusText || strAbort;
                        if (transport) {
                            transport.abort(finalText);
                        }
                        done(0, finalText);
                        return this;
                    },
                };

            // Attach deferreds
            deferred.promise(jqXHR).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;

            // Remove hash character (#7531: and string promotion)
            // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
            // Handle falsy url in the settings object (#10093: consistency with old signature)
            // We also use the url parameter if available
            s.url = ((url || s.url || ajaxLocation) + '').replace(rhash, '').replace(rprotocol, ajaxLocParts[1] + '//');

            // Alias method option to type as per ticket #12004
            s.type = options.method || options.type || s.method || s.type;

            // Extract dataTypes list
            s.dataTypes = jQuery
                .trim(s.dataType || '*')
                .toLowerCase()
                .match(rnotwhite) || [''];

            // A cross-domain request is in order when we have a protocol:host:port mismatch
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!(
                    parts &&
                    (parts[1] !== ajaxLocParts[1] ||
                        parts[2] !== ajaxLocParts[2] ||
                        (parts[3] || (parts[1] === 'http:' ? '80' : '443')) !== (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? '80' : '443')))
                );
            }

            // Convert data if not already a string
            if (s.data && s.processData && typeof s.data !== 'string') {
                s.data = jQuery.param(s.data, s.traditional);
            }

            // Apply prefilters
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

            // If request was aborted inside a prefilter, stop there
            if (state === 2) {
                return jqXHR;
            }

            // We can fire global events as of now if asked to
            // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
            fireGlobals = jQuery.event && s.global;

            // Watch for a new set of requests
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger('ajaxStart');
            }

            // Uppercase the type
            s.type = s.type.toUpperCase();

            // Determine if request has content
            s.hasContent = !rnoContent.test(s.type);

            // Save the URL in case we're toying with the If-Modified-Since
            // and/or If-None-Match header later on
            cacheURL = s.url;

            // More options handling for requests with no content
            if (!s.hasContent) {
                // If data is available, append data to url
                if (s.data) {
                    cacheURL = s.url += (rquery.test(cacheURL) ? '&' : '?') + s.data;
                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }

                // Add anti-cache in url if needed
                if (s.cache === false) {
                    s.url = rts.test(cacheURL)
                        ? // If there is already a '_' parameter, set its value
                          cacheURL.replace(rts, '$1_=' + nonce++)
                        : // Otherwise add one to the end
                          cacheURL + (rquery.test(cacheURL) ? '&' : '?') + '_=' + nonce++;
                }
            }

            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
                }
            }

            // Set the correct header, if data is being sent
            if ((s.data && s.hasContent && s.contentType !== false) || options.contentType) {
                jqXHR.setRequestHeader('Content-Type', s.contentType);
            }

            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader(
                'Accept',
                s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '') : s.accepts['*']
            );

            // Check for headers option
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }

            // Allow custom headers/mimetypes and early abort
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                // Abort if not done already and return
                return jqXHR.abort();
            }

            // aborting is no longer a cancellation
            strAbort = 'abort';

            // Install callbacks on deferreds
            for (i in { success: 1, error: 1, complete: 1 }) {
                jqXHR[i](s[i]);
            }

            // Get transport
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

            // If no transport, we auto-abort
            if (!transport) {
                done(-1, 'No Transport');
            } else {
                jqXHR.readyState = 1;

                // Send global event
                if (fireGlobals) {
                    globalEventContext.trigger('ajaxSend', [jqXHR, s]);
                }
                // Timeout
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout(function () {
                        jqXHR.abort('timeout');
                    }, s.timeout);
                }

                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    // Propagate exception as error if not done
                    if (state < 2) {
                        done(-1, e);
                        // Simply rethrow otherwise
                    } else {
                        throw e;
                    }
                }
            }

            // Callback for when everything is done
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess,
                    success,
                    error,
                    response,
                    modified,
                    statusText = nativeStatusText;

                // Called once
                if (state === 2) {
                    return;
                }

                // State is "done" now
                state = 2;

                // Clear timeout if it exists
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                }

                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;

                // Cache response headers
                responseHeadersString = headers || '';

                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;

                // Determine if successful
                isSuccess = (status >= 200 && status < 300) || status === 304;

                // Get response data
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }

                // Convert no matter what (that way responseXXX fields are always set)
                response = ajaxConvert(s, response, jqXHR, isSuccess);

                // If successful, handle type chaining
                if (isSuccess) {
                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader('Last-Modified');
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader('etag');
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }

                    // if no content
                    if (status === 204 || s.type === 'HEAD') {
                        statusText = 'nocontent';

                        // if not modified
                    } else if (status === 304) {
                        statusText = 'notmodified';

                        // If we have data, let's convert it
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    // We extract error from statusText
                    // then normalize statusText and status for non-aborts
                    error = statusText;
                    if (status || !statusText) {
                        statusText = 'error';
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }

                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + '';

                // Success/Error
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                } else {
                    deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                }

                // Status-dependent callbacks
                jqXHR.statusCode(statusCode);
                statusCode = undefined;

                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [jqXHR, s, isSuccess ? success : error]);
                }

                // Complete
                completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

                if (fireGlobals) {
                    globalEventContext.trigger('ajaxComplete', [jqXHR, s]);
                    // Handle the global AJAX counter
                    if (!--jQuery.active) {
                        jQuery.event.trigger('ajaxStop');
                    }
                }
            }

            return jqXHR;
        },

        getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, 'json');
        },

        getScript: function (url, callback) {
            return jQuery.get(url, undefined, callback, 'script');
        },
    });

    jQuery.each(['get', 'post'], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {
            // shift arguments if data argument was omitted
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }

            return jQuery.ajax({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback,
            });
        };
    });

    jQuery._evalUrl = function (url) {
        return jQuery.ajax({
            url: url,
            type: 'GET',
            dataType: 'script',
            async: false,
            global: false,
            'throws': true,
        });
    };

    jQuery.fn.extend({
        wrapAll: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }

            if (this[0]) {
                // The elements to wrap the target around
                var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }

                wrap.map(function () {
                    var elem = this;

                    while (elem.firstChild && elem.firstChild.nodeType === 1) {
                        elem = elem.firstChild;
                    }

                    return elem;
                }).append(this);
            }

            return this;
        },

        wrapInner: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }

            return this.each(function () {
                var self = jQuery(this),
                    contents = self.contents();

                if (contents.length) {
                    contents.wrapAll(html);
                } else {
                    self.append(html);
                }
            });
        },

        wrap: function (html) {
            var isFunction = jQuery.isFunction(html);

            return this.each(function (i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },

        unwrap: function () {
            return this.parent()
                .each(function () {
                    if (!jQuery.nodeName(this, 'body')) {
                        jQuery(this).replaceWith(this.childNodes);
                    }
                })
                .end();
        },
    });

    jQuery.expr.filters.hidden = function (elem) {
        // Support: Opera <= 12.12
        // Opera reports offsetWidths and offsetHeights less than zero on some elements
        return (
            (elem.offsetWidth <= 0 && elem.offsetHeight <= 0) ||
            (!support.reliableHiddenOffsets() && ((elem.style && elem.style.display) || jQuery.css(elem, 'display')) === 'none')
        );
    };

    jQuery.expr.filters.visible = function (elem) {
        return !jQuery.expr.filters.hidden(elem);
    };

    var r20 = /%20/g,
        rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
        rsubmittable = /^(?:input|select|textarea|keygen)/i;

    function buildParams(prefix, obj, traditional, add) {
        var name;

        if (jQuery.isArray(obj)) {
            // Serialize array item.
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {
                    // Treat each array item as a scalar.
                    add(prefix, v);
                } else {
                    // Item is non-scalar (array or object), encode its numeric index.
                    buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add);
                }
            });
        } else if (!traditional && jQuery.type(obj) === 'object') {
            // Serialize object item.
            for (name in obj) {
                buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
            }
        } else {
            // Serialize scalar item.
            add(prefix, obj);
        }
    }

    // Serialize an array of form elements or a set of
    // key/values into a query string
    jQuery.param = function (a, traditional) {
        var prefix,
            s = [],
            add = function (key, value) {
                // If value is a function, invoke it and return its value
                value = jQuery.isFunction(value) ? value() : value == null ? '' : value;
                s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
            };

        // Set traditional to true for jQuery <= 1.3.2 behavior.
        if (traditional === undefined) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }

        // If an array was passed in, assume that it is an array of form elements.
        if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
            // Serialize the form elements
            jQuery.each(a, function () {
                add(this.name, this.value);
            });
        } else {
            // If traditional, encode the "old" way (the way 1.3.2 or older
            // did it), otherwise encode params recursively.
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }

        // Return the resulting serialization
        return s.join('&').replace(r20, '+');
    };

    jQuery.fn.extend({
        serialize: function () {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function () {
            return this.map(function () {
                // Can add propHook for "elements" to filter or add form elements
                var elements = jQuery.prop(this, 'elements');
                return elements ? jQuery.makeArray(elements) : this;
            })
                .filter(function () {
                    var type = this.type;
                    // Use .is(":disabled") so that fieldset[disabled] works
                    return (
                        this.name &&
                        !jQuery(this).is(':disabled') &&
                        rsubmittable.test(this.nodeName) &&
                        !rsubmitterTypes.test(type) &&
                        (this.checked || !rcheckableType.test(type))
                    );
                })
                .map(function (i, elem) {
                    var val = jQuery(this).val();

                    return val == null
                        ? null
                        : jQuery.isArray(val)
                        ? jQuery.map(val, function (val) {
                              return { name: elem.name, value: val.replace(rCRLF, '\r\n') };
                          })
                        : { name: elem.name, value: val.replace(rCRLF, '\r\n') };
                })
                .get();
        },
    });

    // Create the request object
    // (This is still attached to ajaxSettings for backward compatibility)
    jQuery.ajaxSettings.xhr =
        window.ActiveXObject !== undefined
            ? // Support: IE6+
              function () {
                  // XHR cannot access local files, always use ActiveX for that case
                  return (
                      (!this.isLocal &&
                          // Support: IE7-8
                          // oldIE XHR does not support non-RFC2616 methods (#13240)
                          // See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
                          // and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
                          // Although this check for six methods instead of eight
                          // since IE also does not support "trace" and "connect"
                          /^(get|post|head|put|delete|options)$/i.test(this.type) &&
                          createStandardXHR()) ||
                      createActiveXHR()
                  );
              }
            : // For all other browsers, use the standard XMLHttpRequest object
              createStandardXHR;

    var xhrId = 0,
        xhrCallbacks = {},
        xhrSupported = jQuery.ajaxSettings.xhr();

    // Support: IE<10
    // Open requests must be manually aborted on unload (#5280)
    // See https://support.microsoft.com/kb/2856746 for more info
    if (window.attachEvent) {
        window.attachEvent('onunload', function () {
            for (var key in xhrCallbacks) {
                xhrCallbacks[key](undefined, true);
            }
        });
    }

    // Determine support properties
    support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
    xhrSupported = support.ajax = !!xhrSupported;

    // Create transport if the browser can provide an xhr
    if (xhrSupported) {
        jQuery.ajaxTransport(function (options) {
            // Cross domain only allowed if supported through XMLHttpRequest
            if (!options.crossDomain || support.cors) {
                var callback;

                return {
                    send: function (headers, complete) {
                        var i,
                            xhr = options.xhr(),
                            id = ++xhrId;

                        // Open the socket
                        xhr.open(options.type, options.url, options.async, options.username, options.password);

                        // Apply custom fields if provided
                        if (options.xhrFields) {
                            for (i in options.xhrFields) {
                                xhr[i] = options.xhrFields[i];
                            }
                        }

                        // Override mime type if needed
                        if (options.mimeType && xhr.overrideMimeType) {
                            xhr.overrideMimeType(options.mimeType);
                        }

                        // X-Requested-With header
                        // For cross-domain requests, seeing as conditions for a preflight are
                        // akin to a jigsaw puzzle, we simply never set it to be sure.
                        // (it can always be set on a per-request basis or even using ajaxSetup)
                        // For same-domain requests, won't change header if already provided.
                        if (!options.crossDomain && !headers['X-Requested-With']) {
                            headers['X-Requested-With'] = 'XMLHttpRequest';
                        }

                        // Set headers
                        for (i in headers) {
                            // Support: IE<9
                            // IE's ActiveXObject throws a 'Type Mismatch' exception when setting
                            // request header to a null-value.
                            //
                            // To keep consistent with other XHR implementations, cast the value
                            // to string and ignore `undefined`.
                            if (headers[i] !== undefined) {
                                xhr.setRequestHeader(i, headers[i] + '');
                            }
                        }

                        // Do send the request
                        // This may raise an exception which is actually
                        // handled in jQuery.ajax (so no try/catch here)
                        xhr.send((options.hasContent && options.data) || null);

                        // Listener
                        callback = function (_, isAbort) {
                            var status, statusText, responses;

                            // Was never called and is aborted or complete
                            if (callback && (isAbort || xhr.readyState === 4)) {
                                // Clean up
                                delete xhrCallbacks[id];
                                callback = undefined;
                                xhr.onreadystatechange = jQuery.noop;

                                // Abort manually if needed
                                if (isAbort) {
                                    if (xhr.readyState !== 4) {
                                        xhr.abort();
                                    }
                                } else {
                                    responses = {};
                                    status = xhr.status;

                                    // Support: IE<10
                                    // Accessing binary-data responseText throws an exception
                                    // (#11426)
                                    if (typeof xhr.responseText === 'string') {
                                        responses.text = xhr.responseText;
                                    }

                                    // Firefox throws an exception when accessing
                                    // statusText for faulty cross-domain requests
                                    try {
                                        statusText = xhr.statusText;
                                    } catch (e) {
                                        // We normalize with Webkit giving an empty statusText
                                        statusText = '';
                                    }

                                    // Filter status for non standard behaviors

                                    // If the request is local and we have data: assume a success
                                    // (success with no data won't get notified, that's the best we
                                    // can do given current implementations)
                                    if (!status && options.isLocal && !options.crossDomain) {
                                        status = responses.text ? 200 : 404;
                                        // IE - #1450: sometimes returns 1223 when it should be 204
                                    } else if (status === 1223) {
                                        status = 204;
                                    }
                                }
                            }

                            // Call complete if needed
                            if (responses) {
                                complete(status, statusText, responses, xhr.getAllResponseHeaders());
                            }
                        };

                        if (!options.async) {
                            // if we're in sync mode we fire the callback
                            callback();
                        } else if (xhr.readyState === 4) {
                            // (IE6 & IE7) if it's in cache and has been
                            // retrieved directly we need to fire the callback
                            setTimeout(callback);
                        } else {
                            // Add to the list of active xhr callbacks
                            xhr.onreadystatechange = xhrCallbacks[id] = callback;
                        }
                    },

                    abort: function () {
                        if (callback) {
                            callback(undefined, true);
                        }
                    },
                };
            }
        });
    }

    // Functions to create xhrs
    function createStandardXHR() {
        try {
            return new window.XMLHttpRequest();
        } catch (e) {}
    }

    function createActiveXHR() {
        try {
            return new window.ActiveXObject('Microsoft.XMLHTTP');
        } catch (e) {}
    }

    // Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript',
        },
        contents: {
            script: /(?:java|ecma)script/,
        },
        converters: {
            'text script': function (text) {
                jQuery.globalEval(text);
                return text;
            },
        },
    });

    // Handle cache's special case and global
    jQuery.ajaxPrefilter('script', function (s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = 'GET';
            s.global = false;
        }
    });

    // Bind script tag hack transport
    jQuery.ajaxTransport('script', function (s) {
        // This transport only deals with cross domain requests
        if (s.crossDomain) {
            var script,
                head = document.head || jQuery('head')[0] || document.documentElement;

            return {
                send: function (_, callback) {
                    script = document.createElement('script');

                    script.async = true;

                    if (s.scriptCharset) {
                        script.charset = s.scriptCharset;
                    }

                    script.src = s.url;

                    // Attach handlers for all browsers
                    script.onload = script.onreadystatechange = function (_, isAbort) {
                        if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {
                            // Handle memory leak in IE
                            script.onload = script.onreadystatechange = null;

                            // Remove the script
                            if (script.parentNode) {
                                script.parentNode.removeChild(script);
                            }

                            // Dereference the script
                            script = null;

                            // Callback if not abort
                            if (!isAbort) {
                                callback(200, 'success');
                            }
                        }
                    };

                    // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
                    // Use native DOM manipulation to avoid our domManip AJAX trickery
                    head.insertBefore(script, head.firstChild);
                },

                abort: function () {
                    if (script) {
                        script.onload(undefined, true);
                    }
                },
            };
        }
    });

    var oldCallbacks = [],
        rjsonp = /(=)\?(?=&|$)|\?\?/;

    // Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: 'callback',
        jsonpCallback: function () {
            var callback = oldCallbacks.pop() || jQuery.expando + '_' + nonce++;
            this[callback] = true;
            return callback;
        },
    });

    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {
        var callbackName,
            overwritten,
            responseContainer,
            jsonProp =
                s.jsonp !== false &&
                (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && !(s.contentType || '').indexOf('application/x-www-form-urlencoded') && rjsonp.test(s.data) && 'data');

        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        if (jsonProp || s.dataTypes[0] === 'jsonp') {
            // Get callback name, remembering preexisting value associated with it
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;

            // Insert callback into url or form data
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
            }

            // Use data converter to retrieve json after script execution
            s.converters['script json'] = function () {
                if (!responseContainer) {
                    jQuery.error(callbackName + ' was not called');
                }
                return responseContainer[0];
            };

            // force json dataType
            s.dataTypes[0] = 'json';

            // Install callback
            overwritten = window[callbackName];
            window[callbackName] = function () {
                responseContainer = arguments;
            };

            // Clean-up function (fires after converters)
            jqXHR.always(function () {
                // Restore preexisting value
                window[callbackName] = overwritten;

                // Save back as free
                if (s[callbackName]) {
                    // make sure that re-using the options doesn't screw things around
                    s.jsonpCallback = originalSettings.jsonpCallback;

                    // save the callback name for future use
                    oldCallbacks.push(callbackName);
                }

                // Call if it was a function and we have a response
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }

                responseContainer = overwritten = undefined;
            });

            // Delegate to script
            return 'script';
        }
    });

    // data: string of html
    // context (optional): If specified, the fragment will be created in this context, defaults to document
    // keepScripts (optional): If true, will include scripts passed in the html string
    jQuery.parseHTML = function (data, context, keepScripts) {
        if (!data || typeof data !== 'string') {
            return null;
        }
        if (typeof context === 'boolean') {
            keepScripts = context;
            context = false;
        }
        context = context || document;

        var parsed = rsingleTag.exec(data),
            scripts = !keepScripts && [];

        // Single tag
        if (parsed) {
            return [context.createElement(parsed[1])];
        }

        parsed = jQuery.buildFragment([data], context, scripts);

        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }

        return jQuery.merge([], parsed.childNodes);
    };

    // Keep a copy of the old load method
    var _load = jQuery.fn.load;

    /**
     * Load a url into a page
     */
    jQuery.fn.load = function (url, params, callback) {
        if (typeof url !== 'string' && _load) {
            return _load.apply(this, arguments);
        }

        var selector,
            response,
            type,
            self = this,
            off = url.indexOf(' ');

        if (off >= 0) {
            selector = jQuery.trim(url.slice(off, url.length));
            url = url.slice(0, off);
        }

        // If it's a function
        if (jQuery.isFunction(params)) {
            // We assume that it's the callback
            callback = params;
            params = undefined;

            // Otherwise, build a param string
        } else if (params && typeof params === 'object') {
            type = 'POST';
        }

        // If we have elements to modify, make the request
        if (self.length > 0) {
            jQuery
                .ajax({
                    url: url,

                    // if "type" variable is undefined, then "GET" method will be used
                    type: type,
                    dataType: 'html',
                    data: params,
                })
                .done(function (responseText) {
                    // Save response for use in complete callback
                    response = arguments;

                    self.html(
                        selector
                            ? // If a selector was specified, locate the right elements in a dummy div
                              // Exclude scripts to avoid IE 'Permission Denied' errors
                              jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector)
                            : // Otherwise use the full result
                              responseText
                    );
                })
                .complete(
                    callback &&
                        function (jqXHR, status) {
                            self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
                        }
                );
        }

        return this;
    };

    // Attach a bunch of functions for handling common AJAX events
    jQuery.each(['ajaxStart', 'ajaxStop', 'ajaxComplete', 'ajaxError', 'ajaxSuccess', 'ajaxSend'], function (i, type) {
        jQuery.fn[type] = function (fn) {
            return this.on(type, fn);
        };
    });

    jQuery.expr.filters.animated = function (elem) {
        return jQuery.grep(jQuery.timers, function (fn) {
            return elem === fn.elem;
        }).length;
    };

    var docElem = window.document.documentElement;

    /**
     * Gets a window from an element
     */
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false;
    }

    jQuery.offset = {
        setOffset: function (elem, options, i) {
            var curPosition,
                curLeft,
                curCSSTop,
                curTop,
                curOffset,
                curCSSLeft,
                calculatePosition,
                position = jQuery.css(elem, 'position'),
                curElem = jQuery(elem),
                props = {};

            // set position first, in-case top/left are set even on static elem
            if (position === 'static') {
                elem.style.position = 'relative';
            }

            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, 'top');
            curCSSLeft = jQuery.css(elem, 'left');
            calculatePosition = (position === 'absolute' || position === 'fixed') && jQuery.inArray('auto', [curCSSTop, curCSSLeft]) > -1;

            // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }

            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
            }

            if (options.top != null) {
                props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft;
            }

            if ('using' in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        },
    };

    jQuery.fn.extend({
        offset: function (options) {
            if (arguments.length) {
                return options === undefined
                    ? this
                    : this.each(function (i) {
                          jQuery.offset.setOffset(this, options, i);
                      });
            }

            var docElem,
                win,
                box = { top: 0, left: 0 },
                elem = this[0],
                doc = elem && elem.ownerDocument;

            if (!doc) {
                return;
            }

            docElem = doc.documentElement;

            // Make sure it's not a disconnected DOM node
            if (!jQuery.contains(docElem, elem)) {
                return box;
            }

            // If we don't have gBCR, just use 0,0 rather than error
            // BlackBerry 5, iOS 3 (original iPhone)
            if (typeof elem.getBoundingClientRect !== strundefined) {
                box = elem.getBoundingClientRect();
            }
            win = getWindow(doc);
            return {
                top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
                left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0),
            };
        },

        position: function () {
            if (!this[0]) {
                return;
            }

            var offsetParent,
                offset,
                parentOffset = { top: 0, left: 0 },
                elem = this[0];

            // fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
            if (jQuery.css(elem, 'position') === 'fixed') {
                // we assume that getBoundingClientRect is available when computed position is fixed
                offset = elem.getBoundingClientRect();
            } else {
                // Get *real* offsetParent
                offsetParent = this.offsetParent();

                // Get correct offsets
                offset = this.offset();
                if (!jQuery.nodeName(offsetParent[0], 'html')) {
                    parentOffset = offsetParent.offset();
                }

                // Add offsetParent borders
                parentOffset.top += jQuery.css(offsetParent[0], 'borderTopWidth', true);
                parentOffset.left += jQuery.css(offsetParent[0], 'borderLeftWidth', true);
            }

            // Subtract parent offsets and element margins
            // note: when an element has margin: auto the offsetLeft and marginLeft
            // are the same in Safari causing offset.left to incorrectly be 0
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
                left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true),
            };
        },

        offsetParent: function () {
            return this.map(function () {
                var offsetParent = this.offsetParent || docElem;

                while (offsetParent && !jQuery.nodeName(offsetParent, 'html') && jQuery.css(offsetParent, 'position') === 'static') {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || docElem;
            });
        },
    });

    // Create scrollLeft and scrollTop methods
    jQuery.each({ scrollLeft: 'pageXOffset', scrollTop: 'pageYOffset' }, function (method, prop) {
        var top = /Y/.test(prop);

        jQuery.fn[method] = function (val) {
            return access(
                this,
                function (elem, method, val) {
                    var win = getWindow(elem);

                    if (val === undefined) {
                        return win ? (prop in win ? win[prop] : win.document.documentElement[method]) : elem[method];
                    }

                    if (win) {
                        win.scrollTo(!top ? val : jQuery(win).scrollLeft(), top ? val : jQuery(win).scrollTop());
                    } else {
                        elem[method] = val;
                    }
                },
                method,
                val,
                arguments.length,
                null
            );
        };
    });

    // Add the top/left cssHooks using jQuery.fn.position
    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // getComputedStyle returns percent when specified for top/left/bottom/right
    // rather than make the css module depend on the offset module, we just check for it here
    jQuery.each(['top', 'left'], function (i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                // if curCSS returns percentage, fallback to offset
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
            }
        });
    });

    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each({ Height: 'height', Width: 'width' }, function (name, type) {
        jQuery.each({ padding: 'inner' + name, content: type, '': 'outer' + name }, function (defaultExtra, funcName) {
            // margin is only for outerHeight, outerWidth
            jQuery.fn[funcName] = function (margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'),
                    extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');

                return access(
                    this,
                    function (elem, type, value) {
                        var doc;

                        if (jQuery.isWindow(elem)) {
                            // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                            // isn't a whole lot we can do. See pull request at this URL for discussion:
                            // https://github.com/jquery/jquery/pull/764
                            return elem.document.documentElement['client' + name];
                        }

                        // Get document width or height
                        if (elem.nodeType === 9) {
                            doc = elem.documentElement;

                            // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
                            // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
                            return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);
                        }

                        return value === undefined
                            ? // Get width or height on the element, requesting but not forcing parseFloat
                              jQuery.css(elem, type, extra)
                            : // Set width or height on the element
                              jQuery.style(elem, type, value, extra);
                    },
                    type,
                    chainable ? margin : undefined,
                    chainable,
                    null
                );
            };
        });
    });

    // The number of elements contained in the matched element set
    jQuery.fn.size = function () {
        return this.length;
    };

    jQuery.fn.andSelf = jQuery.fn.addBack;

    // Register as a named AMD module, since jQuery can be concatenated with other
    // files that may use define, but not via a proper concatenation script that
    // understands anonymous AMD modules. A named AMD is safest and most robust
    // way to register. Lowercase jquery is used because AMD module names are
    // derived from file names, and jQuery is normally delivered in a lowercase
    // file name. Do this after creating the global so that if an AMD module wants
    // to call noConflict to hide this version of jQuery, it will work.

    // Note that for maximum portability, libraries that are not jQuery should
    // declare themselves as anonymous modules, and avoid setting a global if an
    // AMD loader is present. jQuery is a special case. For more information, see
    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

    if (typeof define === 'function' && define.amd) {
        define('jquery', [], function () {
            return jQuery;
        });
    }

    var // Map over jQuery in case of overwrite
        _jQuery = window.jQuery,
        // Map over the $ in case of overwrite
        _$ = window.$;

    jQuery.noConflict = function (deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }

        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }

        return jQuery;
    };

    // Expose jQuery and $ identifiers, even in
    // AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
    // and CommonJS for browser emulators (#13566)
    if (typeof noGlobal === strundefined) {
        window.jQuery = window.$ = jQuery;
    }

    return jQuery;
});

/*
 * iFrame Resizer - v3.5.5 - 2016-06-16
 * File: iframeResizer.js
 * Desc: Force iframes to size to content.
 * Requires: iframeResizer.contentWindow.js to be loaded into the target frame.
 * Doc: https://github.com/davidjbradshaw/iframe-resizer
 * Author: David J. Bradshaw - dave@bradshaw.net
 * Contributor: Jure Mav - jure.mav@gmail.com
 * Contributor: Reed Dadoune - reed@dadoune.com
 */

(function(window) {
  'use strict';

  var
    count                 = 0,
    logEnabled            = false,
    hiddenCheckEnabled    = false,
    msgHeader             = 'message',
    msgHeaderLen          = msgHeader.length,
    msgId                 = '[iFrameSizer]', //Must match iframe msg ID
    msgIdLen              = msgId.length,
    pagePosition          = null,
    requestAnimationFrame = window.requestAnimationFrame,
    resetRequiredMethods  = {max:1,scroll:1,bodyScroll:1,documentElementScroll:1},
    settings              = {},
    timer                 = null,
    logId                 = 'Host Page',

    defaults              = {
      autoResize                : true,
      bodyBackground            : null,
      bodyMargin                : null,
      bodyMarginV1              : 8,
      bodyPadding               : null,
      checkOrigin               : true,
      inPageLinks               : false,
      enablePublicMethods       : true,
      heightCalculationMethod   : 'bodyOffset',
      id                        : 'iFrameResizer',
      interval                  : 32,
      log                       : false,
      maxHeight                 : Infinity,
      maxWidth                  : Infinity,
      minHeight                 : 0,
      minWidth                  : 0,
      resizeFrom                : 'parent',
      scrolling                 : false,
      sizeHeight                : true,
      sizeWidth                 : false,
      tolerance                 : 0,
      widthCalculationMethod    : 'scroll',
      closedCallback            : function(){},
      initCallback              : function(){},
      messageCallback           : function(){warn('MessageCallback function not defined');},
      resizedCallback           : function(){},
      scrollCallback            : function(){return true;}
    };

  function addEventListener(obj,evt,func){
    /* istanbul ignore else */ // Not testable in PhantonJS
    if ('addEventListener' in window){
      obj.addEventListener(evt,func, false);
    } else if ('attachEvent' in window){//IE
      obj.attachEvent('on'+evt,func);
    }
  }

  function removeEventListener(el,evt,func){
    /* istanbul ignore else */ // Not testable in phantonJS
    if ('removeEventListener' in window){
      el.removeEventListener(evt,func, false);
    } else if ('detachEvent' in window){ //IE
      el.detachEvent('on'+evt,func);
    }
  }

  function setupRequestAnimationFrame(){
    var
      vendors = ['moz', 'webkit', 'o', 'ms'],
      x;

    // Remove vendor prefixing if prefixed and break early if not
    for (x = 0; x < vendors.length && !requestAnimationFrame; x += 1) {
      requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    }

    if (!(requestAnimationFrame)){
      log('setup','RequestAnimationFrame not supported');
    }
  }

  function getMyID(iframeId){
    var retStr = 'Host page: '+iframeId;

    if (window.top!==window.self){
      if (window.parentIFrame && window.parentIFrame.getId){
        retStr = window.parentIFrame.getId()+': '+iframeId;
      } else {
        retStr = 'Nested host page: '+iframeId;
      }
    }

    return retStr;
  }

  function formatLogHeader(iframeId){
    return msgId + '[' + getMyID(iframeId) + ']';
  }

  function isLogEnabled(iframeId){
    return settings[iframeId] ? settings[iframeId].log : logEnabled;
  }

  function log(iframeId,msg){
    output('log',iframeId,msg,isLogEnabled(iframeId));
  }

  function info(iframeId,msg){
    output('info',iframeId,msg,isLogEnabled(iframeId));
  }

  function warn(iframeId,msg){
    output('warn',iframeId,msg,true);
  }

  function output(type,iframeId,msg,enabled){
    if (true === enabled && 'object' === typeof window.console){
      console[type](formatLogHeader(iframeId),msg);
    }
  }

  function iFrameListener(event){
    function resizeIFrame(){
      function resize(){
        setSize(messageData);
        setPagePosition(iframeId);
      }

      ensureInRange('Height');
      ensureInRange('Width');

      syncResize(resize,messageData,'init');
    }

    function processMsg(){
      var data = msg.substr(msgIdLen).split(':');

      return {
        iframe: settings[data[0]].iframe,
        id:     data[0],
        height: data[1],
        width:  data[2],
        type:   data[3]
      };
    }

    function ensureInRange(Dimension){
      var
        max  = Number(settings[iframeId]['max' + Dimension]),
        min  = Number(settings[iframeId]['min' + Dimension]),
        dimension = Dimension.toLowerCase(),
        size = Number(messageData[dimension]);

      log(iframeId,'Checking ' + dimension + ' is in range ' + min + '-' + max);

      if (size<min) {
        size=min;
        log(iframeId,'Set ' + dimension + ' to min value');
      }

      if (size>max) {
        size=max;
        log(iframeId,'Set ' + dimension + ' to max value');
      }

      messageData[dimension] = '' + size;
    }


    function isMessageFromIFrame(){
      function checkAllowedOrigin(){
        function checkList(){
          var
            i = 0,
            retCode = false;

          log(iframeId,'Checking connection is from allowed list of origins: ' + checkOrigin);

          for (; i < checkOrigin.length; i++) {
            if (checkOrigin[i] === origin) {
              retCode = true;
              break;
            }
          }
          return retCode;
        }

        function checkSingle(){
          var remoteHost  = settings[iframeId].remoteHost;
          log(iframeId,'Checking connection is from: '+remoteHost);
          return origin === remoteHost;
        }

        return checkOrigin.constructor === Array ? checkList() : checkSingle();
      }

      var
        origin      = event.origin,
        checkOrigin = settings[iframeId].checkOrigin;

      if (checkOrigin && (''+origin !== 'null') && !checkAllowedOrigin()) {
        throw new Error(
          'Unexpected message received from: ' + origin +
          ' for ' + messageData.iframe.id +
          '. Message was: ' + event.data +
          '. This error can be disabled by setting the checkOrigin: false option or by providing of array of trusted domains.'
        );
      }

      return true;
    }

    function isMessageForUs(){
      return msgId === (('' + msg).substr(0,msgIdLen)) && (msg.substr(msgIdLen).split(':')[0] in settings); //''+Protects against non-string msg
    }

    function isMessageFromMetaParent(){
      //Test if this message is from a parent above us. This is an ugly test, however, updating
      //the message format would break backwards compatibity.
      var retCode = messageData.type in {'true':1,'false':1,'undefined':1};

      if (retCode){
        log(iframeId,'Ignoring init message from meta parent page');
      }

      return retCode;
    }

    function getMsgBody(offset){
      return msg.substr(msg.indexOf(':')+msgHeaderLen+offset);
    }

    function forwardMsgFromIFrame(msgBody){
      log(iframeId,'MessageCallback passed: {iframe: '+ messageData.iframe.id + ', message: ' + msgBody + '}');
      callback('messageCallback',{
        iframe: messageData.iframe,
        message: JSON.parse(msgBody)
      });
      log(iframeId,'--');
    }

    function getPageInfo(){
      var
        bodyPosition   = document.body.getBoundingClientRect(),
        iFramePosition = messageData.iframe.getBoundingClientRect();

      return JSON.stringify({
        iframeHeight: iFramePosition.height,
        iframeWidth:  iFramePosition.width,
        clientHeight: Math.max(document.documentElement.clientHeight, window.innerHeight || 0),
        clientWidth:  Math.max(document.documentElement.clientWidth,  window.innerWidth  || 0),
        offsetTop:    parseInt(iFramePosition.top  - bodyPosition.top,  10),
        offsetLeft:   parseInt(iFramePosition.left - bodyPosition.left, 10),
        scrollTop:    window.pageYOffset,
        scrollLeft:   window.pageXOffset
      });
    }

    function sendPageInfoToIframe(iframe,iframeId){
      function debouncedTrigger(){
        trigger(
          'Send Page Info',
          'pageInfo:' + getPageInfo(),
          iframe,
          iframeId
        );
      }

      debouce(debouncedTrigger,32);
    }


    function startPageInfoMonitor(){
      function setListener(type,func){
        function sendPageInfo(){
          if (settings[id]){
            sendPageInfoToIframe(settings[id].iframe,id);
          } else {
            stop();
          }
        }

        ['scroll','resize'].forEach(function(evt){
          log(id, type +  evt + ' listener for sendPageInfo');
          func(window,evt,sendPageInfo);
        });
      }

      function stop(){
        setListener('Remove ', removeEventListener);
      }

      function start(){
        setListener('Add ', addEventListener);
      }

      var id = iframeId; //Create locally scoped copy of iFrame ID

      start();

      settings[id].stopPageInfo = stop;
    }

    function stopPageInfoMonitor(){
      if (settings[iframeId] && settings[iframeId].stopPageInfo){
        settings[iframeId].stopPageInfo();
        delete settings[iframeId].stopPageInfo;
      }
    }

    function checkIFrameExists(){
      var retBool = true;

      if (null === messageData.iframe) {
        warn(iframeId,'IFrame ('+messageData.id+') not found');
        retBool = false;
      }
      return retBool;
    }

    function getElementPosition(target){
      var iFramePosition = target.getBoundingClientRect();

      getPagePosition(iframeId);

      return {
        x: Math.floor( Number(iFramePosition.left) + Number(pagePosition.x) ),
        y: Math.floor( Number(iFramePosition.top)  + Number(pagePosition.y) )
      };
    }

    function scrollRequestFromChild(addOffset){
      /* istanbul ignore next */  //Not testable in Karma
      function reposition(){
        pagePosition = newPosition;
        scrollTo();
        log(iframeId,'--');
      }

      function calcOffset(){
        return {
          x: Number(messageData.width) + offset.x,
          y: Number(messageData.height) + offset.y
        };
      }

      function scrollParent(){
        if (window.parentIFrame){
          window.parentIFrame['scrollTo'+(addOffset?'Offset':'')](newPosition.x,newPosition.y);
        } else {
          warn(iframeId,'Unable to scroll to requested position, window.parentIFrame not found');
        }
      }

      var
        offset = addOffset ? getElementPosition(messageData.iframe) : {x:0,y:0},
        newPosition = calcOffset();

      log(iframeId,'Reposition requested from iFrame (offset x:'+offset.x+' y:'+offset.y+')');

      if(window.top!==window.self){
        scrollParent();
      } else {
        reposition();
      }
    }

    function scrollTo(){
      if (false !== callback('scrollCallback',pagePosition)){
        setPagePosition(iframeId);
      } else {
        unsetPagePosition();
      }
    }

    function findTarget(location){
      function jumpToTarget(){
        var jumpPosition = getElementPosition(target);

        log(iframeId,'Moving to in page link (#'+hash+') at x: '+jumpPosition.x+' y: '+jumpPosition.y);
        pagePosition = {
          x: jumpPosition.x,
          y: jumpPosition.y
        };

        scrollTo();
        log(iframeId,'--');
      }

      function jumpToParent(){
        if (window.parentIFrame){
          window.parentIFrame.moveToAnchor(hash);
        } else {
          log(iframeId,'In page link #'+hash+' not found and window.parentIFrame not found');
        }
      }

      var
        hash     = location.split('#')[1] || '',
        hashData = decodeURIComponent(hash),
        target   = document.getElementById(hashData) || document.getElementsByName(hashData)[0];

      if (target){
        jumpToTarget();
      } else if(window.top!==window.self){
        jumpToParent();
      } else {
        log(iframeId,'In page link #'+hash+' not found');
      }
    }

    function callback(funcName,val){
      return chkCallback(iframeId,funcName,val);
    }

    function actionMsg(){

      if(settings[iframeId].firstRun) firstRun();

      switch(messageData.type){
        case 'close':
          closeIFrame(messageData.iframe);
          break;
        case 'message':
          forwardMsgFromIFrame(getMsgBody(6));
          break;
        case 'scrollTo':
          scrollRequestFromChild(false);
          break;
        case 'scrollToOffset':
          scrollRequestFromChild(true);
          break;
        case 'pageInfo':
          sendPageInfoToIframe(settings[iframeId].iframe,iframeId);
          startPageInfoMonitor();
          break;
        case 'pageInfoStop':
          stopPageInfoMonitor();
          break;
        case 'inPageLink':
          findTarget(getMsgBody(9));
          break;
        case 'reset':
          resetIFrame(messageData);
          break;
        case 'init':
          resizeIFrame();
          callback('initCallback',messageData.iframe);
          callback('resizedCallback',messageData);
          break;
        default:
          resizeIFrame();
          callback('resizedCallback',messageData);
      }
    }

    function hasSettings(iframeId){
      var retBool = true;

      if (!settings[iframeId]){
        retBool = false;
        warn(messageData.type + ' No settings for ' + iframeId + '. Message was: ' + msg);
      }

      return retBool;
    }

    function iFrameReadyMsgReceived(){
      for (var iframeId in settings){
        trigger('iFrame requested init',createOutgoingMsg(iframeId),document.getElementById(iframeId),iframeId);
      }
    }

    function firstRun() {
      settings[iframeId].firstRun = false;
    }

    var
      msg = event.data,
      messageData = {},
      iframeId = null;

    if('[iFrameResizerChild]Ready' === msg){
      iFrameReadyMsgReceived();
    } else if (isMessageForUs()){
      messageData = processMsg();
      iframeId    = logId = messageData.id;

      if (!isMessageFromMetaParent() && hasSettings(iframeId)){
        log(iframeId,'Received: '+msg);

        if ( checkIFrameExists() && isMessageFromIFrame() ){
          actionMsg();
        }
      }
    } else {
      info(iframeId,'Ignored: '+msg);
    }

  }


  function chkCallback(iframeId,funcName,val){
    var
      func = null,
      retVal = null;

    if(settings[iframeId]){
      func = settings[iframeId][funcName];

      if( 'function' === typeof func){
        retVal = func(val);
      } else {
        throw new TypeError(funcName+' on iFrame['+iframeId+'] is not a function');
      }
    }

    return retVal;
  }

  function closeIFrame(iframe){
    var iframeId = iframe.id;

    log(iframeId,'Removing iFrame: '+iframeId);
    iframe.parentNode.removeChild(iframe);
    chkCallback(iframeId,'closedCallback',iframeId);
    log(iframeId,'--');
    delete settings[iframeId];
  }

  function getPagePosition(iframeId){
    if(null === pagePosition){
      pagePosition = {
        x: (window.pageXOffset !== undefined) ? window.pageXOffset : document.documentElement.scrollLeft,
        y: (window.pageYOffset !== undefined) ? window.pageYOffset : document.documentElement.scrollTop
      };
      log(iframeId,'Get page position: '+pagePosition.x+','+pagePosition.y);
    }
  }

  function setPagePosition(iframeId){
    if(null !== pagePosition){
      window.scrollTo(pagePosition.x,pagePosition.y);
      log(iframeId,'Set page position: '+pagePosition.x+','+pagePosition.y);
      unsetPagePosition();
    }
  }

  function unsetPagePosition(){
    pagePosition = null;
  }

  function resetIFrame(messageData){
    function reset(){
      setSize(messageData);
      trigger('reset','reset',messageData.iframe,messageData.id);
    }

    log(messageData.id,'Size reset requested by '+('init'===messageData.type?'host page':'iFrame'));
    getPagePosition(messageData.id);
    syncResize(reset,messageData,'reset');
  }

  function setSize(messageData){
    function setDimension(dimension){
      messageData.iframe.style[dimension] = messageData[dimension] + 'px';
      log(
        messageData.id,
        'IFrame (' + iframeId +
        ') ' + dimension +
        ' set to ' + messageData[dimension] + 'px'
      );
    }

    function chkZero(dimension){
      //FireFox sets dimension of hidden iFrames to zero.
      //So if we detect that set up an event to check for
      //when iFrame becomes visible.

      /* istanbul ignore next */  //Not testable in PhantomJS
      if (!hiddenCheckEnabled && '0' === messageData[dimension]){
        hiddenCheckEnabled = true;
        log(iframeId,'Hidden iFrame detected, creating visibility listener');
        fixHiddenIFrames();
      }
    }

    function processDimension(dimension){
      setDimension(dimension);
      chkZero(dimension);
    }

    var iframeId = messageData.iframe.id;

    if(settings[iframeId]){
      if( settings[iframeId].sizeHeight) { processDimension('height'); }
      if( settings[iframeId].sizeWidth ) { processDimension('width'); }
    }
  }

  function syncResize(func,messageData,doNotSync){
    /* istanbul ignore if */  //Not testable in PhantomJS
    if(doNotSync!==messageData.type && requestAnimationFrame){
      log(messageData.id,'Requesting animation frame');
      requestAnimationFrame(func);
    } else {
      func();
    }
  }

  function trigger(calleeMsg,msg,iframe,id){
    function postMessageToIFrame(){
      var target = settings[id].targetOrigin;
      log(id,'[' + calleeMsg + '] Sending msg to iframe['+id+'] ('+msg+') targetOrigin: '+target);
      iframe.contentWindow.postMessage( msgId + msg, target );
    }

    function iFrameNotFound(){
      info(id,'[' + calleeMsg + '] IFrame('+id+') not found');
      if(settings[id]) {
        delete settings[id];
      }
    }

    function chkAndSend(){
      if(iframe && 'contentWindow' in iframe && (null !== iframe.contentWindow)){ //Null test for PhantomJS
        postMessageToIFrame();
      } else {
        iFrameNotFound();
      }
    }

    id = id || iframe.id;

    if(settings[id]) {
      chkAndSend();
    }

  }

  function createOutgoingMsg(iframeId){
    return iframeId +
      ':' + settings[iframeId].bodyMarginV1 +
      ':' + settings[iframeId].sizeWidth +
      ':' + settings[iframeId].log +
      ':' + settings[iframeId].interval +
      ':' + settings[iframeId].enablePublicMethods +
      ':' + settings[iframeId].autoResize +
      ':' + settings[iframeId].bodyMargin +
      ':' + settings[iframeId].heightCalculationMethod +
      ':' + settings[iframeId].bodyBackground +
      ':' + settings[iframeId].bodyPadding +
      ':' + settings[iframeId].tolerance +
      ':' + settings[iframeId].inPageLinks +
      ':' + settings[iframeId].resizeFrom +
      ':' + settings[iframeId].widthCalculationMethod;
  }

  function setupIFrame(iframe,options){
    function setLimits(){
      function addStyle(style){
        if ((Infinity !== settings[iframeId][style]) && (0 !== settings[iframeId][style])){
          iframe.style[style] = settings[iframeId][style] + 'px';
          log(iframeId,'Set '+style+' = '+settings[iframeId][style]+'px');
        }
      }

      function chkMinMax(dimension){
        if (settings[iframeId]['min'+dimension]>settings[iframeId]['max'+dimension]){
          throw new Error('Value for min'+dimension+' can not be greater than max'+dimension);
        }
      }

      chkMinMax('Height');
      chkMinMax('Width');

      addStyle('maxHeight');
      addStyle('minHeight');
      addStyle('maxWidth');
      addStyle('minWidth');
    }

    function newId(){
      var id = ((options && options.id) || defaults.id + count++);
      if  (null!==document.getElementById(id)){
        id = id + count++;
      }
      return id;
    }

    function ensureHasId(iframeId){
      logId=iframeId;
      if (''===iframeId){
        iframe.id = iframeId =  newId();
        logEnabled = (options || {}).log;
        logId=iframeId;
        log(iframeId,'Added missing iframe ID: '+ iframeId +' (' + iframe.src + ')');
      }


      return iframeId;
    }

    function setScrolling(){
      log(iframeId,'IFrame scrolling ' + (settings[iframeId].scrolling ? 'enabled' : 'disabled') + ' for ' + iframeId);
      iframe.style.overflow = false === settings[iframeId].scrolling ? 'hidden' : 'auto';
      iframe.scrolling      = false === settings[iframeId].scrolling ? 'no' : 'yes';
    }

    //The V1 iFrame script expects an int, where as in V2 expects a CSS
    //string value such as '1px 3em', so if we have an int for V2, set V1=V2
    //and then convert V2 to a string PX value.
    function setupBodyMarginValues(){
      if (('number'===typeof(settings[iframeId].bodyMargin)) || ('0'===settings[iframeId].bodyMargin)){
        settings[iframeId].bodyMarginV1 = settings[iframeId].bodyMargin;
        settings[iframeId].bodyMargin   = '' + settings[iframeId].bodyMargin + 'px';
      }
    }

    function checkReset(){
      // Reduce scope of firstRun to function, because IE8's JS execution
      // context stack is borked and this value gets externally
      // changed midway through running this function!!!
      var
        firstRun           = settings[iframeId].firstRun,
        resetRequertMethod = settings[iframeId].heightCalculationMethod in resetRequiredMethods;

      if (!firstRun && resetRequertMethod){
        resetIFrame({iframe:iframe, height:0, width:0, type:'init'});
      }
    }

    function setupIFrameObject(){
      if(Function.prototype.bind){ //Ignore unpolyfilled IE8.
        settings[iframeId].iframe.iFrameResizer = {

          close        : closeIFrame.bind(null,settings[iframeId].iframe),

          resize       : trigger.bind(null,'Window resize', 'resize', settings[iframeId].iframe),

          moveToAnchor : function(anchor){
            trigger('Move to anchor','moveToAnchor:'+anchor, settings[iframeId].iframe,iframeId);
          },

          sendMessage  : function(message){
            message = JSON.stringify(message);
            trigger('Send Message','message:'+message, settings[iframeId].iframe,iframeId);
          }
        };
      }
    }

    //We have to call trigger twice, as we can not be sure if all
    //iframes have completed loading when this code runs. The
    //event listener also catches the page changing in the iFrame.
    function init(msg){
      function iFrameLoaded(){
        trigger('iFrame.onload',msg,iframe);
        checkReset();
      }

      addEventListener(iframe,'load',iFrameLoaded);
      trigger('init',msg,iframe);
    }

    function checkOptions(options){
      if ('object' !== typeof options){
        throw new TypeError('Options is not an object');
      }
    }

    function copyOptions(options){
      for (var option in defaults) {
        if (defaults.hasOwnProperty(option)){
          settings[iframeId][option] = options.hasOwnProperty(option) ? options[option] : defaults[option];
        }
      }
    }

    function getTargetOrigin (remoteHost){
      return ('' === remoteHost || 'file://' === remoteHost) ? '*' : remoteHost;
    }

    function processOptions(options){
      options = options || {};
      settings[iframeId] = {
        firstRun	: true,
        iframe		: iframe,
        remoteHost	: iframe.src.split('/').slice(0,3).join('/')
      };

      checkOptions(options);
      copyOptions(options);

      settings[iframeId].targetOrigin = true === settings[iframeId].checkOrigin ? getTargetOrigin(settings[iframeId].remoteHost) : '*';
    }

    function beenHere(){
      return (iframeId in settings && 'iFrameResizer' in iframe);
    }

    var iframeId = ensureHasId(iframe.id);

    if (!beenHere()){
      processOptions(options);
      setScrolling();
      setLimits();
      setupBodyMarginValues();
      init(createOutgoingMsg(iframeId));
      setupIFrameObject();
    } else {
      warn(iframeId,'Ignored iFrame, already setup.');
    }
  }

  function debouce(fn,time){
    if (null === timer){
      timer = setTimeout(function(){
        timer = null;
        fn();
      }, time);
    }
  }

  /* istanbul ignore next */  //Not testable in PhantomJS
  function fixHiddenIFrames(){
    function checkIFrames(){
      function checkIFrame(settingId){
        function chkDimension(dimension){
          return '0px' === settings[settingId].iframe.style[dimension];
        }

        function isVisible(el) {
          return (null !== el.offsetParent);
        }

        if (isVisible(settings[settingId].iframe) && (chkDimension('height') || chkDimension('width'))){
          trigger('Visibility change', 'resize', settings[settingId].iframe,settingId);
        }
      }

      for (var settingId in settings){
        checkIFrame(settingId);
      }
    }

    function mutationObserved(mutations){
      log('window','Mutation observed: ' + mutations[0].target + ' ' + mutations[0].type);
      debouce(checkIFrames,16);
    }

    function createMutationObserver(){
      var
        target = document.querySelector('body'),

        config = {
          attributes            : true,
          attributeOldValue     : false,
          characterData         : true,
          characterDataOldValue : false,
          childList             : true,
          subtree               : true
        },

        observer = new MutationObserver(mutationObserved);

      observer.observe(target, config);
    }

    var MutationObserver = window.MutationObserver || window.WebKitMutationObserver;

    if (MutationObserver) createMutationObserver();
  }


  function resizeIFrames(event){
    function resize(){
      sendTriggerMsg('Window '+event,'resize');
    }

    log('window','Trigger event: '+event);
    debouce(resize,16);
  }

  /* istanbul ignore next */  //Not testable in PhantomJS
  function tabVisible() {
    function resize(){
      sendTriggerMsg('Tab Visable','resize');
    }

    if('hidden' !== document.visibilityState) {
      log('document','Trigger event: Visiblity change');
      debouce(resize,16);
    }
  }

  function sendTriggerMsg(eventName,event){
    function isIFrameResizeEnabled(iframeId) {
      return	'parent' === settings[iframeId].resizeFrom &&
        settings[iframeId].autoResize &&
        !settings[iframeId].firstRun;
    }

    for (var iframeId in settings){
      if(isIFrameResizeEnabled(iframeId)){
        trigger(eventName,event,document.getElementById(iframeId),iframeId);
      }
    }
  }

  function setupEventListeners(){
    addEventListener(window,'message',iFrameListener);

    addEventListener(window,'resize', function(){resizeIFrames('resize');});

    addEventListener(document,'visibilitychange',tabVisible);
    addEventListener(document,'-webkit-visibilitychange',tabVisible); //Andriod 4.4
    addEventListener(window,'focusin',function(){resizeIFrames('focus');}); //IE8-9
    addEventListener(window,'focus',function(){resizeIFrames('focus');});
  }


  function factory(){
    function init(options,element){
      function chkType(){
        if(!element.tagName) {
          throw new TypeError('Object is not a valid DOM element');
        } else if ('IFRAME' !== element.tagName.toUpperCase()) {
          throw new TypeError('Expected <IFRAME> tag, found <'+element.tagName+'>');
        }
      }

      if(element) {
        chkType();
        setupIFrame(element, options);
        iFrames.push(element);
      }
    }

    var iFrames;

    setupRequestAnimationFrame();
    setupEventListeners();

    return function iFrameResizeF(options,target){
      iFrames = []; //Only return iFrames past in on this call

      switch (typeof(target)){
        case 'undefined':
        case 'string':
          Array.prototype.forEach.call(
            document.querySelectorAll( target || 'iframe' ),
            init.bind(undefined, options)
          );
          break;
        case 'object':
          init(options,target);
          break;
        default:
          throw new TypeError('Unexpected data type ('+typeof(target)+')');
      }

      return iFrames;
    };
  }

  function createJQueryPublicMethod($){
    if (!$.fn) {
      info('','Unable to bind to jQuery, it is not fully loaded.');
    } else {
      $.fn.iFrameResize355 = function $iFrameResizeF(options) {
        function init(index, element) {
          setupIFrame(element, options);
        }

        return this.filter('iframe').each(init).end();
      };
    }
  }

  if (window.jQuery) { createJQueryPublicMethod(jQuery); }

  if (typeof define === 'function' && define.amd) {
    define([],factory);
  } else if (typeof module === 'object' && typeof module.exports === 'object') { //Node for browserfy
    module.exports = factory();
  } else {
    window.iFrameResize355 = window.iFrameResize355 || factory();
  }

})(window || {});
'use strict';
/*
 * babelify version of jquery.overlayScrollbars.js
 *
 * used babel throught  https://babeljs.io/repl  :
 * - uncheck react preset (had only es2015 and stage-2 checked)
 * - set sourcetype as Script
 * - enabled ENV PRESET
 * - added "ie 11" in the prothers field  as a target
*/

function _instanceof(left, right) {
    if (right != null && typeof Symbol !== 'undefined' && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}

function _typeof(obj) {
    if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
        _typeof = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof = function _typeof(obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
        };
    }
    return _typeof(obj);
}

/*!
 * OverlayScrollbars
 * https://github.com/KingSora/OverlayScrollbars
 *
 * Version: 1.10.0
 *
 * Copyright KingSora | Rene Haas.
 * https://github.com/KingSora
 *
 * Released under the MIT license.
 * Date: 11.10.2019
 */
(function(global, factory) {
    if (typeof define === 'function' && define.amd)
        define(['jquery'], function(framework) {
            return factory(global, global.document, undefined, framework);
        });
    else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && _typeof(module.exports) === 'object')
        module.exports = factory(global, global.document, undefined, require('jquery'));
    else factory(global, global.document, undefined, global.jQuery);
})(typeof window !== 'undefined' ? window : void 0, function(window, document, undefined, framework) {
    'use strict';

    var PLUGINNAME = 'OverlayScrollbars';
    var TYPES = {
        o: 'object',
        f: 'function',
        a: 'array',
        s: 'string',
        b: 'boolean',
        n: 'number',
        u: 'undefined',
        z: 'null' //d : 'date',
        //e : 'error',
        //r : 'regexp',
        //y : 'symbol'
    };
    var LEXICON = {
        c: 'class',
        s: 'style',
        i: 'id',
        l: 'length',
        p: 'prototype',
        oH: 'offsetHeight',
        cH: 'clientHeight',
        sH: 'scrollHeight',
        oW: 'offsetWidth',
        cW: 'clientWidth',
        sW: 'scrollWidth',
        hOP: 'hasOwnProperty',
        bCR: 'getBoundingClientRect'
    };

    var VENDORS = (function() {
        //https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix
        var jsCache = {};
        var cssCache = {};
        var cssPrefixes = ['-webkit-', '-moz-', '-o-', '-ms-'];
        var jsPrefixes = ['WebKit', 'Moz', 'O', 'MS'];

        function firstLetterToUpper(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        return {
            _cssPrefixes: cssPrefixes,
            _jsPrefixes: jsPrefixes,
            _cssProperty: function _cssProperty(name) {
                var result = cssCache[name];
                if (cssCache[LEXICON.hOP](name)) return result;
                var uppercasedName = firstLetterToUpper(name);
                var elmStyle = document.createElement('div')[LEXICON.s];
                var resultPossibilities;
                var i = 0;
                var v;
                var currVendorWithoutDashes;

                for (; i < cssPrefixes.length; i++) {
                    currVendorWithoutDashes = cssPrefixes[i].replace(/-/g, '');
                    resultPossibilities = [
                        name, //transition
                        cssPrefixes[i] + name, //-webkit-transition
                        currVendorWithoutDashes + uppercasedName, //webkitTransition
                        firstLetterToUpper(currVendorWithoutDashes) + uppercasedName //WebkitTransition
                    ];

                    for (v = 0; v < resultPossibilities[LEXICON.l]; v++) {
                        if (elmStyle[resultPossibilities[v]] !== undefined) {
                            result = resultPossibilities[v];
                            break;
                        }
                    }
                }

                cssCache[name] = result;
                return result;
            },
            _jsAPI: function _jsAPI(name, isInterface, fallback) {
                var i = 0;
                var result = jsCache[name];

                if (!jsCache[LEXICON.hOP](name)) {
                    result = window[name];

                    for (; i < jsPrefixes[LEXICON.l]; i++) {
                        result = result || window[(isInterface ? jsPrefixes[i] : jsPrefixes[i].toLowerCase()) + firstLetterToUpper(name)];
                    }

                    jsCache[name] = result;
                }

                return result || fallback;
            }
        };
    })();

    var COMPATIBILITY = (function() {
        function windowSize(x) {
            return x
                ? window.innerWidth || document.documentElement[LEXICON.cW] || document.body[LEXICON.cW]
                : window.innerHeight || document.documentElement[LEXICON.cH] || document.body[LEXICON.cH];
        }

        function bind(func, thisObj) {
            if (_typeof(func) != TYPES.f) {
                throw "Can't bind function!"; // closest thing possible to the ECMAScript 5
                // internal IsCallable function
                //throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
            }

            var proto = LEXICON.p;
            var aArgs = Array[proto].slice.call(arguments, 2);

            var fNOP = function fNOP() {};

            var fBound = function fBound() {
                return func.apply(_instanceof(this, fNOP) ? this : thisObj, aArgs.concat(Array[proto].slice.call(arguments)));
            };

            if (func[proto]) fNOP[proto] = func[proto]; // Function.prototype doesn't have a prototype property

            fBound[proto] = new fNOP();
            return fBound;
        }

        return {
            /**
             * Gets the current window width.
             * @returns {Number|number} The current window width in pixel.
             */
            wW: bind(windowSize, 0, true),

            /**
             * Gets the current window height.
             * @returns {Number|number} The current window height in pixel.
             */
            wH: bind(windowSize, 0),

            /**
             * Gets the MutationObserver Object or undefined if not supported.
             * @returns {MutationObserver|*|undefined} The MutationsObserver Object or undefined.
             */
            mO: bind(VENDORS._jsAPI, 0, 'MutationObserver', true),

            /**
             * Gets the ResizeObserver Object or undefined if not supported.
             * @returns {MutationObserver|*|undefined} The ResizeObserver Object or undefined.
             */
            rO: bind(VENDORS._jsAPI, 0, 'ResizeObserver', true),

            /**
             * Gets the RequestAnimationFrame method or it's corresponding polyfill.
             * @returns {*|Function} The RequestAnimationFrame method or it's corresponding polyfill.
             */
            rAF: bind(VENDORS._jsAPI, 0, 'requestAnimationFrame', false, function(func) {
                return window.setTimeout(func, 1000 / 60);
            }),

            /**
             * Gets the CancelAnimationFrame method or it's corresponding polyfill.
             * @returns {*|Function} The CancelAnimationFrame method or it's corresponding polyfill.
             */
            cAF: bind(VENDORS._jsAPI, 0, 'cancelAnimationFrame', false, function(id) {
                return window.clearTimeout(id);
            }),

            /**
             * Gets the current time.
             * @returns {number} The current time.
             */
            now: function now() {
                return (Date.now && Date.now()) || new Date().getTime();
            },

            /**
             * Stops the propagation of the given event.
             * @param event The event of which the propagation shall be stoped.
             */
            stpP: function stpP(event) {
                if (event.stopPropagation) event.stopPropagation();
                else event.cancelBubble = true;
            },

            /**
             * Prevents the default action of the given event.
             * @param event The event of which the default action shall be prevented.
             */
            prvD: function prvD(event) {
                if (event.preventDefault && event.cancelable) event.preventDefault();
                else event.returnValue = false;
            },

            /**
             * Gets the pageX and pageY values of the given mouse event.
             * @param event The mouse event of which the pageX and pageX shall be got.
             * @returns {{x: number, y: number}} x = pageX value, y = pageY value.
             */
            page: function page(event) {
                event = event.originalEvent || event;
                var strPage = 'page';
                var strClient = 'client';
                var strX = 'X';
                var strY = 'Y';
                var target = event.target || event.srcElement || document;
                var eventDoc = target.ownerDocument || document;
                var doc = eventDoc.documentElement;
                var body = eventDoc.body; //if touch event return return pageX/Y of it

                if (event.touches !== undefined) {
                    var touch = event.touches[0];
                    return {
                        x: touch[strPage + strX],
                        y: touch[strPage + strY]
                    };
                } // Calculate pageX/Y if not native supported

                if (!event[strPage + strX] && event[strClient + strX] && event[strClient + strX] != null) {
                    return {
                        x: event[strClient + strX] + ((doc && doc.scrollLeft) || (body && body.scrollLeft) || 0) - ((doc && doc.clientLeft) || (body && body.clientLeft) || 0),
                        y: event[strClient + strY] + ((doc && doc.scrollTop) || (body && body.scrollTop) || 0) - ((doc && doc.clientTop) || (body && body.clientTop) || 0)
                    };
                }

                return {
                    x: event[strPage + strX],
                    y: event[strPage + strY]
                };
            },

            /**
             * Gets the clicked mouse button of the given mouse event.
             * @param event The mouse event of which the clicked button shal be got.
             * @returns {number} The number of the clicked mouse button. (0 : none | 1 : leftButton | 2 : middleButton | 3 : rightButton)
             */
            mBtn: function mBtn(event) {
                var button = event.button;
                if (!event.which && button !== undefined) return button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                else return event.which;
            },

            /**
             * Checks whether a item is in the given array and returns its index.
             * @param item The item of which the position in the array shall be determined.
             * @param arr The array.
             * @returns {number} The zero based index of the item or -1 if the item isn't in the array.
             */
            inA: function inA(item, arr) {
                for (var i = 0; i < arr[LEXICON.l]; i++) {
                    //Sometiems in IE a "SCRIPT70" Permission denied error occurs if HTML elements in a iFrame are compared
                    try {
                        if (arr[i] === item) return i;
                    } catch (e) {}
                }

                return -1;
            },

            /**
             * Returns true if the given value is a array.
             * @param arr The potential array.
             * @returns {boolean} True if the given value is a array, false otherwise.
             */
            isA: function isA(arr) {
                var def = Array.isArray;
                return def ? def(arr) : this.type(arr) == TYPES.a;
            },

            /**
             * Determine the internal JavaScript [[Class]] of the given object.
             * @param obj The object of which the type shall be determined.
             * @returns {string} The type of the given object.
             */
            type: function type(obj) {
                if (obj === undefined) return obj + '';
                if (obj === null) return obj + '';
                return Object[LEXICON.p].toString
                    .call(obj)
                    .replace(/^\[object (.+)\]$/, '$1')
                    .toLowerCase();
            },
            bind: bind
            /**
       * Gets the vendor-prefixed CSS property by the given name.
       * For example the given name is "transform" and you're using a old Firefox browser then the returned value would be "-moz-transform".
       * If the browser doesn't need a vendor-prefix, then the returned string is the given name.
       * If the browser doesn't support the given property name at all (not even with a vendor-prefix) the returned value is null.
       * @param propName The unprefixed CSS property name.
       * @returns {string|null} The vendor-prefixed CSS property or null if the browser doesn't support the given CSS property.
       cssProp: function(propName) {
          return VENDORS._cssProperty(propName);
      }
      */
        };
    })();

    var MATH = Math;
    var JQUERY = framework;
    var EASING = framework.easing;
    var FRAMEWORK = framework;

    var INSTANCES = (function() {
        var _targets = [];
        var _instancePropertyString = '__overlayScrollbars__';
        /**
         * Register, unregister or get a certain (or all) instances.
         * Register: Pass the target and the instance.
         * Unregister: Pass the target and null.
         * Get Instance: Pass the target from which the instance shall be got.
         * Get Targets: Pass no arguments.
         * @param target The target to which the instance shall be registered / from which the instance shall be unregistered / the instance shall be got
         * @param instance The instance.
         * @returns {*|void} Returns the instance from the given target.
         */

        return function(target, instance) {
            var argLen = arguments[LEXICON.l];

            if (argLen < 1) {
                //return all targets
                return _targets;
            } else {
                if (instance) {
                    //register instance
                    target[_instancePropertyString] = instance;

                    _targets.push(target);
                } else {
                    var index = COMPATIBILITY.inA(target, _targets);

                    if (index > -1) {
                        if (argLen > 1) {
                            //unregister instance
                            delete target[_instancePropertyString];

                            _targets.splice(index, 1);
                        } else {
                            //get instance from target
                            return _targets[index][_instancePropertyString];
                        }
                    }
                }
            }
        };
    })();

    var PLUGIN = (function() {
        var _plugin;

        var _pluginsGlobals;

        var _pluginsAutoUpdateLoop;

        var _pluginsExtensions = [];

        var _pluginsOptions = (function() {
            var type = COMPATIBILITY.type;
            var possibleTemplateTypes = [
                TYPES.b, //boolean
                TYPES.n, //number
                TYPES.s, //string
                TYPES.a, //array
                TYPES.o, //object
                TYPES.f, //function
                TYPES.z //null
            ];
            var restrictedStringsSplit = ' ';
            var restrictedStringsPossibilitiesSplit = ':';
            var classNameAllowedValues = [TYPES.z, TYPES.s];
            var numberAllowedValues = TYPES.n;
            var booleanNullAllowedValues = [TYPES.z, TYPES.b];
            var booleanTrueTemplate = [true, TYPES.b];
            var booleanFalseTemplate = [false, TYPES.b];
            var callbackTemplate = [null, [TYPES.z, TYPES.f]];
            var inheritedAttrsTemplate = [
                ['style', 'class'],
                [TYPES.s, TYPES.a, TYPES.z]
            ];
            var resizeAllowedValues = 'n:none b:both h:horizontal v:vertical';
            var overflowBehaviorAllowedValues = 'v-h:visible-hidden v-s:visible-scroll s:scroll h:hidden';
            var scrollbarsVisibilityAllowedValues = 'v:visible h:hidden a:auto';
            var scrollbarsAutoHideAllowedValues = 'n:never s:scroll l:leave m:move';
            var optionsDefaultsAndTemplate = {
                className: ['os-theme-dark', classNameAllowedValues],
                //null || string
                resize: ['none', resizeAllowedValues],
                //none || both  || horizontal || vertical || n || b || h || v
                sizeAutoCapable: booleanTrueTemplate,
                //true || false
                clipAlways: booleanTrueTemplate,
                //true || false
                normalizeRTL: booleanTrueTemplate,
                //true || false
                paddingAbsolute: booleanFalseTemplate,
                //true || false
                autoUpdate: [null, booleanNullAllowedValues],
                //true || false || null
                autoUpdateInterval: [33, numberAllowedValues],
                //number
                nativeScrollbarsOverlaid: {
                    showNativeScrollbars: booleanFalseTemplate,
                    //true || false
                    initialize: booleanTrueTemplate //true || false
                },
                overflowBehavior: {
                    x: ['scroll', overflowBehaviorAllowedValues],
                    //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s
                    y: ['scroll', overflowBehaviorAllowedValues] //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s
                },
                scrollbars: {
                    visibility: ['auto', scrollbarsVisibilityAllowedValues],
                    //visible || hidden || auto || v || h || a
                    autoHide: ['never', scrollbarsAutoHideAllowedValues],
                    //never || scroll || leave || move || n || s || l || m
                    autoHideDelay: [800, numberAllowedValues],
                    //number
                    dragScrolling: booleanTrueTemplate,
                    //true || false
                    clickScrolling: booleanFalseTemplate,
                    //true || false
                    touchSupport: booleanTrueTemplate,
                    //true || false
                    snapHandle: booleanFalseTemplate //true || false
                },
                textarea: {
                    dynWidth: booleanFalseTemplate,
                    //true || false
                    dynHeight: booleanFalseTemplate,
                    //true || false
                    inheritedAttrs: inheritedAttrsTemplate //string || array || null
                },
                callbacks: {
                    onInitialized: callbackTemplate,
                    //null || function
                    onInitializationWithdrawn: callbackTemplate,
                    //null || function
                    onDestroyed: callbackTemplate,
                    //null || function
                    onScrollStart: callbackTemplate,
                    //null || function
                    onScroll: callbackTemplate,
                    //null || function
                    onScrollStop: callbackTemplate,
                    //null || function
                    onOverflowChanged: callbackTemplate,
                    //null || function
                    onOverflowAmountChanged: callbackTemplate,
                    //null || function
                    onDirectionChanged: callbackTemplate,
                    //null || function
                    onContentSizeChanged: callbackTemplate,
                    //null || function
                    onHostSizeChanged: callbackTemplate,
                    //null || function
                    onUpdated: callbackTemplate //null || function
                }
            };

            var convert = function convert(template) {
                var recursive = function recursive(obj) {
                    var key;
                    var val;
                    var valType;

                    for (key in obj) {
                        if (!obj[LEXICON.hOP](key)) continue;
                        val = obj[key];
                        valType = type(val);
                        if (valType == TYPES.a) obj[key] = val[template ? 1 : 0];
                        else if (valType == TYPES.o) obj[key] = recursive(val);
                    }

                    return obj;
                };

                return recursive(FRAMEWORK.extend(true, {}, optionsDefaultsAndTemplate));
            };

            return {
                _defaults: convert(),
                _template: convert(true),

                /**
                 * Validates the passed object by the passed template.
                 * @param obj The object which shall be validated.
                 * @param template The template which defines the allowed values and types.
                 * @param writeErrors True if errors shall be logged to the console.
                 * @param diffObj If a object is passed then only valid differences to this object will be returned.
                 * @returns {{}} A object which contains two objects called "default" and "prepared" which contains only the valid properties of the passed original object and discards not different values compared to the passed diffObj.
                 */
                _validate: function _validate(obj, template, writeErrors, diffObj) {
                    var validatedOptions = {};
                    var validatedOptionsPrepared = {};
                    var objectCopy = FRAMEWORK.extend(true, {}, obj);
                    var inArray = FRAMEWORK.inArray;
                    var isEmptyObj = FRAMEWORK.isEmptyObject;

                    var checkObjectProps = function checkObjectProps(data, template, diffData, validatedOptions, validatedOptionsPrepared, prevPropName) {
                        for (var prop in template) {
                            if (template[LEXICON.hOP](prop) && data[LEXICON.hOP](prop)) {
                                var isValid = false;
                                var isDiff = false;
                                var templateValue = template[prop];
                                var templateValueType = type(templateValue);
                                var templateIsComplex = templateValueType == TYPES.o;
                                var templateTypes = type(templateValue) != TYPES.a ? [templateValue] : templateValue;
                                var dataDiffValue = diffData[prop];
                                var dataValue = data[prop];
                                var dataValueType = type(dataValue);
                                var propPrefix = prevPropName ? prevPropName + '.' : '';
                                var error = 'The option "' + propPrefix + prop + '" wasn\'t set, because';
                                var errorPossibleTypes = [];
                                var errorRestrictedStrings = [];
                                var restrictedStringValuesSplit;
                                var restrictedStringValuesPossibilitiesSplit;
                                var isRestrictedValue;
                                var mainPossibility;
                                var currType;
                                var i;
                                var v;
                                var j;
                                dataDiffValue = dataDiffValue === undefined ? {} : dataDiffValue; //if the template has a object as value, it means that the options are complex (verschachtelt)

                                if (templateIsComplex && dataValueType == TYPES.o) {
                                    validatedOptions[prop] = {};
                                    validatedOptionsPrepared[prop] = {};
                                    checkObjectProps(dataValue, templateValue, dataDiffValue, validatedOptions[prop], validatedOptionsPrepared[prop], propPrefix + prop);
                                    FRAMEWORK.each([data, validatedOptions, validatedOptionsPrepared], function(index, value) {
                                        if (isEmptyObj(value[prop])) {
                                            delete value[prop];
                                        }
                                    });
                                } else if (!templateIsComplex) {
                                    for (i = 0; i < templateTypes[LEXICON.l]; i++) {
                                        currType = templateTypes[i];
                                        templateValueType = type(currType); //if currtype is string and starts with restrictedStringPrefix and end with restrictedStringSuffix

                                        isRestrictedValue = templateValueType == TYPES.s && inArray(currType, possibleTemplateTypes) === -1;

                                        if (isRestrictedValue) {
                                            errorPossibleTypes.push(TYPES.s); //split it into a array which contains all possible values for example: ["y:yes", "n:no", "m:maybe"]

                                            restrictedStringValuesSplit = currType.split(restrictedStringsSplit);
                                            errorRestrictedStrings = errorRestrictedStrings.concat(restrictedStringValuesSplit);

                                            for (v = 0; v < restrictedStringValuesSplit[LEXICON.l]; v++) {
                                                //split the possible values into their possibiliteis for example: ["y", "yes"] -> the first is always the mainPossibility
                                                restrictedStringValuesPossibilitiesSplit = restrictedStringValuesSplit[v].split(restrictedStringsPossibilitiesSplit);
                                                mainPossibility = restrictedStringValuesPossibilitiesSplit[0];

                                                for (j = 0; j < restrictedStringValuesPossibilitiesSplit[LEXICON.l]; j++) {
                                                    //if any possibility matches with the dataValue, its valid
                                                    if (dataValue === restrictedStringValuesPossibilitiesSplit[j]) {
                                                        isValid = true;
                                                        break;
                                                    }
                                                }

                                                if (isValid) break;
                                            }
                                        } else {
                                            errorPossibleTypes.push(currType);

                                            if (dataValueType === currType) {
                                                isValid = true;
                                                break;
                                            }
                                        }
                                    }

                                    if (isValid) {
                                        isDiff = dataValue !== dataDiffValue;
                                        if (isDiff) validatedOptions[prop] = dataValue;
                                        if (isRestrictedValue ? inArray(dataDiffValue, restrictedStringValuesPossibilitiesSplit) < 0 : isDiff)
                                            validatedOptionsPrepared[prop] = isRestrictedValue ? mainPossibility : dataValue;
                                    } else if (writeErrors) {
                                        console.warn(
                                            error +
                                                " it doesn't accept the type [ " +
                                                dataValueType.toUpperCase() +
                                                ' ] with the value of "' +
                                                dataValue +
                                                '".\r\n' +
                                                'Accepted types are: [ ' +
                                                errorPossibleTypes.join(', ').toUpperCase() +
                                                ' ].' +
                                                (errorRestrictedStrings[length] > 0
                                                    ? '\r\nValid strings are: [ ' +
                                                      errorRestrictedStrings
                                                          .join(', ')
                                                          .split(restrictedStringsPossibilitiesSplit)
                                                          .join(', ') +
                                                      ' ].'
                                                    : '')
                                        );
                                    }

                                    delete data[prop];
                                }
                            }
                        }
                    };

                    checkObjectProps(objectCopy, template, diffObj || {}, validatedOptions, validatedOptionsPrepared); //add values which aren't specified in the template to the finished validated object to prevent them from being discarded

                    /*
          if(keepForeignProps) {
              FRAMEWORK.extend(true, validatedOptions, objectCopy);
              FRAMEWORK.extend(true, validatedOptionsPrepared, objectCopy);
          }
          */

                    if (!isEmptyObj(objectCopy) && writeErrors)
                        console.warn('The following options are discarded due to invalidity:\r\n' + window.JSON.stringify(objectCopy, null, 2));
                    return {
                        _default: validatedOptions,
                        _prepared: validatedOptionsPrepared
                    };
                }
            };
        })();
        /**
         * Initializes the object which contains global information about the plugin and each instance of it.
         */

        function initOverlayScrollbarsStatics() {
            if (!_pluginsGlobals) _pluginsGlobals = new OverlayScrollbarsGlobals(_pluginsOptions._defaults);
            if (!_pluginsAutoUpdateLoop) _pluginsAutoUpdateLoop = new OverlayScrollbarsAutoUpdateLoop(_pluginsGlobals);
        }
        /**
         * The global object for the OverlayScrollbars objects. It contains resources which every OverlayScrollbars object needs. This object is initialized only once: if the first OverlayScrollbars object gets initialized.
         * @param defaultOptions
         * @constructor
         */

        function OverlayScrollbarsGlobals(defaultOptions) {
            var _base = this;

            var strOverflow = 'overflow';
            var strHidden = 'hidden';
            var strScroll = 'scroll';
            var bodyElement = FRAMEWORK('body');
            var scrollbarDummyElement = FRAMEWORK('<div id="os-dummy-scrollbar-size"><div></div></div>');
            var scrollbarDummyElement0 = scrollbarDummyElement[0];
            var dummyContainerChild = FRAMEWORK(scrollbarDummyElement.children('div').eq(0));
            bodyElement.append(scrollbarDummyElement);
            scrollbarDummyElement.hide().show(); //fix IE8 bug (incorrect measuring)

            var nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement0);
            var nativeScrollbarIsOverlaid = {
                x: nativeScrollbarSize.x === 0,
                y: nativeScrollbarSize.y === 0
            };

            var msie = (function() {
                var ua = window.navigator.userAgent;
                var strIndexOf = 'indexOf';
                var strSubString = 'substring';
                var msie = ua[strIndexOf]('MSIE ');
                var trident = ua[strIndexOf]('Trident/');
                var edge = ua[strIndexOf]('Edge/');
                var rv = ua[strIndexOf]('rv:');
                var result;
                var parseIntFunc = parseInt; // IE 10 or older => return version number

                if (msie > 0) result = parseIntFunc(ua[strSubString](msie + 5, ua[strIndexOf]('.', msie)), 10);
                // IE 11 => return version number
                else if (trident > 0) result = parseIntFunc(ua[strSubString](rv + 3, ua[strIndexOf]('.', rv)), 10);
                // Edge (IE 12+) => return version number
                else if (edge > 0) result = parseIntFunc(ua[strSubString](edge + 5, ua[strIndexOf]('.', edge)), 10); // other browser

                return result;
            })();

            FRAMEWORK.extend(_base, {
                defaultOptions: defaultOptions,
                msie: msie,
                autoUpdateLoop: false,
                autoUpdateRecommended: !COMPATIBILITY.mO(),
                nativeScrollbarSize: nativeScrollbarSize,
                nativeScrollbarIsOverlaid: nativeScrollbarIsOverlaid,
                nativeScrollbarStyling: (function() {
                    var result = false;
                    scrollbarDummyElement.addClass('os-viewport-native-scrollbars-invisible');

                    try {
                        result =
                            (scrollbarDummyElement.css('scrollbar-width') === 'none' && (msie > 9 || !msie)) ||
                            window.getComputedStyle(scrollbarDummyElement0, '::-webkit-scrollbar').getPropertyValue('display') === 'none';
                    } catch (ex) {} //fix opera bug: scrollbar styles will only appear if overflow value is scroll or auto during the activation of the style.
                    //and set overflow to scroll
                    //scrollbarDummyElement.css(strOverflow, strHidden).hide().css(strOverflow, strScroll).show();
                    //return (scrollbarDummyElement0[LEXICON.oH] - scrollbarDummyElement0[LEXICON.cH]) === 0 && (scrollbarDummyElement0[LEXICON.oW] - scrollbarDummyElement0[LEXICON.cW]) === 0;

                    return result;
                })(),
                overlayScrollbarDummySize: {
                    x: 30,
                    y: 30
                },
                cssCalc: (function() {
                    var dummyStyle = document.createElement('div')[LEXICON.s];
                    var strCalc = 'calc';
                    var i = -1;
                    var prop;

                    for (; i < VENDORS._cssPrefixes[LEXICON.l]; i++) {
                        prop = i < 0 ? strCalc : VENDORS._cssPrefixes[i] + strCalc;
                        dummyStyle.cssText = 'width:' + prop + '(1px);';
                        if (dummyStyle[LEXICON.l]) return prop;
                    }

                    return null;
                })(),
                restrictedMeasuring: (function() {
                    //https://bugzilla.mozilla.org/show_bug.cgi?id=1439305
                    scrollbarDummyElement.css(strOverflow, strHidden);
                    var scrollSize = {
                        w: scrollbarDummyElement0[LEXICON.sW],
                        h: scrollbarDummyElement0[LEXICON.sH]
                    };
                    scrollbarDummyElement.css(strOverflow, 'visible');
                    var scrollSize2 = {
                        w: scrollbarDummyElement0[LEXICON.sW],
                        h: scrollbarDummyElement0[LEXICON.sH]
                    };
                    return scrollSize.w - scrollSize2.w !== 0 || scrollSize.h - scrollSize2.h !== 0;
                })(),
                rtlScrollBehavior: (function() {
                    scrollbarDummyElement
                        .css({
                            'overflow-y': strHidden,
                            'overflow-x': strScroll,
                            'direction': 'rtl'
                        })
                        .scrollLeft(0);
                    var dummyContainerOffset = scrollbarDummyElement.offset();
                    var dummyContainerChildOffset = dummyContainerChild.offset();
                    scrollbarDummyElement.scrollLeft(999);
                    var dummyContainerScrollOffsetAfterScroll = dummyContainerChild.offset();
                    return {
                        //origin direction = determines if the zero scroll position is on the left or right side
                        //'i' means 'invert' (i === true means that the axis must be inverted to be correct)
                        //true = on the left side
                        //false = on the right side
                        i: dummyContainerOffset.left === dummyContainerChildOffset.left,
                        //negative = determines if the maximum scroll is positive or negative
                        //'n' means 'negate' (n === true means that the axis must be negated to be correct)
                        //true = negative
                        //false = positive
                        n: dummyContainerChildOffset.left - dummyContainerScrollOffsetAfterScroll.left === 0
                    };
                })(),
                supportTransform: VENDORS._cssProperty('transform') !== undefined,
                supportTransition: VENDORS._cssProperty('transition') !== undefined,
                supportPassiveEvents: (function() {
                    var supportsPassive = false;

                    try {
                        window.addEventListener(
                            'test',
                            null,
                            Object.defineProperty({}, 'passive', {
                                get: function get() {
                                    supportsPassive = true;
                                }
                            })
                        );
                    } catch (e) {}

                    return supportsPassive;
                })(),
                supportResizeObserver: !!COMPATIBILITY.rO(),
                supportMutationObserver: !!COMPATIBILITY.mO()
            });
            scrollbarDummyElement.removeAttr(LEXICON.s).remove(); //Catch zoom event:

            (function() {
                if (nativeScrollbarIsOverlaid.x && nativeScrollbarIsOverlaid.y) return;
                var abs = MATH.abs;
                var windowWidth = COMPATIBILITY.wW();
                var windowHeight = COMPATIBILITY.wH();
                var windowDpr = getWindowDPR();

                var onResize = function onResize() {
                    if (INSTANCES().length > 0) {
                        var newW = COMPATIBILITY.wW();
                        var newH = COMPATIBILITY.wH();
                        var deltaW = newW - windowWidth;
                        var deltaH = newH - windowHeight;
                        if (deltaW === 0 && deltaH === 0) return;
                        var deltaWRatio = MATH.round(newW / (windowWidth / 100.0));
                        var deltaHRatio = MATH.round(newH / (windowHeight / 100.0));
                        var absDeltaW = abs(deltaW);
                        var absDeltaH = abs(deltaH);
                        var absDeltaWRatio = abs(deltaWRatio);
                        var absDeltaHRatio = abs(deltaHRatio);
                        var newDPR = getWindowDPR();
                        var deltaIsBigger = absDeltaW > 2 && absDeltaH > 2;
                        var difference = !differenceIsBiggerThanOne(absDeltaWRatio, absDeltaHRatio);
                        var dprChanged = newDPR !== windowDpr && windowDpr > 0;
                        var isZoom = deltaIsBigger && difference && dprChanged;
                        var oldScrollbarSize = _base.nativeScrollbarSize;
                        var newScrollbarSize;

                        if (isZoom) {
                            bodyElement.append(scrollbarDummyElement);
                            newScrollbarSize = _base.nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement[0]);
                            scrollbarDummyElement.remove();

                            if (oldScrollbarSize.x !== newScrollbarSize.x || oldScrollbarSize.y !== newScrollbarSize.y) {
                                FRAMEWORK.each(INSTANCES(), function() {
                                    if (INSTANCES(this)) INSTANCES(this).update('zoom');
                                });
                            }
                        }

                        windowWidth = newW;
                        windowHeight = newH;
                        windowDpr = newDPR;
                    }
                };

                function differenceIsBiggerThanOne(valOne, valTwo) {
                    var absValOne = abs(valOne);
                    var absValTwo = abs(valTwo);
                    return !(absValOne === absValTwo || absValOne + 1 === absValTwo || absValOne - 1 === absValTwo);
                }

                function getWindowDPR() {
                    var dDPI = window.screen.deviceXDPI || 0;
                    var sDPI = window.screen.logicalXDPI || 1;
                    return window.devicePixelRatio || dDPI / sDPI;
                }

                FRAMEWORK(window).on('resize', onResize);
            })();

            function calcNativeScrollbarSize(measureElement) {
                return {
                    x: measureElement[LEXICON.oH] - measureElement[LEXICON.cH],
                    y: measureElement[LEXICON.oW] - measureElement[LEXICON.cW]
                };
            }
        }
        /**
         * The object which manages the auto update loop for all OverlayScrollbars objects. This object is initialized only once: if the first OverlayScrollbars object gets initialized.
         * @constructor
         */

        function OverlayScrollbarsAutoUpdateLoop(globals) {
            var _base = this;

            var _inArray = FRAMEWORK.inArray;
            var _getNow = COMPATIBILITY.now;
            var _strAutoUpdate = 'autoUpdate';

            var _strAutoUpdateInterval = _strAutoUpdate + 'Interval';

            var _strLength = LEXICON.l;
            var _loopingInstances = [];
            var _loopingInstancesIntervalCache = [];
            var _loopIsActive = false;
            var _loopIntervalDefault = 33;
            var _loopInterval = _loopIntervalDefault;

            var _loopTimeOld = _getNow();

            var _loopID;
            /**
             * The auto update loop which will run every 50 milliseconds or less if the update interval of a instance is lower than 50 milliseconds.
             */

            var loop = function loop() {
                if (_loopingInstances[_strLength] > 0 && _loopIsActive) {
                    _loopID = COMPATIBILITY.rAF()(function() {
                        loop();
                    });

                    var timeNew = _getNow();

                    var timeDelta = timeNew - _loopTimeOld;
                    var lowestInterval;
                    var instance;
                    var instanceOptions;
                    var instanceAutoUpdateAllowed;
                    var instanceAutoUpdateInterval;
                    var now;

                    if (timeDelta > _loopInterval) {
                        _loopTimeOld = timeNew - (timeDelta % _loopInterval);
                        lowestInterval = _loopIntervalDefault;

                        for (var i = 0; i < _loopingInstances[_strLength]; i++) {
                            instance = _loopingInstances[i];

                            if (instance !== undefined) {
                                instanceOptions = instance.options();
                                instanceAutoUpdateAllowed = instanceOptions[_strAutoUpdate];
                                instanceAutoUpdateInterval = MATH.max(1, instanceOptions[_strAutoUpdateInterval]);
                                now = _getNow();

                                if (
                                    (instanceAutoUpdateAllowed === true || instanceAutoUpdateAllowed === null) &&
                                    now - _loopingInstancesIntervalCache[i] > instanceAutoUpdateInterval
                                ) {
                                    instance.update('auto');
                                    _loopingInstancesIntervalCache[i] = new Date((now += instanceAutoUpdateInterval));
                                }

                                lowestInterval = MATH.max(1, MATH.min(lowestInterval, instanceAutoUpdateInterval));
                            }
                        }

                        _loopInterval = lowestInterval;
                    }
                } else {
                    _loopInterval = _loopIntervalDefault;
                }
            };
            /**
             * Add OverlayScrollbars instance to the auto update loop. Only successful if the instance isn't already added.
             * @param instance The instance which shall be updated in a loop automatically.
             */

            _base.add = function(instance) {
                if (_inArray(instance, _loopingInstances) === -1) {
                    _loopingInstances.push(instance);

                    _loopingInstancesIntervalCache.push(_getNow());

                    if (_loopingInstances[_strLength] > 0 && !_loopIsActive) {
                        _loopIsActive = true;
                        globals.autoUpdateLoop = _loopIsActive;
                        loop();
                    }
                }
            };
            /**
             * Remove OverlayScrollbars instance from the auto update loop. Only successful if the instance was added before.
             * @param instance The instance which shall be updated in a loop automatically.
             */

            _base.remove = function(instance) {
                var index = _inArray(instance, _loopingInstances);

                if (index > -1) {
                    //remove from loopingInstances list
                    _loopingInstancesIntervalCache.splice(index, 1);

                    _loopingInstances.splice(index, 1); //correct update loop behavior

                    if (_loopingInstances[_strLength] === 0 && _loopIsActive) {
                        _loopIsActive = false;
                        globals.autoUpdateLoop = _loopIsActive;

                        if (_loopID !== undefined) {
                            COMPATIBILITY.cAF()(_loopID);
                            _loopID = -1;
                        }
                    }
                }
            };
        }
        /**
         * A object which manages the scrollbars visibility of the target element.
         * @param pluginTargetElement The element from which the scrollbars shall be hidden.
         * @param options The custom options.
         * @param extensions The custom extensions.
         * @param globals
         * @param autoUpdateLoop
         * @returns {*}
         * @constructor
         */

        function OverlayScrollbarsInstance(pluginTargetElement, options, extensions, globals, autoUpdateLoop) {
            //shortcuts
            var type = COMPATIBILITY.type;
            var inArray = FRAMEWORK.inArray;
            var each = FRAMEWORK.each; //make correct instanceof

            var _base = new _plugin();

            var _frameworkProto = FRAMEWORK[LEXICON.p]; //if passed element is no HTML element: skip and return

            if (!isHTMLElement(pluginTargetElement)) return; //if passed element is already initialized: set passed options if there are any and return its instance

            if (INSTANCES(pluginTargetElement)) {
                var inst = INSTANCES(pluginTargetElement);
                inst.options(options);
                return inst;
            } //globals:

            var _nativeScrollbarIsOverlaid;

            var _overlayScrollbarDummySize;

            var _rtlScrollBehavior;

            var _autoUpdateRecommended;

            var _msieVersion;

            var _nativeScrollbarStyling;

            var _cssCalc;

            var _nativeScrollbarSize;

            var _supportTransition;

            var _supportTransform;

            var _supportPassiveEvents;

            var _supportResizeObserver;

            var _supportMutationObserver;

            var _restrictedMeasuring; //general readonly:

            var _initialized;

            var _destroyed;

            var _isTextarea;

            var _isBody;

            var _documentMixed;

            var _domExists; //general:

            var _isBorderBox;

            var _sizeAutoObserverAdded;

            var _paddingX;

            var _paddingY;

            var _borderX;

            var _borderY;

            var _marginX;

            var _marginY;

            var _isRTL;

            var _sleeping;

            var _contentBorderSize = {};
            var _scrollHorizontalInfo = {};
            var _scrollVerticalInfo = {};
            var _viewportSize = {};
            var _nativeScrollbarMinSize = {}; //naming:

            var _strMinusHidden = '-hidden';
            var _strMarginMinus = 'margin-';
            var _strPaddingMinus = 'padding-';
            var _strBorderMinus = 'border-';
            var _strTop = 'top';
            var _strRight = 'right';
            var _strBottom = 'bottom';
            var _strLeft = 'left';
            var _strMinMinus = 'min-';
            var _strMaxMinus = 'max-';
            var _strWidth = 'width';
            var _strHeight = 'height';
            var _strFloat = 'float';
            var _strEmpty = '';
            var _strAuto = 'auto';
            var _strSync = 'sync';
            var _strScroll = 'scroll';
            var _strHundredPercent = '100%';
            var _strX = 'x';
            var _strY = 'y';
            var _strDot = '.';
            var _strSpace = ' ';
            var _strScrollbar = 'scrollbar';
            var _strMinusHorizontal = '-horizontal';
            var _strMinusVertical = '-vertical';

            var _strScrollLeft = _strScroll + 'Left';

            var _strScrollTop = _strScroll + 'Top';

            var _strMouseTouchDownEvent = 'mousedown touchstart';
            var _strMouseTouchUpEvent = 'mouseup touchend touchcancel';
            var _strMouseTouchMoveEvent = 'mousemove touchmove';
            var _strMouseTouchEnter = 'mouseenter';
            var _strMouseTouchLeave = 'mouseleave';
            var _strKeyDownEvent = 'keydown';
            var _strKeyUpEvent = 'keyup';
            var _strSelectStartEvent = 'selectstart';
            var _strTransitionEndEvent = 'transitionend webkitTransitionEnd oTransitionEnd';
            var _strResizeObserverProperty = '__overlayScrollbarsRO__'; //class names:

            var _cassNamesPrefix = 'os-';

            var _classNameHTMLElement = _cassNamesPrefix + 'html';

            var _classNameHostElement = _cassNamesPrefix + 'host';

            var _classNameHostTextareaElement = _classNameHostElement + '-textarea';

            var _classNameHostScrollbarHorizontalHidden = _classNameHostElement + '-' + _strScrollbar + _strMinusHorizontal + _strMinusHidden;

            var _classNameHostScrollbarVerticalHidden = _classNameHostElement + '-' + _strScrollbar + _strMinusVertical + _strMinusHidden;

            var _classNameHostTransition = _classNameHostElement + '-transition';

            var _classNameHostRTL = _classNameHostElement + '-rtl';

            var _classNameHostResizeDisabled = _classNameHostElement + '-resize-disabled';

            var _classNameHostScrolling = _classNameHostElement + '-scrolling';

            var _classNameHostOverflow = _classNameHostElement + '-overflow';

            var _classNameHostOverflowX = _classNameHostOverflow + '-x';

            var _classNameHostOverflowY = _classNameHostOverflow + '-y';

            var _classNameTextareaElement = _cassNamesPrefix + 'textarea';

            var _classNameTextareaCoverElement = _classNameTextareaElement + '-cover';

            var _classNamePaddingElement = _cassNamesPrefix + 'padding';

            var _classNameViewportElement = _cassNamesPrefix + 'viewport';

            var _classNameViewportNativeScrollbarsInvisible = _classNameViewportElement + '-native-scrollbars-invisible';

            var _classNameViewportNativeScrollbarsOverlaid = _classNameViewportElement + '-native-scrollbars-overlaid';

            var _classNameContentElement = _cassNamesPrefix + 'content';

            var _classNameContentArrangeElement = _cassNamesPrefix + 'content-arrange';

            var _classNameContentGlueElement = _cassNamesPrefix + 'content-glue';

            var _classNameSizeAutoObserverElement = _cassNamesPrefix + 'size-auto-observer';

            var _classNameResizeObserverElement = _cassNamesPrefix + 'resize-observer';

            var _classNameResizeObserverItemElement = _cassNamesPrefix + 'resize-observer-item';

            var _classNameResizeObserverItemFinalElement = _classNameResizeObserverItemElement + '-final';

            var _classNameTextInherit = _cassNamesPrefix + 'text-inherit';

            var _classNameScrollbar = _cassNamesPrefix + _strScrollbar;

            var _classNameScrollbarTrack = _classNameScrollbar + '-track';

            var _classNameScrollbarTrackOff = _classNameScrollbarTrack + '-off';

            var _classNameScrollbarHandle = _classNameScrollbar + '-handle';

            var _classNameScrollbarHandleOff = _classNameScrollbarHandle + '-off';

            var _classNameScrollbarUnusable = _classNameScrollbar + '-unusable';

            var _classNameScrollbarAutoHidden = _classNameScrollbar + '-' + _strAuto + _strMinusHidden;

            var _classNameScrollbarCorner = _classNameScrollbar + '-corner';

            var _classNameScrollbarCornerResize = _classNameScrollbarCorner + '-resize';

            var _classNameScrollbarCornerResizeB = _classNameScrollbarCornerResize + '-both';

            var _classNameScrollbarCornerResizeH = _classNameScrollbarCornerResize + _strMinusHorizontal;

            var _classNameScrollbarCornerResizeV = _classNameScrollbarCornerResize + _strMinusVertical;

            var _classNameScrollbarHorizontal = _classNameScrollbar + _strMinusHorizontal;

            var _classNameScrollbarVertical = _classNameScrollbar + _strMinusVertical;

            var _classNameDragging = _cassNamesPrefix + 'dragging';

            var _classNameThemeNone = _cassNamesPrefix + 'theme-none';

            var _classNamesDynamicDestroy = [
                _classNameViewportNativeScrollbarsInvisible,
                _classNameViewportNativeScrollbarsOverlaid,
                _classNameScrollbarTrackOff,
                _classNameScrollbarHandleOff,
                _classNameScrollbarUnusable,
                _classNameScrollbarAutoHidden,
                _classNameScrollbarCornerResize,
                _classNameScrollbarCornerResizeB,
                _classNameScrollbarCornerResizeH,
                _classNameScrollbarCornerResizeV,
                _classNameDragging
            ].join(_strSpace); //callbacks:

            var _callbacksInitQeueue = []; //options:

            var _defaultOptions;

            var _currentOptions;

            var _currentPreparedOptions; //extensions:

            var _extensions = {};
            var _extensionsPrivateMethods = 'added removed on contract'; //update

            var _lastUpdateTime;

            var _swallowedUpdateHints = {};

            var _swallowedUpdateTimeout;

            var _swallowUpdateLag = 42;
            var _imgs = []; //DOM elements:

            var _windowElement;

            var _documentElement;

            var _htmlElement;

            var _bodyElement;

            var _targetElement; //the target element of this OverlayScrollbars object

            var _hostElement; //the host element of this OverlayScrollbars object -> may be the same as targetElement

            var _sizeAutoObserverElement; //observes size auto changes

            var _sizeObserverElement; //observes size and padding changes

            var _paddingElement; //manages the padding

            var _viewportElement; //is the viewport of our scrollbar model

            var _contentElement; //the element which holds the content

            var _contentArrangeElement; //is needed for correct sizing of the content element (only if native scrollbars are overlays)

            var _contentGlueElement; //has always the size of the content element

            var _textareaCoverElement; //only applied if target is a textarea element. Used for correct size calculation and for prevention of uncontrolled scrolling

            var _scrollbarCornerElement;

            var _scrollbarHorizontalElement;

            var _scrollbarHorizontalTrackElement;

            var _scrollbarHorizontalHandleElement;

            var _scrollbarVerticalElement;

            var _scrollbarVerticalTrackElement;

            var _scrollbarVerticalHandleElement;

            var _windowElementNative;

            var _documentElementNative;

            var _targetElementNative;

            var _hostElementNative;

            var _sizeAutoObserverElementNative;

            var _sizeObserverElementNative;

            var _paddingElementNative;

            var _viewportElementNative;

            var _contentElementNative; //Cache:

            var _hostSizeCache;

            var _contentScrollSizeCache;

            var _arrangeContentSizeCache;

            var _hasOverflowCache;

            var _hideOverflowCache;

            var _widthAutoCache;

            var _heightAutoCache;

            var _cssMaxValueCache;

            var _cssBoxSizingCache;

            var _cssPaddingCache;

            var _cssBorderCache;

            var _cssMarginCache;

            var _cssDirectionCache;

            var _cssDirectionDetectedCache;

            var _paddingAbsoluteCache;

            var _clipAlwaysCache;

            var _contentGlueSizeCache;

            var _overflowBehaviorCache;

            var _overflowAmountCache;

            var _ignoreOverlayScrollbarHidingCache;

            var _autoUpdateCache;

            var _sizeAutoCapableCache;

            var _contentElementScrollSizeChangeDetectedCache;

            var _hostElementSizeChangeDetectedCache;

            var _scrollbarsVisibilityCache;

            var _scrollbarsAutoHideCache;

            var _scrollbarsClickScrollingCache;

            var _scrollbarsDragScrollingCache;

            var _resizeCache;

            var _normalizeRTLCache;

            var _classNameCache;

            var _oldClassName;

            var _textareaAutoWrappingCache;

            var _textareaInfoCache;

            var _textareaSizeCache;

            var _textareaDynHeightCache;

            var _textareaDynWidthCache;

            var _bodyMinSizeCache;

            var _viewportScrollSizeCache;

            var _displayIsHiddenCache;

            var _updateAutoCache = {}; //MutationObserver:

            var _mutationObserverHost;

            var _mutationObserverContent;

            var _mutationObserverHostCallback;

            var _mutationObserverContentCallback;

            var _mutationObserversConnected;

            var _mutationObserverAttrsTextarea = ['wrap', 'cols', 'rows'];
            var _mutationObserverAttrsHost = [LEXICON.i, LEXICON.c, LEXICON.s, 'open']; //events:

            var _destroyEvents = []; //textarea:

            var _textareaHasFocus; //scrollbars:

            var _scrollbarsAutoHideTimeoutId;

            var _scrollbarsAutoHideMoveTimeoutId;

            var _scrollbarsAutoHideDelay;

            var _scrollbarsAutoHideNever;

            var _scrollbarsAutoHideScroll;

            var _scrollbarsAutoHideMove;

            var _scrollbarsAutoHideLeave;

            var _scrollbarsHandleHovered;

            var _scrollbarsHandlesDefineScrollPos; //resize

            var _resizeNone;

            var _resizeBoth;

            var _resizeHorizontal;

            var _resizeVertical; //==== Event Listener ====//

            /**
             * Adds or removes a event listener from the given element.
             * @param element The element to which the event listener shall be applied or removed.
             * @param eventNames The name(s) of the events.
             * @param listener The method which shall be called.
             * @param remove True if the handler shall be removed, false or undefined if the handler shall be added.
             */

            function setupResponsiveEventListener(element, eventNames, listener, remove, passive) {
                var collected = type(eventNames) == TYPES.a && type(listener) == TYPES.a;
                var method = remove ? 'removeEventListener' : 'addEventListener';
                var onOff = remove ? 'off' : 'on';
                var events = collected ? false : eventNames.split(_strSpace);
                var i = 0;

                if (collected) {
                    for (; i < eventNames[LEXICON.l]; i++) {
                        setupResponsiveEventListener(element, eventNames[i], listener[i], remove);
                    }
                } else {
                    for (; i < events[LEXICON.l]; i++) {
                        if (_supportPassiveEvents)
                            element[0][method](events[i], listener, {
                                passive: passive || false
                            });
                        else element[onOff](events[i], listener);
                    }
                }
            }

            function addDestroyEventListener(element, eventNames, listener, passive) {
                setupResponsiveEventListener(element, eventNames, listener, false, passive);

                _destroyEvents.push(COMPATIBILITY.bind(setupResponsiveEventListener, 0, element, eventNames, listener, true, passive));
            } //==== Resize Observer ====//

            /**
             * Adds or removes a resize observer from the given element.
             * @param targetElement The element to which the resize observer shall be added or removed.
             * @param onElementResizedCallback The callback which is fired every time the resize observer registers a size change or false / undefined if the resizeObserver shall be removed.
             */

            function setupResizeObserver(targetElement, onElementResizedCallback) {
                if (targetElement) {
                    var resizeObserver = COMPATIBILITY.rO();
                    var strAnimationStartEvent = 'animationstart mozAnimationStart webkitAnimationStart MSAnimationStart';
                    var strChildNodes = 'childNodes';
                    var constScroll = 3333333;

                    var callback = function callback() {
                        targetElement[_strScrollTop](constScroll)[_strScrollLeft](
                            _isRTL ? (_rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll) : constScroll
                        );

                        onElementResizedCallback();
                    }; //add resize observer:

                    if (onElementResizedCallback) {
                        if (_supportResizeObserver) {
                            var element = targetElement.append(generateDiv(_classNameResizeObserverElement + ' observed')).contents()[0];
                            var observer = (element[_strResizeObserverProperty] = new resizeObserver(callback));
                            observer.observe(element);
                        } else {
                            if (_msieVersion > 9 || !_autoUpdateRecommended) {
                                targetElement.prepend(
                                    generateDiv(
                                        _classNameResizeObserverElement,
                                        generateDiv(
                                            {
                                                c: _classNameResizeObserverItemElement,
                                                dir: 'ltr'
                                            },
                                            generateDiv(_classNameResizeObserverItemElement, generateDiv(_classNameResizeObserverItemFinalElement)) +
                                                generateDiv(
                                                    _classNameResizeObserverItemElement,
                                                    generateDiv({
                                                        c: _classNameResizeObserverItemFinalElement,
                                                        style: 'width: 200%; height: 200%'
                                                    })
                                                )
                                        )
                                    )
                                );
                                var observerElement = targetElement[0][strChildNodes][0][strChildNodes][0];
                                var shrinkElement = FRAMEWORK(observerElement[strChildNodes][1]);
                                var expandElement = FRAMEWORK(observerElement[strChildNodes][0]);
                                var expandElementChild = FRAMEWORK(expandElement[0][strChildNodes][0]);
                                var widthCache = observerElement[LEXICON.oW];
                                var heightCache = observerElement[LEXICON.oH];
                                var isDirty;
                                var rAFId;
                                var currWidth;
                                var currHeight;
                                var factor = 2;
                                var nativeScrollbarSize = globals.nativeScrollbarSize; //care don't make changes to this object!!!

                                var reset = function reset() {
                                    /*
                   var sizeResetWidth = observerElement[LEXICON.oW] + nativeScrollbarSize.x * factor + nativeScrollbarSize.y * factor + _overlayScrollbarDummySize.x + _overlayScrollbarDummySize.y;
                   var sizeResetHeight = observerElement[LEXICON.oH] + nativeScrollbarSize.x * factor + nativeScrollbarSize.y * factor + _overlayScrollbarDummySize.x + _overlayScrollbarDummySize.y;
                   var expandChildCSS = {};
                   expandChildCSS[_strWidth] = sizeResetWidth;
                   expandChildCSS[_strHeight] = sizeResetHeight;
                   expandElementChild.css(expandChildCSS);
                     expandElement[_strScrollLeft](sizeResetWidth)[_strScrollTop](sizeResetHeight);
                   shrinkElement[_strScrollLeft](sizeResetWidth)[_strScrollTop](sizeResetHeight);
                   */
                                    expandElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);

                                    shrinkElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);
                                };

                                var onResized = function onResized() {
                                    rAFId = 0;
                                    if (!isDirty) return;
                                    widthCache = currWidth;
                                    heightCache = currHeight;
                                    callback();
                                };

                                var onScroll = function onScroll(event) {
                                    currWidth = observerElement[LEXICON.oW];
                                    currHeight = observerElement[LEXICON.oH];
                                    isDirty = currWidth != widthCache || currHeight != heightCache;

                                    if (event && isDirty && !rAFId) {
                                        COMPATIBILITY.cAF()(rAFId);
                                        rAFId = COMPATIBILITY.rAF()(onResized);
                                    } else if (!event) onResized();

                                    reset();

                                    if (event) {
                                        COMPATIBILITY.prvD(event);
                                        COMPATIBILITY.stpP(event);
                                    }

                                    return false;
                                };

                                var expandChildCSS = {};
                                var observerElementCSS = {};
                                setTopRightBottomLeft(observerElementCSS, _strEmpty, [
                                    -((nativeScrollbarSize.y + 1) * factor),
                                    nativeScrollbarSize.x * -factor,
                                    nativeScrollbarSize.y * -factor,
                                    -((nativeScrollbarSize.x + 1) * factor)
                                ]);
                                FRAMEWORK(observerElement).css(observerElementCSS);
                                expandElement.on(_strScroll, onScroll);
                                shrinkElement.on(_strScroll, onScroll);
                                targetElement.on(strAnimationStartEvent, function() {
                                    onScroll(false);
                                }); //lets assume that the divs will never be that large and a constant value is enough

                                expandChildCSS[_strWidth] = constScroll;
                                expandChildCSS[_strHeight] = constScroll;
                                expandElementChild.css(expandChildCSS);
                                reset();
                            } else {
                                var attachEvent = _documentElementNative.attachEvent;
                                var isIE = _msieVersion !== undefined;

                                if (attachEvent) {
                                    targetElement.prepend(generateDiv(_classNameResizeObserverElement));
                                    findFirst(targetElement, _strDot + _classNameResizeObserverElement)[0].attachEvent('onresize', callback);
                                } else {
                                    var obj = _documentElementNative.createElement(TYPES.o);

                                    obj.setAttribute('tabindex', '-1');
                                    obj.setAttribute(LEXICON.c, _classNameResizeObserverElement);

                                    obj.onload = function() {
                                        var wnd = this.contentDocument.defaultView;
                                        wnd.addEventListener('resize', callback);
                                        wnd.document.documentElement.style.display = 'none';
                                    };

                                    obj.type = 'text/html';
                                    if (isIE) targetElement.prepend(obj);
                                    obj.data = 'about:blank';
                                    if (!isIE) targetElement.prepend(obj);
                                    targetElement.on(strAnimationStartEvent, callback);
                                }
                            }
                        }

                        if (targetElement[0] === _sizeObserverElementNative) {
                            var directionChanged = function directionChanged() {
                                var dir = _hostElement.css('direction');

                                var css = {};
                                var scrollLeftValue = 0;
                                var result = false;

                                if (dir !== _cssDirectionDetectedCache) {
                                    if (dir === 'ltr') {
                                        css[_strLeft] = 0;
                                        css[_strRight] = _strAuto;
                                        scrollLeftValue = constScroll;
                                    } else {
                                        css[_strLeft] = _strAuto;
                                        css[_strRight] = 0;
                                        scrollLeftValue = _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll;
                                    } //execution order is important for IE!!!

                                    _sizeObserverElement
                                        .children()
                                        .eq(0)
                                        .css(css);

                                    _sizeObserverElement[_strScrollLeft](scrollLeftValue)[_strScrollTop](constScroll);

                                    _cssDirectionDetectedCache = dir;
                                    result = true;
                                }

                                return result;
                            };

                            directionChanged();
                            addDestroyEventListener(targetElement, _strScroll, function(event) {
                                if (directionChanged()) update();
                                COMPATIBILITY.prvD(event);
                                COMPATIBILITY.stpP(event);
                                return false;
                            });
                        }
                    } //remove resize observer:
                    else {
                        if (_supportResizeObserver) {
                            var element = targetElement.contents()[0];
                            var resizeObserverObj = element[_strResizeObserverProperty];

                            if (resizeObserverObj) {
                                resizeObserverObj.disconnect();
                                delete element[_strResizeObserverProperty];
                            }
                        } else {
                            remove(targetElement.children(_strDot + _classNameResizeObserverElement).eq(0));
                        }
                    }
                }
            }
            /**
       * Freezes or unfreezes the given resize observer.
       * @param targetElement The element to which the target resize observer is applied.
       * @param freeze True if the resize observer shall be frozen, false otherwise.
       
      function freezeResizeObserver(targetElement, freeze) {
          if (targetElement !== undefined) {
              if(freeze) {
                  if (_supportResizeObserver) {
                      var element = targetElement.contents()[0];
                      element[_strResizeObserverProperty].unobserve(element);
                  }
                  else {
                      targetElement = targetElement.children(_strDot + _classNameResizeObserverElement).eq(0);
                      var w = targetElement.css(_strWidth);
                      var h = targetElement.css(_strHeight);
                      var css = {};
                      css[_strWidth] = w;
                      css[_strHeight] = h;
                      targetElement.css(css);
                  }
              }
              else {
                  if (_supportResizeObserver) {
                      var element = targetElement.contents()[0];
                      element[_strResizeObserverProperty].observe(element);
                  }
                  else {
                      var css = { };
                      css[_strHeight] = _strEmpty;
                      css[_strWidth] = _strEmpty;
                      targetElement.children(_strDot + _classNameResizeObserverElement).eq(0).css(css);
                  }
              }
          }
      }
      */
            //==== Mutation Observers ====//

            /**
             * Creates MutationObservers for the host and content Element if they are supported.
             */

            function createMutationObservers() {
                if (_supportMutationObserver) {
                    var mutationObserverContentLag = 11;
                    var mutationObserver = COMPATIBILITY.mO();
                    var contentLastUpdate = COMPATIBILITY.now();
                    var mutationTarget;
                    var mutationAttrName;
                    var contentTimeout;
                    var now;
                    var sizeAuto;
                    var action;

                    _mutationObserverHostCallback = function _mutationObserverHostCallback(mutations) {
                        var doUpdate = false;
                        var mutation;

                        if (_initialized && !_sleeping) {
                            each(mutations, function() {
                                mutation = this;
                                mutationTarget = mutation.target;
                                mutationAttrName = mutation.attributeName;
                                if (mutationAttrName === LEXICON.c) doUpdate = hostClassNamesChanged(mutation.oldValue, mutationTarget.className);
                                else if (mutationAttrName === LEXICON.s) doUpdate = mutation.oldValue !== mutationTarget[LEXICON.s].cssText;
                                else doUpdate = true;
                                if (doUpdate) return false;
                            });
                            if (doUpdate) _base.update(_strAuto);
                        }

                        return doUpdate;
                    };

                    _mutationObserverContentCallback = function _mutationObserverContentCallback(mutations) {
                        var doUpdate = false;
                        var mutation;

                        if (_initialized && !_sleeping) {
                            each(mutations, function() {
                                mutation = this;
                                doUpdate = isUnknownMutation(mutation);
                                return !doUpdate;
                            });

                            if (doUpdate) {
                                now = COMPATIBILITY.now();
                                sizeAuto = _heightAutoCache || _widthAutoCache;

                                action = function action() {
                                    if (!_destroyed) {
                                        contentLastUpdate = now; //if cols, rows or wrap attr was changed

                                        if (_isTextarea) textareaUpdate();
                                        if (sizeAuto) update();
                                        else _base.update(_strAuto);
                                    }
                                };

                                clearTimeout(contentTimeout);
                                if (mutationObserverContentLag <= 0 || now - contentLastUpdate > mutationObserverContentLag || !sizeAuto) action();
                                else contentTimeout = setTimeout(action, mutationObserverContentLag);
                            }
                        }

                        return doUpdate;
                    };

                    _mutationObserverHost = new mutationObserver(_mutationObserverHostCallback);
                    _mutationObserverContent = new mutationObserver(_mutationObserverContentCallback);
                }
            }
            /**
             * Connects the MutationObservers if they are supported.
             */

            function connectMutationObservers() {
                if (_supportMutationObserver && !_mutationObserversConnected) {
                    _mutationObserverHost.observe(_hostElementNative, {
                        attributes: true,
                        attributeOldValue: true,
                        attributeFilter: _mutationObserverAttrsHost
                    });

                    _mutationObserverContent.observe(_isTextarea ? _targetElementNative : _contentElementNative, {
                        attributes: true,
                        attributeOldValue: true,
                        subtree: !_isTextarea,
                        childList: !_isTextarea,
                        characterData: !_isTextarea,
                        attributeFilter: _isTextarea ? _mutationObserverAttrsTextarea : _mutationObserverAttrsHost
                    });

                    _mutationObserversConnected = true;
                }
            }
            /**
             * Disconnects the MutationObservers if they are supported.
             */

            function disconnectMutationObservers() {
                if (_supportMutationObserver && _mutationObserversConnected) {
                    _mutationObserverHost.disconnect();

                    _mutationObserverContent.disconnect();

                    _mutationObserversConnected = false;
                }
            } //==== Events of elements ====//

            /**
             * This method gets called every time the host element gets resized. IMPORTANT: Padding changes are detected too!!
             * It refreshes the hostResizedEventArgs and the hostSizeResizeCache.
             * If there are any size changes, the update method gets called.
             */

            function hostOnResized() {
                if (!_sleeping) {
                    var changed;
                    var hostSize = {
                        w: _sizeObserverElementNative[LEXICON.sW],
                        h: _sizeObserverElementNative[LEXICON.sH]
                    };
                    changed = checkCache(hostSize, _hostElementSizeChangeDetectedCache);
                    _hostElementSizeChangeDetectedCache = hostSize;
                    if (changed)
                        update({
                            _hostSizeChanged: true
                        });
                }
            }
            /**
             * The mouse enter event of the host element. This event is only needed for the autoHide feature.
             */

            function hostOnMouseEnter() {
                if (_scrollbarsAutoHideLeave) refreshScrollbarsAutoHide(true);
            }
            /**
             * The mouse leave event of the host element. This event is only needed for the autoHide feature.
             */

            function hostOnMouseLeave() {
                if (_scrollbarsAutoHideLeave && !_bodyElement.hasClass(_classNameDragging)) refreshScrollbarsAutoHide(false);
            }
            /**
             * The mouse move event of the host element. This event is only needed for the autoHide "move" feature.
             */

            function hostOnMouseMove() {
                if (_scrollbarsAutoHideMove) {
                    refreshScrollbarsAutoHide(true);
                    clearTimeout(_scrollbarsAutoHideMoveTimeoutId);
                    _scrollbarsAutoHideMoveTimeoutId = setTimeout(function() {
                        if (_scrollbarsAutoHideMove && !_destroyed) refreshScrollbarsAutoHide(false);
                    }, 100);
                }
            }
            /**
             * Prevents text from deselection if attached to the document element on the mousedown event of a DOM element.
             * @param event The select start event.
             */

            function documentOnSelectStart(event) {
                COMPATIBILITY.prvD(event);
                return false;
            }
            /**
             * A callback which will be called after a img element has downloaded its src asynchronous.
             */

            function imgOnLoad() {
                update({
                    _contentSizeChanged: true
                });
            }
            /**
             * Adds or removes mouse & touch events of the host element. (for handling auto-hiding of the scrollbars)
             * @param destroy Indicates whether the events shall be added or removed.
             */

            function setupHostMouseTouchEvents(destroy) {
                setupResponsiveEventListener(_hostElement, _strMouseTouchMoveEvent, hostOnMouseMove, _scrollbarsAutoHideMove ? destroy : true, true);
                setupResponsiveEventListener(
                    _hostElement,
                    [_strMouseTouchEnter, _strMouseTouchLeave],
                    [hostOnMouseEnter, hostOnMouseLeave],
                    _scrollbarsAutoHideMove ? true : destroy,
                    true
                ); //if the plugin is initialized and the mouse is over the host element, make the scrollbars visible

                if (!_initialized && !destroy) _hostElement.one('mouseover', hostOnMouseEnter);
            } //==== Update Detection ====//

            /**
             * Measures the min width and min height of the body element and refreshes the related cache.
             * @returns {boolean} True if the min width or min height has changed, false otherwise.
             */

            function bodyMinSizeChanged() {
                var bodyMinSize = {};

                if (_isBody && _contentArrangeElement) {
                    bodyMinSize.w = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strWidth));
                    bodyMinSize.h = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strHeight));
                    bodyMinSize.c = checkCache(bodyMinSize, _bodyMinSizeCache);
                    bodyMinSize.f = true; //flag for "measured at least once"
                }

                _bodyMinSizeCache = bodyMinSize;
                return !!bodyMinSize.c;
            }
            /**
             * Returns true if the class names really changed (new class without plugin host prefix)
             * @param oldCassNames The old ClassName string.
             * @param newClassNames The new ClassName string.
             * @returns {boolean} True if the class names has really changed, false otherwise.
             */

            function hostClassNamesChanged(oldCassNames, newClassNames) {
                var currClasses = newClassNames !== undefined && newClassNames !== null ? newClassNames.split(_strSpace) : _strEmpty;
                var oldClasses = oldCassNames !== undefined && oldCassNames !== null ? oldCassNames.split(_strSpace) : _strEmpty;
                if (currClasses === _strEmpty && oldClasses === _strEmpty) return false;
                var diff = getArrayDifferences(oldClasses, currClasses);
                var changed = false;
                var oldClassNames = _oldClassName !== undefined && _oldClassName !== null ? _oldClassName.split(_strSpace) : [_strEmpty];
                var currClassNames = _classNameCache !== undefined && _classNameCache !== null ? _classNameCache.split(_strSpace) : [_strEmpty]; //remove none theme from diff list to prevent update

                var idx = inArray(_classNameThemeNone, diff);
                var curr;
                var i;
                var v;
                var o;
                var c;
                if (idx > -1) diff.splice(idx, 1);

                for (i = 0; i < diff.length; i++) {
                    curr = diff[i];

                    if (curr.indexOf(_classNameHostElement) !== 0) {
                        o = true;
                        c = true;

                        for (v = 0; v < oldClassNames.length; v++) {
                            if (curr === oldClassNames[v]) {
                                o = false;
                                break;
                            }
                        }

                        for (v = 0; v < currClassNames.length; v++) {
                            if (curr === currClassNames[v]) {
                                c = false;
                                break;
                            }
                        }

                        if (o && c) {
                            changed = true;
                            break;
                        }
                    }
                }

                return changed;
            }
            /**
             * Returns true if the given mutation is not from a from the plugin generated element. If the target element is a textarea the mutation is always unknown.
             * @param mutation The mutation which shall be checked.
             * @returns {boolean} True if the mutation is from a unknown element, false otherwise.
             */

            function isUnknownMutation(mutation) {
                var attributeName = mutation.attributeName;
                var mutationTarget = mutation.target;
                var mutationType = mutation.type;
                var strClosest = 'closest';
                if (mutationTarget === _contentElementNative) return attributeName === null;

                if (mutationType === 'attributes' && (attributeName === LEXICON.c || attributeName === LEXICON.s) && !_isTextarea) {
                    //ignore className changes by the plugin
                    if (attributeName === LEXICON.c && FRAMEWORK(mutationTarget).hasClass(_classNameHostElement))
                        return hostClassNamesChanged(mutation.oldValue, mutationTarget.getAttribute(LEXICON.c)); //only do it of browser support it natively

                    if (_typeof(mutationTarget[strClosest]) != TYPES.f) return true;
                    if (
                        mutationTarget[strClosest](_strDot + _classNameResizeObserverElement) !== null ||
                        mutationTarget[strClosest](_strDot + _classNameScrollbar) !== null ||
                        mutationTarget[strClosest](_strDot + _classNameScrollbarCorner) !== null
                    )
                        return false;
                }

                return true;
            }
            /**
             * Returns true if the content size was changed since the last time this method was called.
             * @returns {boolean} True if the content size was changed, false otherwise.
             */

            function updateAutoContentSizeChanged() {
                if (_sleeping) return false;
                var contentMeasureElement = getContentMeasureElement();
                var textareaValueLength = _isTextarea && _widthAutoCache && !_textareaAutoWrappingCache ? _targetElement.val().length : 0;
                var setCSS = !_mutationObserversConnected && _widthAutoCache && !_isTextarea;
                var viewportScrollSize = {};
                var css = {};

                var _float;

                var bodyMinSizeC;
                var changed;
                var viewportScrollSizeChanged;
                var contentElementScrollSize; //fix for https://bugzilla.mozilla.org/show_bug.cgi?id=1439305, it only works with "clipAlways : true"
                //it can work with "clipAlways : false" too, but I had to set the overflow of the viewportElement to hidden every time before measuring

                if (_restrictedMeasuring) {
                    viewportScrollSize = {
                        x: _viewportElementNative[LEXICON.sW],
                        y: _viewportElementNative[LEXICON.sH]
                    };
                }

                if (setCSS) {
                    _float = _contentElement.css(_strFloat);
                    css[_strFloat] = _isRTL ? _strRight : _strLeft;
                    css[_strWidth] = _strAuto;

                    _contentElement.css(css);
                }

                contentElementScrollSize = {
                    w: contentMeasureElement[LEXICON.sW] + textareaValueLength,
                    h: contentMeasureElement[LEXICON.sH] + textareaValueLength
                };

                if (setCSS) {
                    css[_strFloat] = _float;
                    css[_strWidth] = _strHundredPercent;

                    _contentElement.css(css);
                }

                bodyMinSizeC = bodyMinSizeChanged();
                changed = checkCache(contentElementScrollSize, _contentElementScrollSizeChangeDetectedCache);
                viewportScrollSizeChanged = checkCache(viewportScrollSize, _viewportScrollSizeCache);
                _contentElementScrollSizeChangeDetectedCache = contentElementScrollSize;
                _viewportScrollSizeCache = viewportScrollSize;
                return changed || bodyMinSizeC || viewportScrollSizeChanged;
            }
            /**
             * Returns true when a attribute which the MutationObserver would observe has changed.
             * @returns {boolean} True if one of the attributes which a MutationObserver would observe has changed, false or undefined otherwise.
             */

            function meaningfulAttrsChanged() {
                if (_sleeping || _mutationObserversConnected) return;
                var changed;
                var elem;
                var curr;
                var cache;
                var checks = [
                    {
                        _elem: _hostElement,
                        _props: _mutationObserverAttrsHost.concat(':visible')
                    },
                    {
                        _elem: _isTextarea ? _targetElement : undefined,
                        _props: _mutationObserverAttrsTextarea
                    }
                ];
                each(checks, function(index, check) {
                    elem = check._elem;

                    if (elem) {
                        each(check._props, function(index, prop) {
                            curr = prop.charAt(0) === ':' ? elem.is(prop) : elem.attr(prop);
                            cache = _updateAutoCache[prop];
                            changed = changed || checkCache(curr, cache);
                            _updateAutoCache[prop] = curr;
                        });
                    }
                });
                return changed;
            }
            /**
             * Checks is a CSS Property of a child element is affecting the scroll size of the content.
             * @param propertyName The CSS property name.
             * @returns {boolean} True if the property is affecting the content scroll size, false otherwise.
             */

            function isSizeAffectingCSSProperty(propertyName) {
                if (!_initialized) return true;
                var flexGrow = 'flex-grow';
                var flexShrink = 'flex-shrink';
                var flexBasis = 'flex-basis';
                var affectingPropsX = [
                    _strWidth,
                    _strMinMinus + _strWidth,
                    _strMaxMinus + _strWidth,
                    _strMarginMinus + _strLeft,
                    _strMarginMinus + _strRight,
                    _strLeft,
                    _strRight,
                    'font-weight',
                    'word-spacing',
                    flexGrow,
                    flexShrink,
                    flexBasis
                ];
                var affectingPropsXContentBox = [
                    _strPaddingMinus + _strLeft,
                    _strPaddingMinus + _strRight,
                    _strBorderMinus + _strLeft + _strWidth,
                    _strBorderMinus + _strRight + _strWidth
                ];
                var affectingPropsY = [
                    _strHeight,
                    _strMinMinus + _strHeight,
                    _strMaxMinus + _strHeight,
                    _strMarginMinus + _strTop,
                    _strMarginMinus + _strBottom,
                    _strTop,
                    _strBottom,
                    'line-height',
                    flexGrow,
                    flexShrink,
                    flexBasis
                ];
                var affectingPropsYContentBox = [
                    _strPaddingMinus + _strTop,
                    _strPaddingMinus + _strBottom,
                    _strBorderMinus + _strTop + _strWidth,
                    _strBorderMinus + _strBottom + _strWidth
                ];
                var _strS = 's';
                var _strVS = 'v-s';
                var checkX = _overflowBehaviorCache.x === _strS || _overflowBehaviorCache.x === _strVS;
                var checkY = _overflowBehaviorCache.y === _strS || _overflowBehaviorCache.y === _strVS;
                var sizeIsAffected = false;

                var checkPropertyName = function checkPropertyName(arr, name) {
                    for (var i = 0; i < arr[LEXICON.l]; i++) {
                        if (arr[i] === name) return true;
                    }

                    return false;
                };

                if (checkY) {
                    sizeIsAffected = checkPropertyName(affectingPropsY, propertyName);
                    if (!sizeIsAffected && !_isBorderBox) sizeIsAffected = checkPropertyName(affectingPropsYContentBox, propertyName);
                }

                if (checkX && !sizeIsAffected) {
                    sizeIsAffected = checkPropertyName(affectingPropsX, propertyName);
                    if (!sizeIsAffected && !_isBorderBox) sizeIsAffected = checkPropertyName(affectingPropsXContentBox, propertyName);
                }

                return sizeIsAffected;
            } //==== Update ====//

            /**
             * Updates the variables and size of the textarea element, and manages the scroll on new line or new character.
             */

            function textareaUpdate() {
                if (!_sleeping) {
                    var wrapAttrOff = !_textareaAutoWrappingCache;
                    var minWidth = _viewportSize.w;
                    var minHeight = _viewportSize.h;
                    var css = {};
                    var doMeasure = _widthAutoCache || wrapAttrOff;
                    var origWidth;
                    var width;
                    var origHeight;
                    var height; //reset min size

                    css[_strMinMinus + _strWidth] = _strEmpty;
                    css[_strMinMinus + _strHeight] = _strEmpty; //set width auto

                    css[_strWidth] = _strAuto;

                    _targetElement.css(css); //measure width

                    origWidth = _targetElementNative[LEXICON.oW];
                    width = doMeasure ? MATH.max(origWidth, _targetElementNative[LEXICON.sW] - 1) : 1;
                    /*width += (_widthAutoCache ? _marginX + (!_isBorderBox ? wrapAttrOff ? 0 : _paddingX + _borderX : 0) : 0);*/
                    //set measured width

                    css[_strWidth] = _widthAutoCache
                        ? _strAuto
                        : /*width*/
                          _strHundredPercent;
                    css[_strMinMinus + _strWidth] = _strHundredPercent; //set height auto

                    css[_strHeight] = _strAuto;

                    _targetElement.css(css); //measure height

                    origHeight = _targetElementNative[LEXICON.oH];
                    height = MATH.max(origHeight, _targetElementNative[LEXICON.sH] - 1); //append correct size values

                    css[_strWidth] = width;
                    css[_strHeight] = height;

                    _textareaCoverElement.css(css); //apply min width / min height to prevent textarea collapsing

                    css[_strMinMinus + _strWidth] = minWidth;
                    /*+ (!_isBorderBox && _widthAutoCache ? _paddingX + _borderX : 0)*/
                    css[_strMinMinus + _strHeight] = minHeight;
                    /*+ (!_isBorderBox && _heightAutoCache ? _paddingY + _borderY : 0)*/

                    _targetElement.css(css);

                    return {
                        _originalWidth: origWidth,
                        _originalHeight: origHeight,
                        _dynamicWidth: width,
                        _dynamicHeight: height
                    };
                }
            }
            /**
             * Updates the plugin and DOM to the current options.
             * This method should only be called if a update is 100% required.
             * @param updateHints A objects which contains hints for this update:
             * {
             *   _hostSizeChanged : boolean,
             *   _contentSizeChanged : boolean,
             *   _force : boolean,                             == preventSwallowing
             *   _changedOptions : { },                        == preventSwallowing && preventSleep
             *  }
             */

            function update(updateHints) {
                clearTimeout(_swallowedUpdateTimeout);
                updateHints = updateHints || {};
                _swallowedUpdateHints._hostSizeChanged |= updateHints._hostSizeChanged;
                _swallowedUpdateHints._contentSizeChanged |= updateHints._contentSizeChanged;
                _swallowedUpdateHints._force |= updateHints._force;
                var now = COMPATIBILITY.now();
                var hostSizeChanged = !!_swallowedUpdateHints._hostSizeChanged;
                var contentSizeChanged = !!_swallowedUpdateHints._contentSizeChanged;
                var force = !!_swallowedUpdateHints._force;
                var changedOptions = updateHints._changedOptions;
                var swallow =
                    _swallowUpdateLag > 0 &&
                    _initialized &&
                    !_destroyed &&
                    !force &&
                    !changedOptions &&
                    now - _lastUpdateTime < _swallowUpdateLag &&
                    !_heightAutoCache &&
                    !_widthAutoCache;
                var displayIsHidden;
                if (swallow) _swallowedUpdateTimeout = setTimeout(update, _swallowUpdateLag); //abort update due to:
                //destroyed
                //swallowing
                //sleeping
                //host is hidden or has false display

                if (
                    _destroyed ||
                    swallow ||
                    (_sleeping && !changedOptions) ||
                    (_initialized && !force && (displayIsHidden = _hostElement.is(':hidden'))) ||
                    _hostElement.css('display') === 'inline'
                )
                    return;
                _lastUpdateTime = now;
                _swallowedUpdateHints = {}; //if scrollbar styling is possible and native scrollbars aren't overlaid the scrollbar styling will be applied which hides the native scrollbars completely.

                if (_nativeScrollbarStyling && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {
                    //native scrollbars are hidden, so change the values to zero
                    _nativeScrollbarSize.x = 0;
                    _nativeScrollbarSize.y = 0;
                } else {
                    //refresh native scrollbar size (in case of zoom)
                    _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);
                } // Scrollbar padding is needed for firefox, because firefox hides scrollbar automatically if the size of the div is too small.
                // The calculation: [scrollbar size +3 *3]
                // (+3 because of possible decoration e.g. borders, margins etc., but only if native scrollbar is NOT a overlaid scrollbar)
                // (*3 because (1)increase / (2)decrease -button and (3)resize handle)

                _nativeScrollbarMinSize = {
                    x: (_nativeScrollbarSize.x + (_nativeScrollbarIsOverlaid.x ? 0 : 3)) * 3,
                    y: (_nativeScrollbarSize.y + (_nativeScrollbarIsOverlaid.y ? 0 : 3)) * 3
                }; //changedOptions = changedOptions || { };
                //freezeResizeObserver(_sizeObserverElement, true);
                //freezeResizeObserver(_sizeAutoObserverElement, true);

                var checkCacheAutoForce = function checkCacheAutoForce() {
                    return checkCache.apply(this, [].slice.call(arguments).concat([force]));
                }; //save current scroll offset

                var currScroll = {
                    x: _viewportElement[_strScrollLeft](),
                    y: _viewportElement[_strScrollTop]()
                };
                var currentPreparedOptionsScrollbars = _currentPreparedOptions.scrollbars;
                var currentPreparedOptionsTextarea = _currentPreparedOptions.textarea; //scrollbars visibility:

                var scrollbarsVisibility = currentPreparedOptionsScrollbars.visibility;
                var scrollbarsVisibilityChanged = checkCacheAutoForce(scrollbarsVisibility, _scrollbarsVisibilityCache); //scrollbars autoHide:

                var scrollbarsAutoHide = currentPreparedOptionsScrollbars.autoHide;
                var scrollbarsAutoHideChanged = checkCacheAutoForce(scrollbarsAutoHide, _scrollbarsAutoHideCache); //scrollbars click scrolling

                var scrollbarsClickScrolling = currentPreparedOptionsScrollbars.clickScrolling;
                var scrollbarsClickScrollingChanged = checkCacheAutoForce(scrollbarsClickScrolling, _scrollbarsClickScrollingCache); //scrollbars drag scrolling

                var scrollbarsDragScrolling = currentPreparedOptionsScrollbars.dragScrolling;
                var scrollbarsDragScrollingChanged = checkCacheAutoForce(scrollbarsDragScrolling, _scrollbarsDragScrollingCache); //className

                var className = _currentPreparedOptions.className;
                var classNameChanged = checkCacheAutoForce(className, _classNameCache); //resize

                var resize = _currentPreparedOptions.resize;
                var resizeChanged = checkCacheAutoForce(resize, _resizeCache) && !_isBody; //body can't be resized since the window itself acts as resize possibility.
                //paddingAbsolute

                var paddingAbsolute = _currentPreparedOptions.paddingAbsolute;
                var paddingAbsoluteChanged = checkCacheAutoForce(paddingAbsolute, _paddingAbsoluteCache); //clipAlways

                var clipAlways = _currentPreparedOptions.clipAlways;
                var clipAlwaysChanged = checkCacheAutoForce(clipAlways, _clipAlwaysCache); //sizeAutoCapable

                var sizeAutoCapable = _currentPreparedOptions.sizeAutoCapable && !_isBody; //body can never be size auto, because it shall be always as big as the viewport.

                var sizeAutoCapableChanged = checkCacheAutoForce(sizeAutoCapable, _sizeAutoCapableCache); //showNativeScrollbars

                var ignoreOverlayScrollbarHiding = _currentPreparedOptions.nativeScrollbarsOverlaid.showNativeScrollbars;
                var ignoreOverlayScrollbarHidingChanged = checkCacheAutoForce(ignoreOverlayScrollbarHiding, _ignoreOverlayScrollbarHidingCache); //autoUpdate

                var autoUpdate = _currentPreparedOptions.autoUpdate;
                var autoUpdateChanged = checkCacheAutoForce(autoUpdate, _autoUpdateCache); //overflowBehavior

                var overflowBehavior = _currentPreparedOptions.overflowBehavior;
                var overflowBehaviorChanged = checkCacheAutoForce(overflowBehavior, _overflowBehaviorCache, force); //dynWidth:

                var textareaDynWidth = currentPreparedOptionsTextarea.dynWidth;
                var textareaDynWidthChanged = checkCacheAutoForce(_textareaDynWidthCache, textareaDynWidth); //dynHeight:

                var textareaDynHeight = currentPreparedOptionsTextarea.dynHeight;
                var textareaDynHeightChanged = checkCacheAutoForce(_textareaDynHeightCache, textareaDynHeight); //scrollbars visibility

                _scrollbarsAutoHideNever = scrollbarsAutoHide === 'n';
                _scrollbarsAutoHideScroll = scrollbarsAutoHide === 's';
                _scrollbarsAutoHideMove = scrollbarsAutoHide === 'm';
                _scrollbarsAutoHideLeave = scrollbarsAutoHide === 'l'; //scrollbars autoHideDelay

                _scrollbarsAutoHideDelay = currentPreparedOptionsScrollbars.autoHideDelay; //old className

                _oldClassName = _classNameCache; //resize

                _resizeNone = resize === 'n';
                _resizeBoth = resize === 'b';
                _resizeHorizontal = resize === 'h';
                _resizeVertical = resize === 'v'; //normalizeRTL

                _normalizeRTLCache = _currentPreparedOptions.normalizeRTL; //ignore overlay scrollbar hiding

                ignoreOverlayScrollbarHiding = ignoreOverlayScrollbarHiding && _nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y; //refresh options cache

                _scrollbarsVisibilityCache = scrollbarsVisibility;
                _scrollbarsAutoHideCache = scrollbarsAutoHide;
                _scrollbarsClickScrollingCache = scrollbarsClickScrolling;
                _scrollbarsDragScrollingCache = scrollbarsDragScrolling;
                _classNameCache = className;
                _resizeCache = resize;
                _paddingAbsoluteCache = paddingAbsolute;
                _clipAlwaysCache = clipAlways;
                _sizeAutoCapableCache = sizeAutoCapable;
                _ignoreOverlayScrollbarHidingCache = ignoreOverlayScrollbarHiding;
                _autoUpdateCache = autoUpdate;
                _overflowBehaviorCache = extendDeep({}, overflowBehavior);
                _textareaDynWidthCache = textareaDynWidth;
                _textareaDynHeightCache = textareaDynHeight;
                _hasOverflowCache = _hasOverflowCache || {
                    x: false,
                    y: false
                }; //set correct class name to the host element

                if (classNameChanged) {
                    removeClass(_hostElement, _oldClassName + _strSpace + _classNameThemeNone);
                    addClass(_hostElement, className !== undefined && className !== null && className.length > 0 ? className : _classNameThemeNone);
                } //set correct auto Update

                if (autoUpdateChanged) {
                    if (autoUpdate === true) {
                        disconnectMutationObservers();
                        autoUpdateLoop.add(_base);
                    } else if (autoUpdate === null) {
                        if (_autoUpdateRecommended) {
                            disconnectMutationObservers();
                            autoUpdateLoop.add(_base);
                        } else {
                            autoUpdateLoop.remove(_base);
                            connectMutationObservers();
                        }
                    } else {
                        autoUpdateLoop.remove(_base);
                        connectMutationObservers();
                    }
                } //activate or deactivate size auto capability

                if (sizeAutoCapableChanged) {
                    if (sizeAutoCapable) {
                        if (!_contentGlueElement) {
                            _contentGlueElement = FRAMEWORK(generateDiv(_classNameContentGlueElement));

                            _paddingElement.before(_contentGlueElement);
                        } else {
                            _contentGlueElement.show();
                        }

                        if (_sizeAutoObserverAdded) {
                            _sizeAutoObserverElement.show();
                        } else {
                            _sizeAutoObserverElement = FRAMEWORK(generateDiv(_classNameSizeAutoObserverElement));
                            _sizeAutoObserverElementNative = _sizeAutoObserverElement[0];

                            _contentGlueElement.before(_sizeAutoObserverElement);

                            var oldSize = {
                                w: -1,
                                h: -1
                            };
                            setupResizeObserver(_sizeAutoObserverElement, function() {
                                var newSize = {
                                    w: _sizeAutoObserverElementNative[LEXICON.oW],
                                    h: _sizeAutoObserverElementNative[LEXICON.oH]
                                };

                                if (checkCache(newSize, oldSize)) {
                                    if ((_initialized && _heightAutoCache && newSize.h > 0) || (_widthAutoCache && newSize.w > 0)) {
                                        update();
                                    } else if ((_initialized && !_heightAutoCache && newSize.h === 0) || (!_widthAutoCache && newSize.w === 0)) {
                                        update();
                                    }
                                }

                                oldSize = newSize;
                            });
                            _sizeAutoObserverAdded = true; //fix heightAuto detector bug if height is fixed but contentHeight is 0.
                            //the probability this bug will ever happen is very very low, thats why its ok if we use calc which isn't supported in IE8.

                            if (_cssCalc !== null) _sizeAutoObserverElement.css(_strHeight, _cssCalc + '(100% + 1px)');
                        }
                    } else {
                        if (_sizeAutoObserverAdded) _sizeAutoObserverElement.hide();
                        if (_contentGlueElement) _contentGlueElement.hide();
                    }
                } //if force, update all resizeObservers too

                if (force) {
                    _sizeObserverElement.find('*').trigger(_strScroll);

                    if (_sizeAutoObserverAdded) _sizeAutoObserverElement.find('*').trigger(_strScroll);
                } //display hidden:

                displayIsHidden = displayIsHidden === undefined ? _hostElement.is(':hidden') : displayIsHidden;
                var displayIsHiddenChanged = checkCacheAutoForce(displayIsHidden, _displayIsHiddenCache); //textarea AutoWrapping:

                var textareaAutoWrapping = _isTextarea ? _targetElement.attr('wrap') !== 'off' : false;
                var textareaAutoWrappingChanged = checkCacheAutoForce(textareaAutoWrapping, _textareaAutoWrappingCache); //detect direction:

                var cssDirection = _hostElement.css('direction');

                var cssDirectionChanged = checkCacheAutoForce(cssDirection, _cssDirectionCache); //detect box-sizing:

                var boxSizing = _hostElement.css('box-sizing');

                var boxSizingChanged = checkCacheAutoForce(boxSizing, _cssBoxSizingCache); //detect padding:

                var padding = {
                    c: force,
                    t: parseToZeroOrNumber(_hostElement.css(_strPaddingMinus + _strTop)),
                    r: parseToZeroOrNumber(_hostElement.css(_strPaddingMinus + _strRight)),
                    b: parseToZeroOrNumber(_hostElement.css(_strPaddingMinus + _strBottom)),
                    l: parseToZeroOrNumber(_hostElement.css(_strPaddingMinus + _strLeft))
                }; //width + height auto detecting var:

                var sizeAutoObserverElementBCRect; //exception occurs in IE8 sometimes (unknown exception)

                try {
                    sizeAutoObserverElementBCRect = _sizeAutoObserverAdded ? _sizeAutoObserverElementNative[LEXICON.bCR]() : null;
                } catch (ex) {
                    return;
                }

                _isRTL = cssDirection === 'rtl';
                _isBorderBox = boxSizing === 'border-box';
                var isRTLLeft = _isRTL ? _strLeft : _strRight;
                var isRTLRight = _isRTL ? _strRight : _strLeft; //detect width auto:

                var widthAutoResizeDetection = false;
                var widthAutoObserverDetection =
                    _sizeAutoObserverAdded && _hostElement.css(_strFloat) !== 'none'
                        ? /*|| _isTextarea */
                          MATH.round(sizeAutoObserverElementBCRect.right - sizeAutoObserverElementBCRect.left) === 0 &&
                          (!paddingAbsolute ? _hostElementNative[LEXICON.cW] - _paddingX > 0 : true)
                        : false;

                if (sizeAutoCapable && !widthAutoObserverDetection) {
                    var tmpCurrHostWidth = _hostElementNative[LEXICON.oW];

                    var tmpCurrContentGlueWidth = _contentGlueElement.css(_strWidth);

                    _contentGlueElement.css(_strWidth, _strAuto);

                    var tmpNewHostWidth = _hostElementNative[LEXICON.oW];

                    _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);

                    widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;

                    if (!widthAutoResizeDetection) {
                        _contentGlueElement.css(_strWidth, tmpCurrHostWidth + 1);

                        tmpNewHostWidth = _hostElementNative[LEXICON.oW];

                        _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);

                        widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;
                    }
                }

                var widthAuto = (widthAutoObserverDetection || widthAutoResizeDetection) && sizeAutoCapable && !displayIsHidden;
                var widthAutoChanged = checkCacheAutoForce(widthAuto, _widthAutoCache);
                var wasWidthAuto = !widthAuto && _widthAutoCache; //detect height auto:

                var heightAuto =
                    _sizeAutoObserverAdded && sizeAutoCapable && !displayIsHidden
                        ? MATH.round(sizeAutoObserverElementBCRect.bottom - sizeAutoObserverElementBCRect.top) === 0
                        : /* && (!paddingAbsolute && (_msieVersion > 9 || !_msieVersion) ? true : true) */
                          false;
                var heightAutoChanged = checkCacheAutoForce(heightAuto, _heightAutoCache);
                var wasHeightAuto = !heightAuto && _heightAutoCache; //detect border:
                //we need the border only if border box and auto size

                var strMinusWidth = '-' + _strWidth;
                var updateBorderX = (widthAuto && _isBorderBox) || !_isBorderBox;
                var updateBorderY = (heightAuto && _isBorderBox) || !_isBorderBox;
                var border = {
                    c: force,
                    t: updateBorderY ? parseToZeroOrNumber(_hostElement.css(_strBorderMinus + _strTop + strMinusWidth), true) : 0,
                    r: updateBorderX ? parseToZeroOrNumber(_hostElement.css(_strBorderMinus + _strRight + strMinusWidth), true) : 0,
                    b: updateBorderY ? parseToZeroOrNumber(_hostElement.css(_strBorderMinus + _strBottom + strMinusWidth), true) : 0,
                    l: updateBorderX ? parseToZeroOrNumber(_hostElement.css(_strBorderMinus + _strLeft + strMinusWidth), true) : 0
                }; //detect margin:

                var margin = {
                    c: force,
                    t: parseToZeroOrNumber(_hostElement.css(_strMarginMinus + _strTop)),
                    r: parseToZeroOrNumber(_hostElement.css(_strMarginMinus + _strRight)),
                    b: parseToZeroOrNumber(_hostElement.css(_strMarginMinus + _strBottom)),
                    l: parseToZeroOrNumber(_hostElement.css(_strMarginMinus + _strLeft))
                }; //detect css max width & height:

                var cssMaxValue = {
                    h: String(_hostElement.css(_strMaxMinus + _strHeight)),
                    w: String(_hostElement.css(_strMaxMinus + _strWidth))
                }; //vars to apply correct css

                var contentElementCSS = {};
                var contentGlueElementCSS = {}; //funcs

                var getHostSize = function getHostSize() {
                    //has to be clientSize because offsetSize respect borders
                    return {
                        w: _hostElementNative[LEXICON.cW],
                        h: _hostElementNative[LEXICON.cH]
                    };
                };

                var getViewportSize = function getViewportSize() {
                    //viewport size is padding container because it never has padding, margin and a border
                    //determine zoom rounding error -> sometimes scrollWidth/Height is smaller than clientWidth/Height
                    //if this happens add the difference to the viewportSize to compensate the rounding error
                    return {
                        w: _paddingElementNative[LEXICON.oW] + MATH.max(0, _contentElementNative[LEXICON.cW] - _contentElementNative[LEXICON.sW]),
                        h: _paddingElementNative[LEXICON.oH] + MATH.max(0, _contentElementNative[LEXICON.cH] - _contentElementNative[LEXICON.sH])
                    };
                }; //set info for padding

                var paddingAbsoluteX = (_paddingX = padding.l + padding.r);
                var paddingAbsoluteY = (_paddingY = padding.t + padding.b);
                paddingAbsoluteX *= paddingAbsolute ? 1 : 0;
                paddingAbsoluteY *= paddingAbsolute ? 1 : 0;
                padding.c = checkCacheAutoForce(padding, _cssPaddingCache); //set info for border

                _borderX = border.l + border.r;
                _borderY = border.t + border.b;
                border.c = checkCacheAutoForce(border, _cssBorderCache); //set info for margin

                _marginX = margin.l + margin.r;
                _marginY = margin.t + margin.b;
                margin.c = checkCacheAutoForce(margin, _cssMarginCache); //set info for css max value

                cssMaxValue.ih = parseToZeroOrNumber(cssMaxValue.h); //ih = integer height

                cssMaxValue.iw = parseToZeroOrNumber(cssMaxValue.w); //iw = integer width

                cssMaxValue.ch = cssMaxValue.h.indexOf('px') > -1; //ch = correct height

                cssMaxValue.cw = cssMaxValue.w.indexOf('px') > -1; //cw = correct width

                cssMaxValue.c = checkCacheAutoForce(cssMaxValue, _cssMaxValueCache); //refresh cache

                _displayIsHiddenCache = displayIsHidden;
                _textareaAutoWrappingCache = textareaAutoWrapping;
                _cssDirectionCache = cssDirection;
                _cssBoxSizingCache = boxSizing;
                _widthAutoCache = widthAuto;
                _heightAutoCache = heightAuto;
                _cssPaddingCache = padding;
                _cssBorderCache = border;
                _cssMarginCache = margin;
                _cssMaxValueCache = cssMaxValue; //IEFix direction changed

                if (cssDirectionChanged && _sizeAutoObserverAdded) _sizeAutoObserverElement.css(_strFloat, isRTLRight); //apply padding:

                if (padding.c || cssDirectionChanged || paddingAbsoluteChanged || widthAutoChanged || heightAutoChanged || boxSizingChanged || sizeAutoCapableChanged) {
                    var paddingElementCSS = {};
                    var textareaCSS = {};
                    setTopRightBottomLeft(contentGlueElementCSS, _strMarginMinus, [-padding.t, -padding.r, -padding.b, -padding.l]);

                    if (paddingAbsolute) {
                        setTopRightBottomLeft(paddingElementCSS, _strEmpty, [padding.t, padding.r, padding.b, padding.l]);
                        if (_isTextarea) setTopRightBottomLeft(textareaCSS, _strPaddingMinus);
                        else setTopRightBottomLeft(contentElementCSS, _strPaddingMinus);
                    } else {
                        setTopRightBottomLeft(paddingElementCSS, _strEmpty);
                        if (_isTextarea) setTopRightBottomLeft(textareaCSS, _strPaddingMinus, [padding.t, padding.r, padding.b, padding.l]);
                        else setTopRightBottomLeft(contentElementCSS, _strPaddingMinus, [padding.t, padding.r, padding.b, padding.l]);
                    }

                    _paddingElement.css(paddingElementCSS);

                    _targetElement.css(textareaCSS);
                } //viewport size is padding container because it never has padding, margin and a border.

                _viewportSize = getViewportSize(); //update Textarea

                var textareaSize = _isTextarea ? textareaUpdate() : false;

                var textareaSizeChanged = _isTextarea && checkCacheAutoForce(textareaSize, _textareaSizeCache);

                var textareaDynOrigSize =
                    _isTextarea && textareaSize
                        ? {
                              w: textareaDynWidth ? textareaSize._dynamicWidth : textareaSize._originalWidth,
                              h: textareaDynHeight ? textareaSize._dynamicHeight : textareaSize._originalHeight
                          }
                        : {};
                _textareaSizeCache = textareaSize; //fix height auto / width auto in cooperation with current padding & boxSizing behavior:

                if (heightAuto && (heightAutoChanged || paddingAbsoluteChanged || boxSizingChanged || cssMaxValue.c || padding.c || border.c)) {
                    /*
          if (cssMaxValue.ch)
              contentElementCSS[_strMaxMinus + _strHeight] =
                  (cssMaxValue.ch ? (cssMaxValue.ih - paddingAbsoluteY + (_isBorderBox ? -_borderY : _paddingY))
                  : _strEmpty);
          */
                    contentElementCSS[_strHeight] = _strAuto;
                } else if (heightAutoChanged || paddingAbsoluteChanged) {
                    contentElementCSS[_strMaxMinus + _strHeight] = _strEmpty;
                    contentElementCSS[_strHeight] = _strHundredPercent;
                }

                if (widthAuto && (widthAutoChanged || paddingAbsoluteChanged || boxSizingChanged || cssMaxValue.c || padding.c || border.c || cssDirectionChanged)) {
                    /*
          if (cssMaxValue.cw)
              contentElementCSS[_strMaxMinus + _strWidth] =
                  (cssMaxValue.cw ? (cssMaxValue.iw - paddingAbsoluteX + (_isBorderBox ? -_borderX : _paddingX)) +
                  (_nativeScrollbarIsOverlaid.y ? _overlayScrollbarDummySize.y : 0)
                  : _strEmpty);
          */
                    contentElementCSS[_strWidth] = _strAuto;
                    contentGlueElementCSS[_strMaxMinus + _strWidth] = _strHundredPercent; //IE Fix
                } else if (widthAutoChanged || paddingAbsoluteChanged) {
                    contentElementCSS[_strMaxMinus + _strWidth] = _strEmpty;
                    contentElementCSS[_strWidth] = _strHundredPercent;
                    contentElementCSS[_strFloat] = _strEmpty;
                    contentGlueElementCSS[_strMaxMinus + _strWidth] = _strEmpty; //IE Fix
                }

                if (widthAuto) {
                    if (!cssMaxValue.cw) contentElementCSS[_strMaxMinus + _strWidth] = _strEmpty; //textareaDynOrigSize.w || _strAuto :: doesnt works because applied margin will shift width

                    contentGlueElementCSS[_strWidth] = _strAuto;
                    contentElementCSS[_strWidth] = _strAuto;
                    contentElementCSS[_strFloat] = isRTLRight;
                } else {
                    contentGlueElementCSS[_strWidth] = _strEmpty;
                }

                if (heightAuto) {
                    if (!cssMaxValue.ch) contentElementCSS[_strMaxMinus + _strHeight] = _strEmpty; //textareaDynOrigSize.h || _contentElementNative[LEXICON.cH] :: use for anti scroll jumping

                    contentGlueElementCSS[_strHeight] = textareaDynOrigSize.h || _contentElementNative[LEXICON.cH];
                } else {
                    contentGlueElementCSS[_strHeight] = _strEmpty;
                }

                if (sizeAutoCapable) _contentGlueElement.css(contentGlueElementCSS);

                _contentElement.css(contentElementCSS); //CHECKPOINT HERE ~

                contentElementCSS = {};
                contentGlueElementCSS = {}; //if [content(host) client / scroll size, or target element direction, or content(host) max-sizes] changed, or force is true

                if (
                    hostSizeChanged ||
                    contentSizeChanged ||
                    textareaSizeChanged ||
                    cssDirectionChanged ||
                    boxSizingChanged ||
                    paddingAbsoluteChanged ||
                    widthAutoChanged ||
                    widthAuto ||
                    heightAutoChanged ||
                    heightAuto ||
                    cssMaxValue.c ||
                    ignoreOverlayScrollbarHidingChanged ||
                    overflowBehaviorChanged ||
                    clipAlwaysChanged ||
                    resizeChanged ||
                    scrollbarsVisibilityChanged ||
                    scrollbarsAutoHideChanged ||
                    scrollbarsDragScrollingChanged ||
                    scrollbarsClickScrollingChanged ||
                    textareaDynWidthChanged ||
                    textareaDynHeightChanged ||
                    textareaAutoWrappingChanged
                ) {
                    var strOverflow = 'overflow';
                    var strOverflowX = strOverflow + '-x';
                    var strOverflowY = strOverflow + '-y';
                    var strHidden = 'hidden';
                    var strVisible = 'visible'; //decide whether the content overflow must get hidden for correct overflow measuring, it !MUST! be always hidden if the height is auto

                    var hideOverflow4CorrectMeasuring = _restrictedMeasuring
                        ? _nativeScrollbarIsOverlaid.x ||
                          _nativeScrollbarIsOverlaid.y || //it must be hidden if native scrollbars are overlaid
                          _viewportSize.w < _nativeScrollbarMinSize.y ||
                          _viewportSize.h < _nativeScrollbarMinSize.x || //it must be hidden if host-element is too small
                          heightAuto ||
                          displayIsHiddenChanged //it must be hidden if height is auto or display was changed
                        : heightAuto; //if there is not the restricted Measuring bug, it must be hidden if the height is auto
                    //Reset the viewport (very important for natively overlaid scrollbars and zoom change
                    //don't change the overflow prop as it is very expensive and affects performance !A LOT!

                    var viewportElementResetCSS = {};
                    var resetXTmp =
                        _hasOverflowCache.y && _hideOverflowCache.ys && !ignoreOverlayScrollbarHiding && !_nativeScrollbarStyling
                            ? _nativeScrollbarIsOverlaid.y
                                ? _viewportElement.css(isRTLLeft)
                                : -_nativeScrollbarSize.y
                            : 0;
                    var resetBottomTmp =
                        _hasOverflowCache.x && _hideOverflowCache.xs && !ignoreOverlayScrollbarHiding && !_nativeScrollbarStyling
                            ? _nativeScrollbarIsOverlaid.x
                                ? _viewportElement.css(_strBottom)
                                : -_nativeScrollbarSize.x
                            : 0;
                    setTopRightBottomLeft(viewportElementResetCSS, _strEmpty);

                    _viewportElement.css(viewportElementResetCSS);

                    if (hideOverflow4CorrectMeasuring) _contentElement.css(strOverflow, strHidden); //measure several sizes:

                    var contentMeasureElement = getContentMeasureElement(); //in Firefox content element has to have overflow hidden, else element margins aren't calculated properly, this element prevents this bug, but only if scrollbars aren't overlaid

                    var contentMeasureElementGuaranty = _restrictedMeasuring && !hideOverflow4CorrectMeasuring ? _viewportElementNative : contentMeasureElement;
                    var contentSize = {
                        //use clientSize because natively overlaidScrollbars add borders
                        w: textareaDynOrigSize.w || contentMeasureElement[LEXICON.cW],
                        h: textareaDynOrigSize.h || contentMeasureElement[LEXICON.cH]
                    };
                    var scrollSize = {
                        w: MATH.max(contentMeasureElement[LEXICON.sW], contentMeasureElementGuaranty[LEXICON.sW]),
                        h: MATH.max(contentMeasureElement[LEXICON.sH], contentMeasureElementGuaranty[LEXICON.sH])
                    }; //apply the correct viewport style and measure viewport size

                    viewportElementResetCSS[_strBottom] = wasHeightAuto ? _strEmpty : resetBottomTmp;
                    viewportElementResetCSS[isRTLLeft] = wasWidthAuto ? _strEmpty : resetXTmp;

                    _viewportElement.css(viewportElementResetCSS);

                    _viewportSize = getViewportSize(); //measure and correct several sizes

                    var hostSize = getHostSize();
                    var contentGlueSize = {
                        //client/scrollSize + AbsolutePadding -> because padding is only applied to the paddingElement if its absolute, so you have to add it manually
                        //hostSize is clientSize -> so padding should be added manually, right? FALSE! Because content glue is inside hostElement, so we don't have to worry about padding
                        w: MATH.max((widthAuto ? contentSize.w : scrollSize.w) + paddingAbsoluteX, hostSize.w),
                        h: MATH.max((heightAuto ? contentSize.h : scrollSize.h) + paddingAbsoluteY, hostSize.h)
                    };
                    contentGlueSize.c = checkCacheAutoForce(contentGlueSize, _contentGlueSizeCache);
                    _contentGlueSizeCache = contentGlueSize; //apply correct contentGlue size

                    if (sizeAutoCapable) {
                        //size contentGlue correctly to make sure the element has correct size if the sizing switches to auto
                        if (contentGlueSize.c || heightAuto || widthAuto) {
                            contentGlueElementCSS[_strWidth] = contentGlueSize.w;
                            contentGlueElementCSS[_strHeight] = contentGlueSize.h; //textarea-sizes are already calculated correctly at this point

                            if (!_isTextarea) {
                                contentSize = {
                                    //use clientSize because natively overlaidScrollbars add borders
                                    w: contentMeasureElement[LEXICON.cW],
                                    h: contentMeasureElement[LEXICON.cH]
                                };
                            }
                        }

                        var textareaCoverCSS = {};

                        var setContentGlueElementCSSfunction = function setContentGlueElementCSSfunction(horizontal) {
                            var scrollbarVars = getScrollbarVars(horizontal);
                            var wh = scrollbarVars._w_h;
                            var strWH = scrollbarVars._width_height;
                            var autoSize = horizontal ? widthAuto : heightAuto;
                            var borderSize = horizontal ? _borderX : _borderY;
                            var paddingSize = horizontal ? _paddingX : _paddingY;
                            var marginSize = horizontal ? _marginX : _marginY;
                            var maxSize = contentGlueElementCSS[strWH] + (_isBorderBox ? borderSize : -paddingSize); //make contentGlue size -1 if element is not auto sized, to make sure that a resize event happens when the element shrinks

                            if (!autoSize || (!autoSize && border.c)) contentGlueElementCSS[strWH] = hostSize[wh] - (_isBorderBox ? 0 : paddingSize + borderSize) - 1 - marginSize; //if size is auto and host is same size as max size, make content glue size +1 to make sure size changes will be detected

                            if (autoSize && cssMaxValue['c' + wh] && cssMaxValue['i' + wh] === maxSize)
                                contentGlueElementCSS[strWH] = maxSize + (_isBorderBox ? 0 : paddingSize) + 1; //if size is auto and host is smaller than size as min size, make content glue size -1 to make sure size changes will be detected (this is only needed if padding is 0)

                            if (autoSize && contentSize[wh] < _viewportSize[wh] && (horizontal && _isTextarea ? !textareaAutoWrapping : true)) {
                                if (_isTextarea) textareaCoverCSS[strWH] = parseToZeroOrNumber(_textareaCoverElement.css(strWH)) - 1;
                                contentGlueElementCSS[strWH] -= 1;
                            } //make sure content glue size is at least 1

                            if (contentSize[wh] > 0) contentGlueElementCSS[strWH] = MATH.max(1, contentGlueElementCSS[strWH]);
                        };

                        setContentGlueElementCSSfunction(true);
                        setContentGlueElementCSSfunction(false);
                        if (_isTextarea) _textareaCoverElement.css(textareaCoverCSS);

                        _contentGlueElement.css(contentGlueElementCSS);
                    }

                    if (widthAuto) contentElementCSS[_strWidth] = _strHundredPercent;
                    if (widthAuto && !_isBorderBox && !_mutationObserversConnected) contentElementCSS[_strFloat] = 'none'; //apply and reset content style

                    _contentElement.css(contentElementCSS);

                    contentElementCSS = {}; //measure again, but this time all correct sizes:

                    var contentScrollSize = {
                        w: MATH.max(contentMeasureElement[LEXICON.sW], contentMeasureElementGuaranty[LEXICON.sW]),
                        h: MATH.max(contentMeasureElement[LEXICON.sH], contentMeasureElementGuaranty[LEXICON.sH])
                    };
                    contentScrollSize.c = contentSizeChanged = checkCacheAutoForce(contentScrollSize, _contentScrollSizeCache);
                    _contentScrollSizeCache = contentScrollSize; //remove overflow hidden to restore overflow

                    if (hideOverflow4CorrectMeasuring) _contentElement.css(strOverflow, _strEmpty); //refresh viewport size after correct measuring

                    _viewportSize = getViewportSize();
                    hostSize = getHostSize();
                    hostSizeChanged = checkCacheAutoForce(hostSize, _hostSizeCache);
                    _hostSizeCache = hostSize;
                    var hideOverflowForceTextarea = _isTextarea && (_viewportSize.w === 0 || _viewportSize.h === 0);
                    var previousOverflow = _overflowAmountCache;
                    var overflowBehaviorIsVS = {};
                    var overflowBehaviorIsVH = {};
                    var overflowBehaviorIsS = {};
                    var overflowAmount = {};
                    var hasOverflow = {};
                    var hideOverflow = {};
                    var canScroll = {};

                    var viewportRect = _paddingElementNative[LEXICON.bCR]();

                    var setOverflowVariables = function setOverflowVariables(horizontal) {
                        var scrollbarVars = getScrollbarVars(horizontal);
                        var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                        var xyI = scrollbarVarsInverted._x_y;
                        var xy = scrollbarVars._x_y;
                        var wh = scrollbarVars._w_h;
                        var widthHeight = scrollbarVars._width_height;
                        var scrollMax = _strScroll + scrollbarVars._Left_Top + 'Max';
                        var fractionalOverflowAmount = viewportRect[widthHeight] ? MATH.abs(viewportRect[widthHeight] - _viewportSize[wh]) : 0;
                        overflowBehaviorIsVS[xy] = overflowBehavior[xy] === 'v-s';
                        overflowBehaviorIsVH[xy] = overflowBehavior[xy] === 'v-h';
                        overflowBehaviorIsS[xy] = overflowBehavior[xy] === 's';
                        overflowAmount[xy] = MATH.max(0, MATH.round((contentScrollSize[wh] - _viewportSize[wh]) * 100) / 100);
                        overflowAmount[xy] *=
                            hideOverflowForceTextarea || (_viewportElementNative[scrollMax] === 0 && fractionalOverflowAmount > 0 && fractionalOverflowAmount < 1) ? 0 : 1;
                        hasOverflow[xy] = overflowAmount[xy] > 0; //hideOverflow:
                        //x || y : true === overflow is hidden by "overflow: scroll" OR "overflow: hidden"
                        //xs || ys : true === overflow is hidden by "overflow: scroll"

                        hideOverflow[xy] =
                            overflowBehaviorIsVS[xy] || overflowBehaviorIsVH[xy] ? hasOverflow[xyI] && !overflowBehaviorIsVS[xyI] && !overflowBehaviorIsVH[xyI] : hasOverflow[xy];
                        hideOverflow[xy + 's'] = hideOverflow[xy] ? overflowBehaviorIsS[xy] || overflowBehaviorIsVS[xy] : false;
                        canScroll[xy] = hasOverflow[xy] && hideOverflow[xy + 's'];
                    };

                    setOverflowVariables(true);
                    setOverflowVariables(false);
                    overflowAmount.c = checkCacheAutoForce(overflowAmount, _overflowAmountCache);
                    _overflowAmountCache = overflowAmount;
                    hasOverflow.c = checkCacheAutoForce(hasOverflow, _hasOverflowCache);
                    _hasOverflowCache = hasOverflow;
                    hideOverflow.c = checkCacheAutoForce(hideOverflow, _hideOverflowCache);
                    _hideOverflowCache = hideOverflow; //if native scrollbar is overlay at x OR y axis, prepare DOM

                    if (_nativeScrollbarIsOverlaid.x || _nativeScrollbarIsOverlaid.y) {
                        var borderDesign = 'px solid transparent';
                        var contentArrangeElementCSS = {};
                        var arrangeContent = {};
                        var arrangeChanged = force;
                        var setContentElementCSS;

                        if (hasOverflow.x || hasOverflow.y) {
                            arrangeContent.w = _nativeScrollbarIsOverlaid.y && hasOverflow.y ? contentScrollSize.w + _overlayScrollbarDummySize.y : _strEmpty;
                            arrangeContent.h = _nativeScrollbarIsOverlaid.x && hasOverflow.x ? contentScrollSize.h + _overlayScrollbarDummySize.x : _strEmpty;
                            arrangeChanged = checkCacheAutoForce(arrangeContent, _arrangeContentSizeCache);
                            _arrangeContentSizeCache = arrangeContent;
                        }

                        if (
                            hasOverflow.c ||
                            hideOverflow.c ||
                            contentScrollSize.c ||
                            cssDirectionChanged ||
                            widthAutoChanged ||
                            heightAutoChanged ||
                            widthAuto ||
                            heightAuto ||
                            ignoreOverlayScrollbarHidingChanged
                        ) {
                            contentElementCSS[_strMarginMinus + isRTLRight] = contentElementCSS[_strBorderMinus + isRTLRight] = _strEmpty;

                            setContentElementCSS = function setContentElementCSS(horizontal) {
                                var scrollbarVars = getScrollbarVars(horizontal);
                                var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                                var xy = scrollbarVars._x_y;
                                var strDirection = horizontal ? _strBottom : isRTLLeft;
                                var invertedAutoSize = horizontal ? heightAuto : widthAuto;

                                if (_nativeScrollbarIsOverlaid[xy] && hasOverflow[xy] && hideOverflow[xy + 's']) {
                                    contentElementCSS[_strMarginMinus + strDirection] = invertedAutoSize
                                        ? ignoreOverlayScrollbarHiding
                                            ? _strEmpty
                                            : _overlayScrollbarDummySize[xy]
                                        : _strEmpty;
                                    contentElementCSS[_strBorderMinus + strDirection] =
                                        (horizontal ? !invertedAutoSize : true) && !ignoreOverlayScrollbarHiding ? _overlayScrollbarDummySize[xy] + borderDesign : _strEmpty;
                                } else {
                                    arrangeContent[scrollbarVarsInverted._w_h] = contentElementCSS[_strMarginMinus + strDirection] = contentElementCSS[
                                        _strBorderMinus + strDirection
                                    ] = _strEmpty;
                                    arrangeChanged = true;
                                }
                            };

                            if (_nativeScrollbarStyling) {
                                if (ignoreOverlayScrollbarHiding) removeClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible);
                                else addClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible);
                            } else {
                                setContentElementCSS(true);
                                setContentElementCSS(false);
                            }
                        }

                        if (ignoreOverlayScrollbarHiding) {
                            arrangeContent.w = arrangeContent.h = _strEmpty;
                            arrangeChanged = true;
                        }

                        if (arrangeChanged && !_nativeScrollbarStyling) {
                            contentArrangeElementCSS[_strWidth] = hideOverflow.y ? arrangeContent.w : _strEmpty;
                            contentArrangeElementCSS[_strHeight] = hideOverflow.x ? arrangeContent.h : _strEmpty;

                            if (!_contentArrangeElement) {
                                _contentArrangeElement = FRAMEWORK(generateDiv(_classNameContentArrangeElement));

                                _viewportElement.prepend(_contentArrangeElement);
                            }

                            _contentArrangeElement.css(contentArrangeElementCSS);
                        }

                        _contentElement.css(contentElementCSS);
                    }

                    var viewportElementCSS = {};
                    var paddingElementCSS = {};
                    var setViewportCSS;

                    if (
                        hostSizeChanged ||
                        hasOverflow.c ||
                        hideOverflow.c ||
                        contentScrollSize.c ||
                        overflowBehaviorChanged ||
                        boxSizingChanged ||
                        ignoreOverlayScrollbarHidingChanged ||
                        cssDirectionChanged ||
                        clipAlwaysChanged ||
                        heightAutoChanged
                    ) {
                        viewportElementCSS[isRTLRight] = _strEmpty;

                        setViewportCSS = function setViewportCSS(horizontal) {
                            var scrollbarVars = getScrollbarVars(horizontal);
                            var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                            var xy = scrollbarVars._x_y;
                            var XY = scrollbarVars._X_Y;
                            var strDirection = horizontal ? _strBottom : isRTLLeft;

                            var reset = function reset() {
                                viewportElementCSS[strDirection] = _strEmpty;
                                _contentBorderSize[scrollbarVarsInverted._w_h] = 0;
                            };

                            if (hasOverflow[xy] && hideOverflow[xy + 's']) {
                                viewportElementCSS[strOverflow + XY] = _strScroll;

                                if (ignoreOverlayScrollbarHiding || _nativeScrollbarStyling) {
                                    reset();
                                } else {
                                    viewportElementCSS[strDirection] = -(_nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[xy] : _nativeScrollbarSize[xy]);
                                    _contentBorderSize[scrollbarVarsInverted._w_h] = _nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[scrollbarVarsInverted._x_y] : 0;
                                }
                            } else {
                                viewportElementCSS[strOverflow + XY] = _strEmpty;
                                reset();
                            }
                        };

                        setViewportCSS(true);
                        setViewportCSS(false); // if the scroll container is too small and if there is any overflow with no overlay scrollbar (and scrollbar styling isn't possible),
                        // make viewport element greater in size (Firefox hide Scrollbars fix)
                        // because firefox starts hiding scrollbars on too small elements
                        // with this behavior the overflow calculation may be incorrect or the scrollbars would appear suddenly
                        // https://bugzilla.mozilla.org/show_bug.cgi?id=292284

                        if (
                            !_nativeScrollbarStyling &&
                            (_viewportSize.h < _nativeScrollbarMinSize.x || _viewportSize.w < _nativeScrollbarMinSize.y) &&
                            ((hasOverflow.x && hideOverflow.x && !_nativeScrollbarIsOverlaid.x) || (hasOverflow.y && hideOverflow.y && !_nativeScrollbarIsOverlaid.y))
                        ) {
                            viewportElementCSS[_strPaddingMinus + _strTop] = _nativeScrollbarMinSize.x;
                            viewportElementCSS[_strMarginMinus + _strTop] = -_nativeScrollbarMinSize.x;
                            viewportElementCSS[_strPaddingMinus + isRTLRight] = _nativeScrollbarMinSize.y;
                            viewportElementCSS[_strMarginMinus + isRTLRight] = -_nativeScrollbarMinSize.y;
                        } else {
                            viewportElementCSS[_strPaddingMinus + _strTop] = viewportElementCSS[_strMarginMinus + _strTop] = viewportElementCSS[
                                _strPaddingMinus + isRTLRight
                            ] = viewportElementCSS[_strMarginMinus + isRTLRight] = _strEmpty;
                        }

                        viewportElementCSS[_strPaddingMinus + isRTLLeft] = viewportElementCSS[_strMarginMinus + isRTLLeft] = _strEmpty; //if there is any overflow (x OR y axis) and this overflow shall be hidden, make overflow hidden, else overflow visible

                        if ((hasOverflow.x && hideOverflow.x) || (hasOverflow.y && hideOverflow.y) || hideOverflowForceTextarea) {
                            //only hide if is Textarea
                            if (_isTextarea && hideOverflowForceTextarea) {
                                paddingElementCSS[strOverflowX] = paddingElementCSS[strOverflowY] = strHidden;
                            }
                        } else {
                            if (!clipAlways || overflowBehaviorIsVH.x || overflowBehaviorIsVS.x || overflowBehaviorIsVH.y || overflowBehaviorIsVS.y) {
                                //only un-hide if Textarea
                                if (_isTextarea) {
                                    paddingElementCSS[strOverflowX] = paddingElementCSS[strOverflowY] = _strEmpty;
                                }

                                viewportElementCSS[strOverflowX] = viewportElementCSS[strOverflowY] = strVisible;
                            }
                        }

                        _paddingElement.css(paddingElementCSS);

                        _viewportElement.css(viewportElementCSS);

                        viewportElementCSS = {}; //force soft redraw in webkit because without the scrollbars will may appear because DOM wont be redrawn under special conditions

                        if ((hasOverflow.c || boxSizingChanged || widthAutoChanged || heightAutoChanged) && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {
                            var elementStyle = _contentElementNative[LEXICON.s];
                            var dump;
                            elementStyle.webkitTransform = 'scale(1)';
                            elementStyle.display = 'run-in';
                            dump = _contentElementNative[LEXICON.oH];
                            elementStyle.display = _strEmpty; //|| dump; //use dump to prevent it from deletion if minify

                            elementStyle.webkitTransform = _strEmpty;
                        }
                        /*
            //force hard redraw in webkit if native overlaid scrollbars shall appear
            if (ignoreOverlayScrollbarHidingChanged && ignoreOverlayScrollbarHiding) {
                _hostElement.hide();
                var dump = _hostElementNative[LEXICON.oH];
                _hostElement.show();
            }
            */
                    } //change to direction RTL and width auto Bugfix in Webkit
                    //without this fix, the DOM still thinks the scrollbar is LTR and thus the content is shifted to the left

                    contentElementCSS = {};

                    if (cssDirectionChanged || widthAutoChanged || heightAutoChanged) {
                        if (_isRTL && widthAuto) {
                            var floatTmp = _contentElement.css(_strFloat);

                            var posLeftWithoutFloat = MATH.round(
                                _contentElement
                                    .css(_strFloat, _strEmpty)
                                    .css(_strLeft, _strEmpty)
                                    .position().left
                            );

                            _contentElement.css(_strFloat, floatTmp);

                            var posLeftWithFloat = MATH.round(_contentElement.position().left);
                            if (posLeftWithoutFloat !== posLeftWithFloat) contentElementCSS[_strLeft] = posLeftWithoutFloat;
                        } else {
                            contentElementCSS[_strLeft] = _strEmpty;
                        }
                    }

                    _contentElement.css(contentElementCSS); //handle scroll position

                    if (_isTextarea && contentSizeChanged) {
                        var textareaInfo = getTextareaInfo();

                        if (textareaInfo) {
                            var textareaRowsChanged = _textareaInfoCache === undefined ? true : textareaInfo._rows !== _textareaInfoCache._rows;
                            var cursorRow = textareaInfo._cursorRow;
                            var cursorCol = textareaInfo._cursorColumn;
                            var widestRow = textareaInfo._widestRow;
                            var lastRow = textareaInfo._rows;
                            var lastCol = textareaInfo._columns;
                            var cursorPos = textareaInfo._cursorPosition;
                            var cursorMax = textareaInfo._cursorMax;
                            var cursorIsLastPosition = cursorPos >= cursorMax && _textareaHasFocus;
                            var textareaScrollAmount = {
                                x: !textareaAutoWrapping && cursorCol === lastCol && cursorRow === widestRow ? _overflowAmountCache.x : -1,
                                y: (textareaAutoWrapping
                                  ? cursorIsLastPosition || (textareaRowsChanged && (previousOverflow !== undefined ? currScroll.y === previousOverflow.y : false))
                                  : (cursorIsLastPosition || textareaRowsChanged) && cursorRow === lastRow)
                                    ? _overflowAmountCache.y
                                    : -1
                            };
                            currScroll.x = textareaScrollAmount.x > -1 ? (_isRTL && _normalizeRTLCache && _rtlScrollBehavior.i ? 0 : textareaScrollAmount.x) : currScroll.x; //if inverted, scroll to 0 -> normalized this means to max scroll offset.

                            currScroll.y = textareaScrollAmount.y > -1 ? textareaScrollAmount.y : currScroll.y;
                        }

                        _textareaInfoCache = textareaInfo;
                    }

                    if (_isRTL && _rtlScrollBehavior.i && _nativeScrollbarIsOverlaid.y && hasOverflow.x && _normalizeRTLCache) currScroll.x += _contentBorderSize.w || 0;
                    if (widthAuto) _hostElement[_strScrollLeft](0);
                    if (heightAuto) _hostElement[_strScrollTop](0);

                    _viewportElement[_strScrollLeft](currScroll.x)[_strScrollTop](currScroll.y); //scrollbars management:

                    var scrollbarsVisibilityVisible = scrollbarsVisibility === 'v';
                    var scrollbarsVisibilityHidden = scrollbarsVisibility === 'h';
                    var scrollbarsVisibilityAuto = scrollbarsVisibility === 'a';
                    var showScrollbarH = COMPATIBILITY.bind(refreshScrollbarAppearance, 0, true, true, canScroll.x);
                    var showScrollbarV = COMPATIBILITY.bind(refreshScrollbarAppearance, 0, false, true, canScroll.y);
                    var hideScrollbarH = COMPATIBILITY.bind(refreshScrollbarAppearance, 0, true, false, canScroll.x);
                    var hideScrollbarV = COMPATIBILITY.bind(refreshScrollbarAppearance, 0, false, false, canScroll.y); //manage class name which indicates scrollable overflow

                    if (hideOverflow.x || hideOverflow.y) addClass(_hostElement, _classNameHostOverflow);
                    else removeClass(_hostElement, _classNameHostOverflow);
                    if (hideOverflow.x) addClass(_hostElement, _classNameHostOverflowX);
                    else removeClass(_hostElement, _classNameHostOverflowX);
                    if (hideOverflow.y) addClass(_hostElement, _classNameHostOverflowY);
                    else removeClass(_hostElement, _classNameHostOverflowY); //add or remove rtl class name for styling purposes

                    if (cssDirectionChanged) {
                        if (_isRTL) addClass(_hostElement, _classNameHostRTL);
                        else removeClass(_hostElement, _classNameHostRTL);
                    } //manage the resize feature (CSS3 resize "polyfill" for this plugin)

                    if (_isBody) addClass(_hostElement, _classNameHostResizeDisabled);

                    if (resizeChanged) {
                        removeClass(
                            _scrollbarCornerElement,
                            [_classNameScrollbarCornerResize, _classNameScrollbarCornerResizeB, _classNameScrollbarCornerResizeH, _classNameScrollbarCornerResizeV].join(_strSpace)
                        );

                        if (_resizeNone) {
                            addClass(_hostElement, _classNameHostResizeDisabled);
                        } else {
                            removeClass(_hostElement, _classNameHostResizeDisabled);
                            addClass(_scrollbarCornerElement, _classNameScrollbarCornerResize);
                            if (_resizeBoth) addClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeB);
                            else if (_resizeHorizontal) addClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeH);
                            else if (_resizeVertical) addClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeV);
                        }
                    } //manage the scrollbars general visibility + the scrollbar interactivity (unusable class name)

                    if (scrollbarsVisibilityChanged || overflowBehaviorChanged || hideOverflow.c || hasOverflow.c || ignoreOverlayScrollbarHidingChanged) {
                        if (ignoreOverlayScrollbarHiding) {
                            if (ignoreOverlayScrollbarHidingChanged) {
                                removeClass(_hostElement, _classNameHostScrolling);

                                if (ignoreOverlayScrollbarHiding) {
                                    hideScrollbarH();
                                    hideScrollbarV();
                                }
                            }
                        } else if (scrollbarsVisibilityAuto) {
                            if (canScroll.x) showScrollbarH();
                            else hideScrollbarH();
                            if (canScroll.y) showScrollbarV();
                            else hideScrollbarV();
                        } else if (scrollbarsVisibilityVisible) {
                            showScrollbarH();
                            showScrollbarV();
                        } else if (scrollbarsVisibilityHidden) {
                            hideScrollbarH();
                            hideScrollbarV();
                        }
                    } //manage the scrollbars auto hide feature (auto hide them after specific actions)

                    if (scrollbarsAutoHideChanged || ignoreOverlayScrollbarHidingChanged) {
                        if (_scrollbarsAutoHideLeave || _scrollbarsAutoHideMove) {
                            setupHostMouseTouchEvents(true);
                            setupHostMouseTouchEvents();
                        } else {
                            setupHostMouseTouchEvents(true);
                        }

                        if (_scrollbarsAutoHideNever) refreshScrollbarsAutoHide(true);
                        else refreshScrollbarsAutoHide(false, true);
                    } //manage scrollbars handle length & offset - don't remove!

                    if (
                        hostSizeChanged ||
                        overflowAmount.c ||
                        heightAutoChanged ||
                        widthAutoChanged ||
                        resizeChanged ||
                        boxSizingChanged ||
                        paddingAbsoluteChanged ||
                        ignoreOverlayScrollbarHidingChanged ||
                        cssDirectionChanged
                    ) {
                        refreshScrollbarHandleLength(true);
                        refreshScrollbarHandleOffset(true);
                        refreshScrollbarHandleLength(false);
                        refreshScrollbarHandleOffset(false);
                    } //manage interactivity

                    if (scrollbarsClickScrollingChanged) refreshScrollbarsInteractive(true, scrollbarsClickScrolling);
                    if (scrollbarsDragScrollingChanged) refreshScrollbarsInteractive(false, scrollbarsDragScrolling); //callbacks:

                    if (cssDirectionChanged) {
                        dispatchCallback('onDirectionChanged', {
                            isRTL: _isRTL,
                            dir: cssDirection
                        });
                    }

                    if (hostSizeChanged) {
                        dispatchCallback('onHostSizeChanged', {
                            width: _hostSizeCache.w,
                            height: _hostSizeCache.h
                        });
                    }

                    if (contentSizeChanged) {
                        dispatchCallback('onContentSizeChanged', {
                            width: _contentScrollSizeCache.w,
                            height: _contentScrollSizeCache.h
                        });
                    }

                    if (hasOverflow.c || hideOverflow.c) {
                        dispatchCallback('onOverflowChanged', {
                            x: hasOverflow.x,
                            y: hasOverflow.y,
                            xScrollable: hideOverflow.xs,
                            yScrollable: hideOverflow.ys,
                            clipped: hideOverflow.x || hideOverflow.y
                        });
                    }

                    if (overflowAmount.c) {
                        dispatchCallback('onOverflowAmountChanged', {
                            x: overflowAmount.x,
                            y: overflowAmount.y
                        });
                    }
                } //fix body min size

                if (_isBody && _bodyMinSizeCache && (_hasOverflowCache.c || _bodyMinSizeCache.c)) {
                    //its possible that no min size was measured until now, because the content arrange element was just added now, in this case, measure now the min size.
                    if (!_bodyMinSizeCache.f) bodyMinSizeChanged();
                    if (_nativeScrollbarIsOverlaid.y && _hasOverflowCache.x) _contentElement.css(_strMinMinus + _strWidth, _bodyMinSizeCache.w + _overlayScrollbarDummySize.y);
                    if (_nativeScrollbarIsOverlaid.x && _hasOverflowCache.y) _contentElement.css(_strMinMinus + _strHeight, _bodyMinSizeCache.h + _overlayScrollbarDummySize.x);
                    _bodyMinSizeCache.c = false;
                } //freezeResizeObserver(_sizeObserverElement, false);
                //freezeResizeObserver(_sizeAutoObserverElement, false);

                dispatchCallback('onUpdated', {
                    forced: force
                });
            } //==== Options ====//

            /**
             * Sets new options but doesn't call the update method.
             * @param newOptions The object which contains the new options.
             * @returns {*} A object which contains the changed options.
             */

            function setOptions(newOptions) {
                var validatedOpts = _pluginsOptions._validate(newOptions, _pluginsOptions._template, true, _currentOptions);

                _currentOptions = extendDeep({}, _currentOptions, validatedOpts._default);
                _currentPreparedOptions = extendDeep({}, _currentPreparedOptions, validatedOpts._prepared);
                return validatedOpts._prepared;
            } //==== Structure ====//

            /**
             * Builds or destroys the wrapper and helper DOM elements.
             * @param destroy Indicates whether the DOM shall be build or destroyed.
             */

            function setupStructureDOM(destroy) {
                var strParent = 'parent';
                var classNameResizeObserverHost = 'os-resize-observer-host';
                var classNameTextareaElementFull = _classNameTextareaElement + _strSpace + _classNameTextInherit;
                var textareaClass = _isTextarea ? _strSpace + _classNameTextInherit : _strEmpty;
                var adoptAttrs = _currentPreparedOptions.textarea.inheritedAttrs;
                var adoptAttrsMap = {};

                var applyAdoptedAttrs = function applyAdoptedAttrs() {
                    var applyAdoptedAttrsElm = destroy ? _targetElement : _hostElement;
                    each(adoptAttrsMap, function(key, value) {
                        if (type(value) == TYPES.s) {
                            if (key == LEXICON.c) applyAdoptedAttrsElm.addClass(value);
                            else applyAdoptedAttrsElm.attr(key, value);
                        }
                    });
                };

                var hostElementClassNames = [
                    _classNameHostElement,
                    _classNameHostTextareaElement,
                    _classNameHostResizeDisabled,
                    _classNameHostRTL,
                    _classNameHostScrollbarHorizontalHidden,
                    _classNameHostScrollbarVerticalHidden,
                    _classNameHostTransition,
                    _classNameHostScrolling,
                    _classNameHostOverflow,
                    _classNameHostOverflowX,
                    _classNameHostOverflowY,
                    _classNameThemeNone,
                    _classNameTextareaElement,
                    _classNameTextInherit,
                    _classNameCache
                ].join(_strSpace);
                var hostElementCSS = {}; //get host element as first element, because that's the most upper element and required for the other elements

                _hostElement =
                    _hostElement ||
                    (_isTextarea
                        ? _domExists
                            ? _targetElement[strParent]()
                                  [strParent]()
                                  [strParent]()
                                  [strParent]()
                            : FRAMEWORK(generateDiv(_classNameHostTextareaElement))
                        : _targetElement);
                _contentElement = _contentElement || selectOrGenerateDivByClass(_classNameContentElement + textareaClass);
                _viewportElement = _viewportElement || selectOrGenerateDivByClass(_classNameViewportElement + textareaClass);
                _paddingElement = _paddingElement || selectOrGenerateDivByClass(_classNamePaddingElement + textareaClass);
                _sizeObserverElement = _sizeObserverElement || selectOrGenerateDivByClass(classNameResizeObserverHost);
                _textareaCoverElement = _textareaCoverElement || (_isTextarea ? selectOrGenerateDivByClass(_classNameTextareaCoverElement) : undefined); //on destroy, remove all generated class names from the host element before collecting the adopted attributes
                //to prevent adopting generated class names

                if (destroy) removeClass(_hostElement, hostElementClassNames); //collect all adopted attributes

                adoptAttrs = type(adoptAttrs) == TYPES.s ? adoptAttrs.split(_strSpace) : adoptAttrs;

                if (type(adoptAttrs) == TYPES.a && _isTextarea) {
                    each(adoptAttrs, function(i, v) {
                        if (type(v) == TYPES.s) {
                            adoptAttrsMap[v] = destroy ? _hostElement.attr(v) : _targetElement.attr(v);
                        }
                    });
                }

                if (!destroy) {
                    if (_isTextarea) {
                        if (!_currentPreparedOptions.sizeAutoCapable) {
                            hostElementCSS[_strWidth] = _targetElement.css(_strWidth);
                            hostElementCSS[_strHeight] = _targetElement.css(_strHeight);
                        }

                        if (!_domExists) _targetElement.addClass(_classNameTextInherit).wrap(_hostElement); //jQuery clones elements in wrap functions, so we have to select them again

                        _hostElement = _targetElement[strParent]().css(hostElementCSS);
                    }

                    if (!_domExists) {
                        //add the correct class to the target element
                        addClass(_targetElement, _isTextarea ? classNameTextareaElementFull : _classNameHostElement); //wrap the content into the generated elements to create the required DOM

                        _hostElement
                            .wrapInner(_contentElement)
                            .wrapInner(_viewportElement)
                            .wrapInner(_paddingElement)
                            .prepend(_sizeObserverElement); //jQuery clones elements in wrap functions, so we have to select them again

                        _contentElement = findFirst(_hostElement, _strDot + _classNameContentElement);
                        _viewportElement = findFirst(_hostElement, _strDot + _classNameViewportElement);
                        _paddingElement = findFirst(_hostElement, _strDot + _classNamePaddingElement);

                        if (_isTextarea) {
                            _contentElement.prepend(_textareaCoverElement);

                            applyAdoptedAttrs();
                        }
                    }

                    if (_nativeScrollbarStyling) addClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible);
                    if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y) addClass(_viewportElement, _classNameViewportNativeScrollbarsOverlaid);
                    if (_isBody) addClass(_htmlElement, _classNameHTMLElement);
                    _sizeObserverElementNative = _sizeObserverElement[0];
                    _hostElementNative = _hostElement[0];
                    _paddingElementNative = _paddingElement[0];
                    _viewportElementNative = _viewportElement[0];
                    _contentElementNative = _contentElement[0];
                } else {
                    if (_domExists && _initialized) {
                        //clear size observer
                        _sizeObserverElement.children().remove(); //remove the style property and classes from already generated elements

                        each([_paddingElement, _viewportElement, _contentElement, _textareaCoverElement], function(i, elm) {
                            if (elm) {
                                removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                            }
                        }); //add classes to the host element which was removed previously to match the expected DOM

                        addClass(_hostElement, _isTextarea ? _classNameHostTextareaElement : _classNameHostElement);
                    } else {
                        //remove size observer
                        remove(_sizeObserverElement); //unwrap the content to restore DOM

                        _contentElement
                            .contents()
                            .unwrap()
                            .unwrap()
                            .unwrap();

                        if (_isTextarea) {
                            _targetElement.unwrap();

                            remove(_hostElement);
                            remove(_textareaCoverElement);
                            applyAdoptedAttrs();
                        }
                    }

                    if (_isTextarea) _targetElement.removeAttr(LEXICON.s);
                    if (_isBody) removeClass(_htmlElement, _classNameHTMLElement);
                }
            }
            /**
             * Adds or removes all wrapper elements interactivity events.
             * @param destroy Indicates whether the Events shall be added or removed.
             */

            function setupStructureEvents() {
                var textareaKeyDownRestrictedKeyCodes = [
                    112,
                    113,
                    114,
                    115,
                    116,
                    117,
                    118,
                    119,
                    120,
                    121,
                    123, //F1 to F12
                    33,
                    34, //page up, page down
                    37,
                    38,
                    39,
                    40, //left, up, right, down arrows
                    16,
                    17,
                    18,
                    19,
                    20,
                    144 //Shift, Ctrl, Alt, Pause, CapsLock, NumLock
                ];
                var textareaKeyDownKeyCodesList = [];
                var textareaUpdateIntervalID;
                var scrollStopTimeoutId;
                var scrollStopDelay = 175;
                var strFocus = 'focus';

                function updateTextarea(doClearInterval) {
                    textareaUpdate();

                    _base.update(_strAuto);

                    if (doClearInterval && _autoUpdateRecommended) clearInterval(textareaUpdateIntervalID);
                }

                function textareaOnScroll(event) {
                    _targetElement[_strScrollLeft](_rtlScrollBehavior.i && _normalizeRTLCache ? 9999999 : 0);

                    _targetElement[_strScrollTop](0);

                    COMPATIBILITY.prvD(event);
                    COMPATIBILITY.stpP(event);
                    return false;
                }

                function textareaOnDrop(event) {
                    setTimeout(function() {
                        if (!_destroyed) updateTextarea();
                    }, 50);
                }

                function textareaOnFocus() {
                    _textareaHasFocus = true;
                    addClass(_hostElement, strFocus);
                }

                function textareaOnFocusout() {
                    _textareaHasFocus = false;
                    textareaKeyDownKeyCodesList = [];
                    removeClass(_hostElement, strFocus);
                    updateTextarea(true);
                }

                function textareaOnKeyDown(event) {
                    var keyCode = event.keyCode;

                    if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {
                        if (!textareaKeyDownKeyCodesList[LEXICON.l]) {
                            updateTextarea();
                            textareaUpdateIntervalID = setInterval(updateTextarea, 1000 / 60);
                        }

                        if (inArray(keyCode, textareaKeyDownKeyCodesList) < 0) textareaKeyDownKeyCodesList.push(keyCode);
                    }
                }

                function textareaOnKeyUp(event) {
                    var keyCode = event.keyCode;
                    var index = inArray(keyCode, textareaKeyDownKeyCodesList);

                    if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {
                        if (index > -1) textareaKeyDownKeyCodesList.splice(index, 1);
                        if (!textareaKeyDownKeyCodesList[LEXICON.l]) updateTextarea(true);
                    }
                }

                function contentOnTransitionEnd(event) {
                    if (_autoUpdateCache === true) return;
                    event = event.originalEvent || event;
                    if (isSizeAffectingCSSProperty(event.propertyName)) _base.update(_strAuto);
                }

                function viewportOnScroll(event) {
                    if (!_sleeping) {
                        if (scrollStopTimeoutId !== undefined) clearTimeout(scrollStopTimeoutId);
                        else {
                            if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove) refreshScrollbarsAutoHide(true);
                            if (!nativeOverlayScrollbarsAreActive()) addClass(_hostElement, _classNameHostScrolling);
                            dispatchCallback('onScrollStart', event);
                        } //if a scrollbars handle gets dragged, the mousemove event is responsible for refreshing the handle offset
                        //because if CSS scroll-snap is used, the handle offset gets only refreshed on every snap point
                        //this looks laggy & clunky, it looks much better if the offset refreshes with the mousemove

                        if (!_scrollbarsHandlesDefineScrollPos) {
                            refreshScrollbarHandleOffset(true);
                            refreshScrollbarHandleOffset(false);
                        }

                        dispatchCallback('onScroll', event);
                        scrollStopTimeoutId = setTimeout(function() {
                            if (!_destroyed) {
                                //OnScrollStop:
                                clearTimeout(scrollStopTimeoutId);
                                scrollStopTimeoutId = undefined;
                                if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove) refreshScrollbarsAutoHide(false);
                                if (!nativeOverlayScrollbarsAreActive()) removeClass(_hostElement, _classNameHostScrolling);
                                dispatchCallback('onScrollStop', event);
                            }
                        }, scrollStopDelay);
                    }
                }

                if (_isTextarea) {
                    if (_msieVersion > 9 || !_autoUpdateRecommended) {
                        addDestroyEventListener(_targetElement, 'input', updateTextarea);
                    } else {
                        addDestroyEventListener(_targetElement, [_strKeyDownEvent, _strKeyUpEvent], [textareaOnKeyDown, textareaOnKeyUp]);
                    }

                    addDestroyEventListener(
                        _targetElement,
                        [_strScroll, 'drop', strFocus, strFocus + 'out'],
                        [textareaOnScroll, textareaOnDrop, textareaOnFocus, textareaOnFocusout]
                    );
                } else {
                    addDestroyEventListener(_contentElement, _strTransitionEndEvent, contentOnTransitionEnd);
                }

                addDestroyEventListener(_viewportElement, _strScroll, viewportOnScroll, true);
            } //==== Scrollbars ====//

            /**
             * Builds or destroys all scrollbar DOM elements (scrollbar, track, handle)
             * @param destroy Indicates whether the DOM shall be build or destroyed.
             */

            function setupScrollbarsDOM(destroy) {
                var selectOrGenerateScrollbarDOM = function selectOrGenerateScrollbarDOM(isHorizontal) {
                    var scrollbarClassName = isHorizontal ? _classNameScrollbarHorizontal : _classNameScrollbarVertical;
                    var scrollbar = selectOrGenerateDivByClass(_classNameScrollbar + _strSpace + scrollbarClassName, true);
                    var track = selectOrGenerateDivByClass(_classNameScrollbarTrack, scrollbar);
                    var handle = selectOrGenerateDivByClass(_classNameScrollbarHandle, scrollbar);

                    if (!_domExists && !destroy) {
                        scrollbar.append(track);
                        track.append(handle);
                    }

                    return {
                        _scrollbar: scrollbar,
                        _track: track,
                        _handle: handle
                    };
                };

                function resetScrollbarDOM(isHorizontal) {
                    var scrollbarVars = getScrollbarVars(isHorizontal);
                    var scrollbar = scrollbarVars._scrollbar;
                    var track = scrollbarVars._track;
                    var handle = scrollbarVars._handle;

                    if (_domExists && _initialized) {
                        each([scrollbar, track, handle], function(i, elm) {
                            removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                        });
                    } else {
                        remove(scrollbar || selectOrGenerateScrollbarDOM(isHorizontal)._scrollbar);
                    }
                }

                var horizontalElements;
                var verticalElements;

                if (!destroy) {
                    horizontalElements = selectOrGenerateScrollbarDOM(true);
                    verticalElements = selectOrGenerateScrollbarDOM();
                    _scrollbarHorizontalElement = horizontalElements._scrollbar;
                    _scrollbarHorizontalTrackElement = horizontalElements._track;
                    _scrollbarHorizontalHandleElement = horizontalElements._handle;
                    _scrollbarVerticalElement = verticalElements._scrollbar;
                    _scrollbarVerticalTrackElement = verticalElements._track;
                    _scrollbarVerticalHandleElement = verticalElements._handle;

                    if (!_domExists) {
                        _paddingElement.after(_scrollbarVerticalElement);

                        _paddingElement.after(_scrollbarHorizontalElement);
                    }
                } else {
                    resetScrollbarDOM(true);
                    resetScrollbarDOM();
                }
            }
            /**
             * Initializes all scrollbar interactivity events. (track and handle dragging, clicking, scrolling)
             * @param isHorizontal True if the target scrollbar is the horizontal scrollbar, false if the target scrollbar is the vertical scrollbar.
             */

            function setupScrollbarEvents(isHorizontal) {
                var scrollbarVars = getScrollbarVars(isHorizontal);
                var scrollbarVarsInfo = scrollbarVars._info;
                var insideIFrame = _windowElementNative.top !== _windowElementNative;
                var xy = scrollbarVars._x_y;
                var XY = scrollbarVars._X_Y;
                var scroll = _strScroll + scrollbarVars._Left_Top;
                var strActive = 'active';
                var strSnapHandle = 'snapHandle';
                var scrollDurationFactor = 1;
                var increaseDecreaseScrollAmountKeyCodes = [16, 17]; //shift, ctrl

                var trackTimeout;
                var mouseDownScroll;
                var mouseDownOffset;
                var mouseDownInvertedScale;

                function getPointerPosition(event) {
                    return _msieVersion && insideIFrame ? event['screen' + XY] : COMPATIBILITY.page(event)[xy]; //use screen coordinates in EDGE & IE because the page values are incorrect in frames.
                }

                function getPreparedScrollbarsOption(name) {
                    return _currentPreparedOptions.scrollbars[name];
                }

                function increaseTrackScrollAmount() {
                    scrollDurationFactor = 0.5;
                }

                function decreaseTrackScrollAmount() {
                    scrollDurationFactor = 1;
                }

                function documentKeyDown(event) {
                    if (inArray(event.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1) increaseTrackScrollAmount();
                }

                function documentKeyUp(event) {
                    if (inArray(event.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1) decreaseTrackScrollAmount();
                }

                function onMouseTouchDownContinue(event) {
                    var originalEvent = event.originalEvent || event;
                    var isTouchEvent = originalEvent.touches !== undefined;
                    return _sleeping ||
                        _destroyed ||
                        nativeOverlayScrollbarsAreActive() ||
                        !_scrollbarsDragScrollingCache ||
                        (isTouchEvent && !getPreparedScrollbarsOption('touchSupport'))
                        ? false
                        : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;
                }

                function documentDragMove(event) {
                    if (onMouseTouchDownContinue(event)) {
                        var trackLength = scrollbarVarsInfo._trackLength;
                        var handleLength = scrollbarVarsInfo._handleLength;
                        var scrollRange = scrollbarVarsInfo._maxScroll;
                        var scrollRaw = (getPointerPosition(event) - mouseDownOffset) * mouseDownInvertedScale;
                        var scrollDeltaPercent = scrollRaw / (trackLength - handleLength);
                        var scrollDelta = scrollRange * scrollDeltaPercent;
                        scrollDelta = isFinite(scrollDelta) ? scrollDelta : 0;
                        if (_isRTL && isHorizontal && !_rtlScrollBehavior.i) scrollDelta *= -1;

                        _viewportElement[scroll](MATH.round(mouseDownScroll + scrollDelta));

                        if (_scrollbarsHandlesDefineScrollPos) refreshScrollbarHandleOffset(isHorizontal, mouseDownScroll + scrollDelta);
                        if (!_supportPassiveEvents) COMPATIBILITY.prvD(event);
                    } else documentMouseTouchUp(event);
                }

                function documentMouseTouchUp(event) {
                    event = event || event.originalEvent;
                    setupResponsiveEventListener(
                        _documentElement,
                        [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent],
                        [documentDragMove, documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart],
                        true
                    );
                    if (_scrollbarsHandlesDefineScrollPos) refreshScrollbarHandleOffset(isHorizontal, true);
                    _scrollbarsHandlesDefineScrollPos = false;
                    removeClass(_bodyElement, _classNameDragging);
                    removeClass(scrollbarVars._handle, strActive);
                    removeClass(scrollbarVars._track, strActive);
                    removeClass(scrollbarVars._scrollbar, strActive);
                    mouseDownScroll = undefined;
                    mouseDownOffset = undefined;
                    mouseDownInvertedScale = 1;
                    decreaseTrackScrollAmount();

                    if (trackTimeout !== undefined) {
                        _base.scrollStop();

                        clearTimeout(trackTimeout);
                        trackTimeout = undefined;
                    }

                    if (event) {
                        var rect = _hostElementNative[LEXICON.bCR]();

                        var mouseInsideHost = event.clientX >= rect.left && event.clientX <= rect.right && event.clientY >= rect.top && event.clientY <= rect.bottom; //if mouse is outside host element

                        if (!mouseInsideHost) hostOnMouseLeave();
                        if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove) refreshScrollbarsAutoHide(false);
                    }
                }

                function onHandleMouseTouchDown(event) {
                    if (onMouseTouchDownContinue(event)) onHandleMouseTouchDownAction(event);
                }

                function onHandleMouseTouchDownAction(event) {
                    mouseDownScroll = _viewportElement[scroll]();
                    mouseDownScroll = isNaN(mouseDownScroll) ? 0 : mouseDownScroll;
                    if ((_isRTL && isHorizontal && !_rtlScrollBehavior.n) || !_isRTL) mouseDownScroll = mouseDownScroll < 0 ? 0 : mouseDownScroll;
                    mouseDownInvertedScale = getHostElementInvertedScale()[xy];
                    mouseDownOffset = getPointerPosition(event);
                    _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);
                    addClass(_bodyElement, _classNameDragging);
                    addClass(scrollbarVars._handle, strActive);
                    addClass(scrollbarVars._scrollbar, strActive);
                    setupResponsiveEventListener(
                        _documentElement,
                        [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strSelectStartEvent],
                        [documentDragMove, documentMouseTouchUp, documentOnSelectStart]
                    );
                    if (_msieVersion || !_documentMixed) COMPATIBILITY.prvD(event);
                    COMPATIBILITY.stpP(event);
                }

                function onTrackMouseTouchDown(event) {
                    if (onMouseTouchDownContinue(event)) {
                        var scrollDistance = MATH.round(_viewportSize[scrollbarVars._w_h]);

                        var trackOffset = scrollbarVars._track.offset()[scrollbarVars._left_top];

                        var ctrlKey = event.ctrlKey;
                        var instantScroll = event.shiftKey;
                        var instantScrollTransition = instantScroll && ctrlKey;
                        var isFirstIteration = true;
                        var easing = 'linear';
                        var decreaseScroll;
                        var finishedCondition;

                        var scrollActionFinsished = function scrollActionFinsished(transition) {
                            if (_scrollbarsHandlesDefineScrollPos) refreshScrollbarHandleOffset(isHorizontal, transition);
                        };

                        var scrollActionInstantFinished = function scrollActionInstantFinished() {
                            scrollActionFinsished();
                            onHandleMouseTouchDownAction(event);
                        };

                        var scrollAction = function scrollAction() {
                            if (!_destroyed) {
                                var mouseOffset = (mouseDownOffset - trackOffset) * mouseDownInvertedScale;
                                var handleOffset = scrollbarVarsInfo._handleOffset;
                                var trackLength = scrollbarVarsInfo._trackLength;
                                var handleLength = scrollbarVarsInfo._handleLength;
                                var scrollRange = scrollbarVarsInfo._maxScroll;
                                var currScroll = scrollbarVarsInfo._currentScroll;
                                var scrollDuration = 270 * scrollDurationFactor;
                                var timeoutDelay = isFirstIteration ? MATH.max(400, scrollDuration) : scrollDuration;
                                var instantScrollPosition = scrollRange * ((mouseOffset - handleLength / 2) / (trackLength - handleLength)); // 100% * positionPercent

                                var rtlIsNormal = _isRTL && isHorizontal && ((!_rtlScrollBehavior.i && !_rtlScrollBehavior.n) || _normalizeRTLCache);
                                var decreaseScrollCondition = rtlIsNormal ? handleOffset < mouseOffset : handleOffset > mouseOffset;
                                var scrollObj = {};
                                var animationObj = {
                                    easing: easing,
                                    step: function step(now) {
                                        if (_scrollbarsHandlesDefineScrollPos) {
                                            _viewportElement[scroll](now); //https://github.com/jquery/jquery/issues/4340

                                            refreshScrollbarHandleOffset(isHorizontal, now);
                                        }
                                    }
                                };
                                instantScrollPosition = isFinite(instantScrollPosition) ? instantScrollPosition : 0;
                                instantScrollPosition = _isRTL && isHorizontal && !_rtlScrollBehavior.i ? scrollRange - instantScrollPosition : instantScrollPosition; //_base.scrollStop();

                                if (instantScroll) {
                                    _viewportElement[scroll](instantScrollPosition); //scroll instantly to new position

                                    if (instantScrollTransition) {
                                        //get the scroll position after instant scroll (in case CSS Snap Points are used) to get the correct snapped scroll position
                                        //and the animation stops at the correct point
                                        instantScrollPosition = _viewportElement[scroll](); //scroll back to the position before instant scrolling so animation can be performed

                                        _viewportElement[scroll](currScroll);

                                        instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.i ? scrollRange - instantScrollPosition : instantScrollPosition;
                                        instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.n ? -instantScrollPosition : instantScrollPosition;
                                        scrollObj[xy] = instantScrollPosition;

                                        _base.scroll(
                                            scrollObj,
                                            extendDeep(animationObj, {
                                                duration: 130,
                                                complete: scrollActionInstantFinished
                                            })
                                        );
                                    } else scrollActionInstantFinished();
                                } else {
                                    decreaseScroll = isFirstIteration ? decreaseScrollCondition : decreaseScroll;
                                    finishedCondition = rtlIsNormal
                                        ? decreaseScroll
                                            ? handleOffset + handleLength >= mouseOffset
                                            : handleOffset <= mouseOffset
                                        : decreaseScroll
                                        ? handleOffset <= mouseOffset
                                        : handleOffset + handleLength >= mouseOffset;

                                    if (finishedCondition) {
                                        clearTimeout(trackTimeout);

                                        _base.scrollStop();

                                        trackTimeout = undefined;
                                        scrollActionFinsished(true);
                                    } else {
                                        trackTimeout = setTimeout(scrollAction, timeoutDelay);
                                        scrollObj[xy] = (decreaseScroll ? '-=' : '+=') + scrollDistance;

                                        _base.scroll(
                                            scrollObj,
                                            extendDeep(animationObj, {
                                                duration: scrollDuration
                                            })
                                        );
                                    }

                                    isFirstIteration = false;
                                }
                            }
                        };

                        if (ctrlKey) increaseTrackScrollAmount();
                        mouseDownInvertedScale = getHostElementInvertedScale()[xy];
                        mouseDownOffset = COMPATIBILITY.page(event)[xy];
                        _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);
                        addClass(_bodyElement, _classNameDragging);
                        addClass(scrollbarVars._track, strActive);
                        addClass(scrollbarVars._scrollbar, strActive);
                        setupResponsiveEventListener(
                            _documentElement,
                            [_strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent],
                            [documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart]
                        );
                        scrollAction();
                        COMPATIBILITY.prvD(event);
                        COMPATIBILITY.stpP(event);
                    }
                }

                function onTrackMouseTouchEnter(event) {
                    //make sure both scrollbars will stay visible if one scrollbar is hovered if autoHide is "scroll" or "move".
                    _scrollbarsHandleHovered = true;
                    if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove) refreshScrollbarsAutoHide(true);
                }

                function onTrackMouseTouchLeave(event) {
                    _scrollbarsHandleHovered = false;
                    if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove) refreshScrollbarsAutoHide(false);
                }

                function onScrollbarMouseTouchDown(event) {
                    COMPATIBILITY.stpP(event);
                }

                addDestroyEventListener(scrollbarVars._handle, _strMouseTouchDownEvent, onHandleMouseTouchDown);
                addDestroyEventListener(
                    scrollbarVars._track,
                    [_strMouseTouchDownEvent, _strMouseTouchEnter, _strMouseTouchLeave],
                    [onTrackMouseTouchDown, onTrackMouseTouchEnter, onTrackMouseTouchLeave]
                );
                addDestroyEventListener(scrollbarVars._scrollbar, _strMouseTouchDownEvent, onScrollbarMouseTouchDown);

                if (_supportTransition) {
                    addDestroyEventListener(scrollbarVars._scrollbar, _strTransitionEndEvent, function(event) {
                        if (event.target !== scrollbarVars._scrollbar[0]) return;
                        refreshScrollbarHandleLength(isHorizontal);
                        refreshScrollbarHandleOffset(isHorizontal);
                    });
                }
            }
            /**
             * Shows or hides the given scrollbar and applied a class name which indicates if the scrollbar is scrollable or not.
             * @param isHorizontal True if the horizontal scrollbar is the target, false if the vertical scrollbar is the target.
             * @param shallBeVisible True if the scrollbar shall be shown, false if hidden.
             * @param canScroll True if the scrollbar is scrollable, false otherwise.
             */

            function refreshScrollbarAppearance(isHorizontal, shallBeVisible, canScroll) {
                var scrollbarClassName = isHorizontal ? _classNameHostScrollbarHorizontalHidden : _classNameHostScrollbarVerticalHidden;
                var scrollbarElement = isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement;
                if (shallBeVisible) removeClass(_hostElement, scrollbarClassName);
                else addClass(_hostElement, scrollbarClassName);
                if (canScroll) removeClass(scrollbarElement, _classNameScrollbarUnusable);
                else addClass(scrollbarElement, _classNameScrollbarUnusable);
            }
            /**
             * Autoshows / autohides both scrollbars with.
             * @param shallBeVisible True if the scrollbars shall be autoshown (only the case if they are hidden by a autohide), false if the shall be auto hidden.
             * @param delayfree True if the scrollbars shall be hidden without a delay, false or undefined otherwise.
             */

            function refreshScrollbarsAutoHide(shallBeVisible, delayfree) {
                clearTimeout(_scrollbarsAutoHideTimeoutId);

                if (shallBeVisible) {
                    //if(_hasOverflowCache.x && _hideOverflowCache.xs)
                    removeClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden); //if(_hasOverflowCache.y && _hideOverflowCache.ys)

                    removeClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);
                } else {
                    var anyActive;
                    var strActive = 'active';

                    var hide = function hide() {
                        if (!_scrollbarsHandleHovered && !_destroyed) {
                            anyActive = _scrollbarHorizontalHandleElement.hasClass(strActive) || _scrollbarVerticalHandleElement.hasClass(strActive);
                            if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave))
                                addClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden);
                            if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave))
                                addClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);
                        }
                    };

                    if (_scrollbarsAutoHideDelay > 0 && delayfree !== true) _scrollbarsAutoHideTimeoutId = setTimeout(hide, _scrollbarsAutoHideDelay);
                    else hide();
                }
            }
            /**
             * Refreshes the handle length of the given scrollbar.
             * @param isHorizontal True if the horizontal scrollbar handle shall be refreshed, false if the vertical one shall be refreshed.
             */

            function refreshScrollbarHandleLength(isHorizontal) {
                var handleCSS = {};
                var scrollbarVars = getScrollbarVars(isHorizontal);
                var scrollbarVarsInfo = scrollbarVars._info;
                var digit = 1000000; //get and apply intended handle length

                var handleRatio = MATH.min(
                    1,
                    (_hostSizeCache[scrollbarVars._w_h] - (_paddingAbsoluteCache ? (isHorizontal ? _paddingX : _paddingY) : 0)) / _contentScrollSizeCache[scrollbarVars._w_h]
                );
                handleCSS[scrollbarVars._width_height] = MATH.floor(handleRatio * 100 * digit) / digit + '%'; //the last * digit / digit is for flooring to the 4th digit

                if (!nativeOverlayScrollbarsAreActive()) scrollbarVars._handle.css(handleCSS); //measure the handle length to respect min & max length

                scrollbarVarsInfo._handleLength = scrollbarVars._handle[0]['offset' + scrollbarVars._Width_Height];
                scrollbarVarsInfo._handleLengthRatio = handleRatio;
            }
            /**
             * Refreshes the handle offset of the given scrollbar.
             * @param isHorizontal True if the horizontal scrollbar handle shall be refreshed, false if the vertical one shall be refreshed.
             * @param scrollOrTransition The scroll position of the given scrollbar axis to which the handle shall be moved or a boolean which indicates whether a transition shall be applied. If undefined or boolean if the current scroll-offset is taken. (if isHorizontal ? scrollLeft : scrollTop)
             */

            function refreshScrollbarHandleOffset(isHorizontal, scrollOrTransition) {
                var transition = type(scrollOrTransition) == TYPES.b;
                var transitionDuration = 250;
                var isRTLisHorizontal = _isRTL && isHorizontal;
                var scrollbarVars = getScrollbarVars(isHorizontal);
                var scrollbarVarsInfo = scrollbarVars._info;
                var strTranslateBrace = 'translate(';

                var strTransform = VENDORS._cssProperty('transform');

                var strTransition = VENDORS._cssProperty('transition');

                var nativeScroll = isHorizontal ? _viewportElement[_strScrollLeft]() : _viewportElement[_strScrollTop]();
                var currentScroll = scrollOrTransition === undefined || transition ? nativeScroll : scrollOrTransition; //measure the handle length to respect min & max length

                var handleLength = scrollbarVarsInfo._handleLength;
                var trackLength = scrollbarVars._track[0]['offset' + scrollbarVars._Width_Height];
                var handleTrackDiff = trackLength - handleLength;
                var handleCSS = {};
                var transformOffset;
                var translateValue; //DONT use the variable '_contentScrollSizeCache[scrollbarVars._w_h]' instead of '_viewportElement[0]['scroll' + scrollbarVars._Width_Height]'
                // because its a bit behind during the small delay when content size updates
                //(delay = mutationObserverContentLag, if its 0 then this var could be used)

                var maxScroll =
                    (_viewportElementNative[_strScroll + scrollbarVars._Width_Height] - _viewportElementNative['client' + scrollbarVars._Width_Height]) *
                    (_rtlScrollBehavior.n && isRTLisHorizontal ? -1 : 1); //* -1 if rtl scroll max is negative

                var getScrollRatio = function getScrollRatio(base) {
                    return isNaN(base / maxScroll) ? 0 : MATH.max(0, MATH.min(1, base / maxScroll));
                };

                var getHandleOffset = function getHandleOffset(scrollRatio) {
                    var offset = handleTrackDiff * scrollRatio;
                    offset = isNaN(offset) ? 0 : offset;
                    offset = isRTLisHorizontal && !_rtlScrollBehavior.i ? trackLength - handleLength - offset : offset;
                    offset = MATH.max(0, offset);
                    return offset;
                };

                var scrollRatio = getScrollRatio(nativeScroll);
                var unsnappedScrollRatio = getScrollRatio(currentScroll);
                var handleOffset = getHandleOffset(unsnappedScrollRatio);
                var snappedHandleOffset = getHandleOffset(scrollRatio);
                scrollbarVarsInfo._maxScroll = maxScroll;
                scrollbarVarsInfo._currentScroll = nativeScroll;
                scrollbarVarsInfo._currentScrollRatio = scrollRatio;

                if (_supportTransform) {
                    transformOffset = isRTLisHorizontal ? -(trackLength - handleLength - handleOffset) : handleOffset; //in px
                    //transformOffset = (transformOffset / trackLength * 100) * (trackLength / handleLength); //in %

                    translateValue = isHorizontal ? strTranslateBrace + transformOffset + 'px, 0)' : strTranslateBrace + '0, ' + transformOffset + 'px)';
                    handleCSS[strTransform] = translateValue; //apply or clear up transition

                    if (_supportTransition)
                        handleCSS[strTransition] =
                            transition && MATH.abs(handleOffset - scrollbarVarsInfo._handleOffset) > 1
                                ? getCSSTransitionString(scrollbarVars._handle) + ', ' + (strTransform + _strSpace + transitionDuration + 'ms')
                                : _strEmpty;
                } else handleCSS[scrollbarVars._left_top] = handleOffset; //only apply css if offset has changed and overflow exists.

                if (!nativeOverlayScrollbarsAreActive()) {
                    scrollbarVars._handle.css(handleCSS); //clear up transition

                    if (_supportTransform && _supportTransition && transition) {
                        scrollbarVars._handle.one(_strTransitionEndEvent, function() {
                            if (!_destroyed) scrollbarVars._handle.css(strTransition, _strEmpty);
                        });
                    }
                }

                scrollbarVarsInfo._handleOffset = handleOffset;
                scrollbarVarsInfo._snappedHandleOffset = snappedHandleOffset;
                scrollbarVarsInfo._trackLength = trackLength;
            }
            /**
             * Refreshes the interactivity of the given scrollbar element.
             * @param isTrack True if the track element is the target, false if the handle element is the target.
             * @param value True for interactivity false for no interactivity.
             */

            function refreshScrollbarsInteractive(isTrack, value) {
                var action = value ? 'removeClass' : 'addClass';
                var element1 = isTrack ? _scrollbarHorizontalTrackElement : _scrollbarHorizontalHandleElement;
                var element2 = isTrack ? _scrollbarVerticalTrackElement : _scrollbarVerticalHandleElement;
                var className = isTrack ? _classNameScrollbarTrackOff : _classNameScrollbarHandleOff;
                element1[action](className);
                element2[action](className);
            }
            /**
             * Returns a object which is used for fast access for specific variables.
             * @param isHorizontal True if the horizontal scrollbar vars shall be accessed, false if the vertical scrollbar vars shall be accessed.
             * @returns {{wh: string, WH: string, lt: string, _wh: string, _lt: string, t: *, h: *, c: {}, s: *}}
             */

            function getScrollbarVars(isHorizontal) {
                return {
                    _width_height: isHorizontal ? _strWidth : _strHeight,
                    _Width_Height: isHorizontal ? 'Width' : 'Height',
                    _left_top: isHorizontal ? _strLeft : _strTop,
                    _Left_Top: isHorizontal ? 'Left' : 'Top',
                    _x_y: isHorizontal ? _strX : _strY,
                    _X_Y: isHorizontal ? 'X' : 'Y',
                    _w_h: isHorizontal ? 'w' : 'h',
                    _l_t: isHorizontal ? 'l' : 't',
                    _track: isHorizontal ? _scrollbarHorizontalTrackElement : _scrollbarVerticalTrackElement,
                    _handle: isHorizontal ? _scrollbarHorizontalHandleElement : _scrollbarVerticalHandleElement,
                    _scrollbar: isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement,
                    _info: isHorizontal ? _scrollHorizontalInfo : _scrollVerticalInfo
                };
            } //==== Scrollbar Corner ====//

            /**
             * Builds or destroys the scrollbar corner DOM element.
             * @param destroy Indicates whether the DOM shall be build or destroyed.
             */

            function setupScrollbarCornerDOM(destroy) {
                _scrollbarCornerElement = _scrollbarCornerElement || selectOrGenerateDivByClass(_classNameScrollbarCorner, true);

                if (!destroy) {
                    if (!_domExists) {
                        _hostElement.append(_scrollbarCornerElement);
                    }
                } else {
                    if (_domExists && _initialized) {
                        removeClass(_scrollbarCornerElement.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                    } else {
                        remove(_scrollbarCornerElement);
                    }
                }
            }
            /**
             * Initializes all scrollbar corner interactivity events.
             */

            function setupScrollbarCornerEvents() {
                var insideIFrame = _windowElementNative.top !== _windowElementNative;
                var mouseDownPosition = {};
                var mouseDownSize = {};
                var mouseDownInvertedScale = {};
                var reconnectMutationObserver;

                function documentDragMove(event) {
                    if (onMouseTouchDownContinue(event)) {
                        var pageOffset = getCoordinates(event);
                        var hostElementCSS = {};
                        if (_resizeHorizontal || _resizeBoth) hostElementCSS[_strWidth] = mouseDownSize.w + (pageOffset.x - mouseDownPosition.x) * mouseDownInvertedScale.x;
                        if (_resizeVertical || _resizeBoth) hostElementCSS[_strHeight] = mouseDownSize.h + (pageOffset.y - mouseDownPosition.y) * mouseDownInvertedScale.y;

                        _hostElement.css(hostElementCSS);

                        COMPATIBILITY.stpP(event);
                    } else {
                        documentMouseTouchUp(event);
                    }
                }

                function documentMouseTouchUp(event) {
                    var eventIsTrusted = event !== undefined;
                    setupResponsiveEventListener(
                        _documentElement,
                        [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent],
                        [documentOnSelectStart, documentDragMove, documentMouseTouchUp],
                        true
                    );
                    removeClass(_bodyElement, _classNameDragging);
                    if (_scrollbarCornerElement.releaseCapture) _scrollbarCornerElement.releaseCapture();

                    if (eventIsTrusted) {
                        if (reconnectMutationObserver) connectMutationObservers();

                        _base.update(_strAuto);
                    }

                    reconnectMutationObserver = false;
                }

                function onMouseTouchDownContinue(event) {
                    var originalEvent = event.originalEvent || event;
                    var isTouchEvent = originalEvent.touches !== undefined;
                    return _sleeping || _destroyed ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;
                }

                function getCoordinates(event) {
                    return _msieVersion && insideIFrame
                        ? {
                              x: event.screenX,
                              y: event.screenY
                          }
                        : COMPATIBILITY.page(event);
                }

                addDestroyEventListener(_scrollbarCornerElement, _strMouseTouchDownEvent, function(event) {
                    if (onMouseTouchDownContinue(event) && !_resizeNone) {
                        if (_mutationObserversConnected) {
                            reconnectMutationObserver = true;
                            disconnectMutationObservers();
                        }

                        mouseDownPosition = getCoordinates(event);
                        mouseDownSize.w = _hostElementNative[LEXICON.oW] - (!_isBorderBox ? _paddingX : 0);
                        mouseDownSize.h = _hostElementNative[LEXICON.oH] - (!_isBorderBox ? _paddingY : 0);
                        mouseDownInvertedScale = getHostElementInvertedScale();
                        setupResponsiveEventListener(
                            _documentElement,
                            [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent],
                            [documentOnSelectStart, documentDragMove, documentMouseTouchUp]
                        );
                        addClass(_bodyElement, _classNameDragging);
                        if (_scrollbarCornerElement.setCapture) _scrollbarCornerElement.setCapture();
                        COMPATIBILITY.prvD(event);
                        COMPATIBILITY.stpP(event);
                    }
                });
            } //==== Utils ====//

            /**
             * Calls the callback with the given name. The Context of this callback is always _base (this).
             * @param name The name of the target which shall be called.
             * @param args The args with which the callback shall be called.
             */

            function dispatchCallback(name, args) {
                if (_initialized) {
                    var callback = _currentPreparedOptions.callbacks[name];
                    var extensionOnName = name;
                    var ext;
                    if (extensionOnName.substr(0, 2) === 'on') extensionOnName = extensionOnName.substr(2, 1).toLowerCase() + extensionOnName.substr(3);
                    if (type(callback) == TYPES.f) callback.call(_base, args);
                    each(_extensions, function() {
                        ext = this;
                        if (type(ext.on) == TYPES.f) ext.on(extensionOnName, args);
                    });
                } else if (!_destroyed)
                    _callbacksInitQeueue.push({
                        n: name,
                        a: args
                    });
            }
            /**
             * Sets the "top, right, bottom, left" properties, with a given prefix, of the given css object.
             * @param targetCSSObject The css object to which the values shall be applied.
             * @param prefix The prefix of the "top, right, bottom, left" css properties. (example: 'padding-' is a valid prefix)
             * @param values A array of values which shall be applied to the "top, right, bottom, left" -properties. The array order is [top, right, bottom, left].
             * If this argument is undefined the value '' (empty string) will be applied to all properties.
             */

            function setTopRightBottomLeft(targetCSSObject, prefix, values) {
                if (values === undefined) values = [_strEmpty, _strEmpty, _strEmpty, _strEmpty];
                targetCSSObject[prefix + _strTop] = values[0];
                targetCSSObject[prefix + _strRight] = values[1];
                targetCSSObject[prefix + _strBottom] = values[2];
                targetCSSObject[prefix + _strLeft] = values[3];
            }
            /**
             * Returns the computed CSS transition string from the given element.
             * @param element The element from which the transition string shall be returned.
             * @returns {string} The CSS transition string from the given element.
             */

            function getCSSTransitionString(element) {
                var transitionStr = VENDORS._cssProperty('transition');

                var assembledValue = element.css(transitionStr);
                if (assembledValue) return assembledValue;
                var regExpString = '\\s*(' + '([^,(]+(\\(.+?\\))?)+' + ')[\\s,]*';
                var regExpMain = new RegExp(regExpString);
                var regExpValidate = new RegExp('^(' + regExpString + ')+$');
                var properties = 'property duration timing-function delay'.split(' ');
                var result = [];
                var strResult;
                var valueArray;
                var i = 0;
                var j;

                var splitCssStyleByComma = function splitCssStyleByComma(str) {
                    strResult = [];
                    if (!str.match(regExpValidate)) return str;

                    while (str.match(regExpMain)) {
                        strResult.push(RegExp.$1);
                        str = str.replace(regExpMain, _strEmpty);
                    }

                    return strResult;
                };

                for (; i < properties[LEXICON.l]; i++) {
                    valueArray = splitCssStyleByComma(element.css(transitionStr + '-' + properties[i]));

                    for (j = 0; j < valueArray[LEXICON.l]; j++) {
                        result[j] = (result[j] ? result[j] + _strSpace : _strEmpty) + valueArray[j];
                    }
                }

                return result.join(', ');
            }
            /**
             * Calculates the host-elements inverted scale. (invertedScale = 1 / scale)
             * @returns {{x: number, y: number}} The scale of the host-element.
             */

            function getHostElementInvertedScale() {
                var rect = _paddingElementNative[LEXICON.bCR]();

                return {
                    x: _supportTransform ? 1 / (MATH.round(rect.width) / _paddingElementNative[LEXICON.oW]) || 1 : 1,
                    y: _supportTransform ? 1 / (MATH.round(rect.height) / _paddingElementNative[LEXICON.oH]) || 1 : 1
                };
            }
            /**
             * Checks whether the given object is a HTMLElement.
             * @param o The object which shall be checked.
             * @returns {boolean} True the given object is a HTMLElement, false otherwise.
             */

            function isHTMLElement(o) {
                var strOwnerDocument = 'ownerDocument';
                var strHTMLElement = 'HTMLElement';
                var wnd = o && o[strOwnerDocument] ? o[strOwnerDocument].parentWindow || window : window;
                return _typeof(wnd[strHTMLElement]) == TYPES.o
                    ? _instanceof(o, wnd[strHTMLElement]) //DOM2
                    : o && _typeof(o) == TYPES.o && o !== null && o.nodeType === 1 && _typeof(o.nodeName) == TYPES.s;
            }
            /**
             * Compares 2 arrays and returns the differences between them as a array.
             * @param a1 The first array which shall be compared.
             * @param a2 The second array which shall be compared.
             * @returns {Array} The differences between the two arrays.
             */

            function getArrayDifferences(a1, a2) {
                var a = [];
                var diff = [];
                var i;
                var k;

                for (i = 0; i < a1.length; i++) {
                    a[a1[i]] = true;
                }

                for (i = 0; i < a2.length; i++) {
                    if (a[a2[i]]) delete a[a2[i]];
                    else a[a2[i]] = true;
                }

                for (k in a) {
                    diff.push(k);
                }

                return diff;
            }
            /**
             * Returns Zero or the number to which the value can be parsed.
             * @param value The value which shall be parsed.
             * @param toFloat Indicates whether the number shall be parsed to a float.
             */

            function parseToZeroOrNumber(value, toFloat) {
                var num = toFloat ? parseFloat(value) : parseInt(value, 10);
                return isNaN(num) ? 0 : num;
            }
            /**
             * Gets several information of the textarea and returns them as a object or undefined if the browser doesn't support it.
             * @returns {{cursorRow: Number, cursorCol, rows: Number, cols: number, wRow: number, pos: number, max : number}} or undefined if not supported.
             */

            function getTextareaInfo() {
                //read needed values
                var textareaCursorPosition = _targetElementNative.selectionStart;
                if (textareaCursorPosition === undefined) return;

                var textareaValue = _targetElement.val();

                var textareaLength = textareaValue[LEXICON.l];
                var textareaRowSplit = textareaValue.split('\n');
                var textareaLastRow = textareaRowSplit[LEXICON.l];
                var textareaCurrentCursorRowSplit = textareaValue.substr(0, textareaCursorPosition).split('\n');
                var widestRow = 0;
                var textareaLastCol = 0;
                var cursorRow = textareaCurrentCursorRowSplit[LEXICON.l];
                var cursorCol = textareaCurrentCursorRowSplit[textareaCurrentCursorRowSplit[LEXICON.l] - 1][LEXICON.l];
                var rowCols;
                var i; //get widest Row and the last column of the textarea

                for (i = 0; i < textareaRowSplit[LEXICON.l]; i++) {
                    rowCols = textareaRowSplit[i][LEXICON.l];

                    if (rowCols > textareaLastCol) {
                        widestRow = i + 1;
                        textareaLastCol = rowCols;
                    }
                }

                return {
                    _cursorRow: cursorRow,
                    //cursorRow
                    _cursorColumn: cursorCol,
                    //cursorCol
                    _rows: textareaLastRow,
                    //rows
                    _columns: textareaLastCol,
                    //cols
                    _widestRow: widestRow,
                    //wRow
                    _cursorPosition: textareaCursorPosition,
                    //pos
                    _cursorMax: textareaLength //max
                };
            }
            /**
             * Determines whether native overlay scrollbars are active.
             * @returns {boolean} True if native overlay scrollbars are active, false otherwise.
             */

            function nativeOverlayScrollbarsAreActive() {
                return _ignoreOverlayScrollbarHidingCache && _nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y;
            }
            /**
             * Gets the element which is used to measure the content size.
             * @returns {*} TextareaCover if target element is textarea else the ContentElement.
             */

            function getContentMeasureElement() {
                return _isTextarea ? _textareaCoverElement[0] : _contentElementNative;
            }
            /**
             * Generates a string which represents a HTML div with the given classes or attributes.
             * @param classesOrAttrs The class of the div as string or a object which represents the attributes of the div. (The class attribute can also be written as "className".)
             * @param content The content of the div as string.
             * @returns {string} The concated string which represents a HTML div and its content.
             */

            function generateDiv(classesOrAttrs, content) {
                return (
                    '<div ' +
                    (classesOrAttrs
                        ? type(classesOrAttrs) == TYPES.s
                            ? 'class="' + classesOrAttrs + '"'
                            : (function() {
                                  var key;
                                  var attrs = _strEmpty;

                                  if (FRAMEWORK.isPlainObject(classesOrAttrs)) {
                                      for (key in classesOrAttrs) {
                                          attrs += (key === 'c' ? 'class' : key) + '="' + classesOrAttrs[key] + '" ';
                                      }
                                  }

                                  return attrs;
                              })()
                        : _strEmpty) +
                    '>' +
                    (content || _strEmpty) +
                    '</div>'
                );
            }
            /**
             * Selects or generates a div with the given class attribute.
             * @param className The class names (divided by spaces) of the div which shall be selected or generated.
             * @param selectParentOrOnlyChildren The parent element from which of the element shall be selected. (if undefined or boolean its hostElement)
             * If its a boolean it decides whether only the children of the host element shall be selected.
             * @returns {*} The generated or selected element.
             */

            function selectOrGenerateDivByClass(className, selectParentOrOnlyChildren) {
                var onlyChildren = type(selectParentOrOnlyChildren) == TYPES.b;
                var selectParent = onlyChildren ? _hostElement : selectParentOrOnlyChildren || _hostElement;
                return _domExists && !selectParent[LEXICON.l]
                    ? null
                    : _domExists
                    ? selectParent[onlyChildren ? 'children' : 'find'](_strDot + className.replace(/\s/g, _strDot)).eq(0)
                    : FRAMEWORK(generateDiv(className));
            }
            /**
             * Gets the value of the given property from the given object.
             * @param obj The object from which the property value shall be got.
             * @param path The property of which the value shall be got.
             * @returns {*} Returns the value of the searched property or undefined of the property wasn't found.
             */

            function getObjectPropVal(obj, path) {
                var splits = path.split(_strDot);
                var i = 0;
                var val;

                for (; i < splits.length; i++) {
                    if (!obj[LEXICON.hOP](splits[i])) return;
                    val = obj[splits[i]];
                    if (i < splits.length && type(val) == TYPES.o) obj = val;
                }

                return val;
            }
            /**
             * Sets the value of the given property from the given object.
             * @param obj The object from which the property value shall be set.
             * @param path The property of which the value shall be set.
             * @param val The value of the property which shall be set.
             */

            function setObjectPropVal(obj, path, val) {
                var splits = path.split(_strDot);
                var splitsLength = splits.length;
                var i = 0;
                var extendObj = {};
                var extendObjRoot = extendObj;

                for (; i < splitsLength; i++) {
                    extendObj = extendObj[splits[i]] = i + 1 < splitsLength ? {} : val;
                }

                FRAMEWORK.extend(obj, extendObjRoot, true);
            } //==== Utils Cache ====//

            /**
             * Compares two values or objects and returns true if they aren't equal.
             * @param current The first value or object which shall be compared.
             * @param cache The second value or object which shall be compared.
             * @param force If true the returned value is always true.
             * @returns {boolean} True if both values or objects aren't equal or force is true, false otherwise.
             */

            function checkCache(current, cache, force) {
                if (force) return force;

                if (type(current) == TYPES.o && type(cache) == TYPES.o) {
                    for (var prop in current) {
                        if (prop !== 'c') {
                            if (current[LEXICON.hOP](prop) && cache[LEXICON.hOP](prop)) {
                                if (checkCache(current[prop], cache[prop])) return true;
                            } else {
                                return true;
                            }
                        }
                    }
                } else {
                    return current !== cache;
                }

                return false;
            } //==== Shortcuts ====//

            /**
             * jQuery extend method shortcut with a appended "true" as first argument.
             */

            function extendDeep() {
                return FRAMEWORK.extend.apply(this, [true].concat([].slice.call(arguments)));
            }
            /**
             * jQuery addClass method shortcut.
             */

            function addClass(el, classes) {
                return _frameworkProto.addClass.call(el, classes);
            }
            /**
             * jQuery removeClass method shortcut.
             */

            function removeClass(el, classes) {
                return _frameworkProto.removeClass.call(el, classes);
            }
            /**
             * jQuery remove method shortcut.
             */

            function remove(el) {
                return _frameworkProto.remove.call(el);
            }
            /**
             * Finds the first child element with the given selector of the given element.
             * @param el The root element from which the selector shall be valid.
             * @param selector The selector of the searched element.
             * @returns {*} The first element which is a child of the given element and matches the givens selector.
             */

            function findFirst(el, selector) {
                return _frameworkProto.find.call(el, selector).eq(0);
            } //==== API ====//

            /**
             * Puts the instance to sleep. It wont respond to any changes in the DOM and won't update. Scrollbar Interactivity is also disabled as well as the resize handle.
             * This behavior can be reset by calling the update method.
             */

            _base.sleep = function() {
                _sleeping = true;
            };
            /**
             * Updates the plugin and DOM to the current options.
             * This method should only be called if a update is 100% required.
             * @param force True if every property shall be updated and the cache shall be ignored.
             * !INTERNAL USAGE! : force can be a string "auto", "sync" or "zoom" too
             * if "auto" then before a real update the content size and host element attributes gets checked, and if they changed only then the update method will be called.
             * if "sync" then the async update process (MutationObserver or UpdateLoop) gets synchronized and a corresponding update takes place if one was needed due to pending changes.
             * if "zoom" then a update takes place where it's assumed that content and host size changed
             * @returns {boolean|undefined}
             * If force is "sync" then a boolean is returned which indicates whether a update was needed due to pending changes.
             * If force is "auto" then a boolean is returned whether a update was needed due to attribute or size changes.
             * undefined otherwise.
             */

            _base.update = function(force) {
                if (_destroyed) return;
                var attrsChanged;
                var contentSizeC;
                var isString = type(force) == TYPES.s;
                var imgElementSelector = 'img';
                var imgElementLoadEvent = 'load';
                var doUpdateAuto;
                var mutHost;
                var mutContent;

                if (isString) {
                    if (force === _strAuto) {
                        attrsChanged = meaningfulAttrsChanged();
                        contentSizeC = updateAutoContentSizeChanged();
                        doUpdateAuto = attrsChanged || contentSizeC;

                        if (doUpdateAuto) {
                            update({
                                _contentSizeChanged: contentSizeC,
                                _changedOptions: _initialized ? undefined : _currentPreparedOptions
                            });
                        }
                    } else if (force === _strSync) {
                        if (_mutationObserversConnected) {
                            mutHost = _mutationObserverHostCallback(_mutationObserverHost.takeRecords());
                            mutContent = _mutationObserverContentCallback(_mutationObserverContent.takeRecords());
                        } else {
                            mutHost = _base.update(_strAuto);
                        }
                    } else if (force === 'zoom') {
                        update({
                            _hostSizeChanged: true,
                            _contentSizeChanged: true
                        });
                    }
                } else {
                    force = _sleeping || force;
                    _sleeping = false;
                    if (!_base.update(_strSync) || force)
                        update({
                            _force: force
                        });
                }

                if (!_isTextarea) {
                    _contentElement.find(imgElementSelector).each(function(i, el) {
                        var index = COMPATIBILITY.inA(el, _imgs);
                        if (index === -1)
                            FRAMEWORK(el)
                                .off(imgElementLoadEvent, imgOnLoad)
                                .on(imgElementLoadEvent, imgOnLoad);
                    });
                }

                return doUpdateAuto || mutHost || mutContent;
            };
            /**
       Gets or sets the current options. The update method will be called automatically if new options were set.
       * @param newOptions If new options are given, then the new options will be set, if new options aren't given (undefined or a not a plain object) then the current options will be returned.
       * @param value If new options is a property path string, then this value will be used to set the option to which the property path string leads.
       * @returns {*}
       */

            _base.options = function(newOptions, value) {
                var option = {};
                var changedOps; //return current options if newOptions are undefined or empty

                if (FRAMEWORK.isEmptyObject(newOptions) || !FRAMEWORK.isPlainObject(newOptions)) {
                    if (type(newOptions) == TYPES.s) {
                        if (arguments.length > 1) {
                            setObjectPropVal(option, newOptions, value);
                            changedOps = setOptions(option);
                        } else return getObjectPropVal(_currentOptions, newOptions);
                    } else return _currentOptions;
                } else {
                    changedOps = setOptions(newOptions);
                }

                if (!FRAMEWORK.isEmptyObject(changedOps)) {
                    update({
                        _changedOptions: changedOps
                    });
                }
            };
            /**
             * Restore the DOM, disconnects all observers, remove all resize observers and put the instance to sleep.
             */

            _base.destroy = function() {
                if (_destroyed) return; //remove this instance from auto update loop

                autoUpdateLoop.remove(_base); //disconnect all mutation observers

                disconnectMutationObservers(); //remove all resize observers

                setupResizeObserver(_sizeObserverElement);
                setupResizeObserver(_sizeAutoObserverElement); //remove all extensions

                for (var extName in _extensions) {
                    _base.removeExt(extName);
                } //remove all 'destroy' events

                while (_destroyEvents[LEXICON.l] > 0) {
                    _destroyEvents.pop()();
                } //remove all events from host element

                setupHostMouseTouchEvents(true); //remove all helper / detection elements

                if (_contentGlueElement) remove(_contentGlueElement);
                if (_contentArrangeElement) remove(_contentArrangeElement);
                if (_sizeAutoObserverAdded) remove(_sizeAutoObserverElement); //remove all generated DOM

                setupScrollbarsDOM(true);
                setupScrollbarCornerDOM(true);
                setupStructureDOM(true); //remove all generated image load events

                for (var i = 0; i < _imgs[LEXICON.l]; i++) {
                    FRAMEWORK(_imgs[i]).off('load', imgOnLoad);
                }

                _imgs = undefined;
                _destroyed = true;
                _sleeping = true; //remove this instance from the instances list

                INSTANCES(pluginTargetElement, 0);
                dispatchCallback('onDestroyed'); //remove all properties and methods
                //for (var property in _base)
                //    delete _base[property];
                //_base = undefined;
            };
            /**
             * Scrolls to a given position or element.
             * @param coordinates
             * 1. Can be "coordinates" which looks like:
             *    { x : ?, y : ? } OR          Object with x and y properties
             *    { left : ?, top : ? } OR     Object with left and top properties
             *    { l : ?, t : ? } OR          Object with l and t properties
             *    [ ?, ? ] OR                  Array where the first two element are the coordinates (first is x, second is y)
             *    ?                            A single value which stays for both axis
             *    A value can be a number, a string or a calculation.
             *
             *    Operators:
             *    [NONE]  The current scroll will be overwritten by the value.
             *    '+='    The value will be added to the current scroll offset
             *    '-='    The value will be subtracted from the current scroll offset
             *    '*='    The current scroll wil be multiplicated by the value.
             *    '/='    The current scroll wil be divided by the value.
             *
             *    Units:
             *    [NONE]  The value is the final scroll amount.                   final = (value * 1)
             *    'px'    Same as none
             *    '%'     The value is dependent on the current scroll value.     final = ((currentScrollValue / 100) * value)
             *    'vw'    The value is multiplicated by the viewport width.       final = (value * viewportWidth)
             *    'vh'    The value is multiplicated by the viewport height.      final = (value * viewportHeight)
             *
             *    example final values:
             *    200, '200px', '50%', '1vw', '1vh', '+=200', '/=1vw', '*=2px', '-=5vh', '+=33%', '+= 50% - 2px', '-= 1vw - 50%'
             *
             * 2. Can be a HTML or jQuery element:
             *    The final scroll offset is the offset (without margin) of the given HTML / jQuery element.
             *
             * 3. Can be a object with a HTML or jQuery element with additional settings:
             *    {
             *      el : [HTMLElement, jQuery element],             MUST be specified, else this object isn't valid.
             *      scroll : [string, array, object],               Default value is 'always'.
             *      block : [string, array, object],                Default value is 'begin'.
             *      margin : [number, boolean, array, object]       Default value is false.
             *    }
             *
             *    Possible scroll settings are:
             *    'always'      Scrolls always.
             *    'ifneeded'    Scrolls only if the element isnt fully in view.
             *    'never'       Scrolls never.
             *
             *    Possible block settings are:
             *    'begin'   Both axis shall be docked to the "begin" edge. - The element will be docked to the top and left edge of the viewport.
             *    'end'     Both axis shall be docked to the "end" edge. - The element will be docked to the bottom and right edge of the viewport. (If direction is RTL to the bottom and left edge.)
             *    'center'  Both axis shall be docked to "center". - The element will be centered in the viewport.
             *    'nearest' The element will be docked to the nearest edge(s).
             *
             *    Possible margin settings are: -- The actual margin of the element wont be affect, this option affects only the final scroll offset.
             *    [BOOLEAN]                                         If true the css margin of the element will be used, if false no margin will be used.
             *    [NUMBER]                                          The margin will be used for all edges.
             *
             * @param duration The duration of the scroll animation, OR a jQuery animation configuration object.
             * @param easing The animation easing.
             * @param complete The animation complete callback.
             * @returns {{
             *   position: {x: number, y: number},
             *   ratio: {x: number, y: number},
             *   max: {x: number, y: number},
             *   handleOffset: {x: number, y: number},
             *   handleLength: {x: number, y: number},
             *   handleLengthRatio: {x: number, y: number}, t
             *   rackLength: {x: number, y: number},
             *   isRTL: boolean,
             *   isRTLNormalized: boolean
             *  }}
             */

            _base.scroll = function(coordinates, duration, easing, complete) {
                if (arguments.length === 0 || coordinates === undefined) {
                    var infoX = _scrollHorizontalInfo;
                    var infoY = _scrollVerticalInfo;
                    var normalizeInvert = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.i;
                    var normalizeNegate = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.n;
                    var scrollX = infoX._currentScroll;
                    var scrollXRatio = infoX._currentScrollRatio;
                    var maxScrollX = infoX._maxScroll;
                    scrollXRatio = normalizeInvert ? 1 - scrollXRatio : scrollXRatio;
                    scrollX = normalizeInvert ? maxScrollX - scrollX : scrollX;
                    scrollX *= normalizeNegate ? -1 : 1;
                    maxScrollX *= normalizeNegate ? -1 : 1;
                    return {
                        position: {
                            x: scrollX,
                            y: infoY._currentScroll
                        },
                        ratio: {
                            x: scrollXRatio,
                            y: infoY._currentScrollRatio
                        },
                        max: {
                            x: maxScrollX,
                            y: infoY._maxScroll
                        },
                        handleOffset: {
                            x: infoX._handleOffset,
                            y: infoY._handleOffset
                        },
                        handleLength: {
                            x: infoX._handleLength,
                            y: infoY._handleLength
                        },
                        handleLengthRatio: {
                            x: infoX._handleLengthRatio,
                            y: infoY._handleLengthRatio
                        },
                        trackLength: {
                            x: infoX._trackLength,
                            y: infoY._trackLength
                        },
                        snappedHandleOffset: {
                            x: infoX._snappedHandleOffset,
                            y: infoY._snappedHandleOffset
                        },
                        isRTL: _isRTL,
                        isRTLNormalized: _normalizeRTLCache
                    };
                }

                _base.update(_strSync);

                var normalizeRTL = _normalizeRTLCache;
                var coordinatesXAxisProps = [_strX, _strLeft, 'l'];
                var coordinatesYAxisProps = [_strY, _strTop, 't'];
                var coordinatesOperators = ['+=', '-=', '*=', '/='];
                var durationIsObject = type(duration) == TYPES.o;
                var completeCallback = durationIsObject ? duration.complete : complete;
                var i;
                var finalScroll = {};
                var specialEasing = {};
                var doScrollLeft;
                var doScrollTop;
                var animationOptions;
                var strEnd = 'end';
                var strBegin = 'begin';
                var strCenter = 'center';
                var strNearest = 'nearest';
                var strAlways = 'always';
                var strNever = 'never';
                var strIfNeeded = 'ifneeded';
                var strLength = LEXICON.l;
                var settingsAxis;
                var settingsScroll;
                var settingsBlock;
                var settingsMargin;
                var finalElement;
                var elementObjSettingsAxisValues = [_strX, _strY, 'xy', 'yx'];
                var elementObjSettingsBlockValues = [strBegin, strEnd, strCenter, strNearest];
                var elementObjSettingsScrollValues = [strAlways, strNever, strIfNeeded];
                var coordinatesIsElementObj = coordinates[LEXICON.hOP]('el');
                var possibleElement = coordinatesIsElementObj ? coordinates.el : coordinates;
                var possibleElementIsJQuery = _instanceof(possibleElement, FRAMEWORK) || JQUERY ? _instanceof(possibleElement, JQUERY) : false;
                var possibleElementIsHTMLElement = possibleElementIsJQuery ? false : isHTMLElement(possibleElement);
                var proxyCompleteCallback =
                    type(completeCallback) != TYPES.f
                        ? undefined
                        : function() {
                              if (doScrollLeft) refreshScrollbarHandleOffset(true);
                              if (doScrollTop) refreshScrollbarHandleOffset(false);
                              completeCallback();
                          };

                function checkSettingsStringValue(currValue, allowedValues) {
                    for (i = 0; i < allowedValues[strLength]; i++) {
                        if (currValue === allowedValues[i]) return true;
                    }

                    return false;
                }

                function getRawScroll(isX, coordinates) {
                    var coordinateProps = isX ? coordinatesXAxisProps : coordinatesYAxisProps;
                    coordinates = type(coordinates) == TYPES.s || type(coordinates) == TYPES.n ? [coordinates, coordinates] : coordinates;
                    if (type(coordinates) == TYPES.a) return isX ? coordinates[0] : coordinates[1];
                    else if (type(coordinates) == TYPES.o) {
                        //decides RTL normalization "hack" with .n
                        //normalizeRTL = type(coordinates.n) == TYPES.b ? coordinates.n : normalizeRTL;
                        for (i = 0; i < coordinateProps[strLength]; i++) {
                            if (coordinateProps[i] in coordinates) return coordinates[coordinateProps[i]];
                        }
                    }
                }

                function getFinalScroll(isX, rawScroll) {
                    var isString = type(rawScroll) == TYPES.s;
                    var operator;
                    var amount;
                    var scrollInfo = isX ? _scrollHorizontalInfo : _scrollVerticalInfo;
                    var currScroll = scrollInfo._currentScroll;
                    var maxScroll = scrollInfo._maxScroll;
                    var mult = ' * ';
                    var finalValue;
                    var isRTLisX = _isRTL && isX;
                    var normalizeShortcuts = isRTLisX && _rtlScrollBehavior.n && !normalizeRTL;
                    var strReplace = 'replace';
                    var evalFunc = eval;
                    var possibleOperator;

                    if (isString) {
                        //check operator
                        if (rawScroll[strLength] > 2) {
                            possibleOperator = rawScroll.substr(0, 2);
                            if (inArray(possibleOperator, coordinatesOperators) > -1) operator = possibleOperator;
                        } //calculate units and shortcuts

                        rawScroll = operator ? rawScroll.substr(2) : rawScroll;
                        rawScroll = rawScroll[strReplace](/min/g, 0) //'min' = 0%
                            [strReplace](/</g, 0) //'<'   = 0%
                            [strReplace](/max/g, (normalizeShortcuts ? '-' : _strEmpty) + _strHundredPercent) //'max' = 100%
                            [strReplace](/>/g, (normalizeShortcuts ? '-' : _strEmpty) + _strHundredPercent) //'>'   = 100%
                            [strReplace](/px/g, _strEmpty)
                            [strReplace](/%/g, mult + (maxScroll * (isRTLisX && _rtlScrollBehavior.n ? -1 : 1)) / 100.0)
                            [strReplace](/vw/g, mult + _viewportSize.w)
                            [strReplace](/vh/g, mult + _viewportSize.h);
                        amount = parseToZeroOrNumber(isNaN(rawScroll) ? parseToZeroOrNumber(evalFunc(rawScroll), true).toFixed() : rawScroll);
                    } else {
                        amount = rawScroll;
                    }

                    if (amount !== undefined && !isNaN(amount) && type(amount) == TYPES.n) {
                        var normalizeIsRTLisX = normalizeRTL && isRTLisX;
                        var operatorCurrScroll = currScroll * (normalizeIsRTLisX && _rtlScrollBehavior.n ? -1 : 1);
                        var invert = normalizeIsRTLisX && _rtlScrollBehavior.i;
                        var negate = normalizeIsRTLisX && _rtlScrollBehavior.n;
                        operatorCurrScroll = invert ? maxScroll - operatorCurrScroll : operatorCurrScroll;

                        switch (operator) {
                            case '+=':
                                finalValue = operatorCurrScroll + amount;
                                break;

                            case '-=':
                                finalValue = operatorCurrScroll - amount;
                                break;

                            case '*=':
                                finalValue = operatorCurrScroll * amount;
                                break;

                            case '/=':
                                finalValue = operatorCurrScroll / amount;
                                break;

                            default:
                                finalValue = amount;
                                break;
                        }

                        finalValue = invert ? maxScroll - finalValue : finalValue;
                        finalValue *= negate ? -1 : 1;
                        finalValue = isRTLisX && _rtlScrollBehavior.n ? MATH.min(0, MATH.max(maxScroll, finalValue)) : MATH.max(0, MATH.min(maxScroll, finalValue));
                    }

                    return finalValue === currScroll ? undefined : finalValue;
                }

                function getPerAxisValue(value, valueInternalType, defaultValue, allowedValues) {
                    var resultDefault = [defaultValue, defaultValue];
                    var valueType = type(value);
                    var valueArrLength;
                    var valueArrItem; //value can be [ string, or array of two strings ]

                    if (valueType == valueInternalType) {
                        value = [value, value];
                    } else if (valueType == TYPES.a) {
                        valueArrLength = value[strLength];
                        if (valueArrLength > 2 || valueArrLength < 1) value = resultDefault;
                        else {
                            if (valueArrLength === 1) value[1] = defaultValue;

                            for (i = 0; i < valueArrLength; i++) {
                                valueArrItem = value[i];

                                if (type(valueArrItem) != valueInternalType || !checkSettingsStringValue(valueArrItem, allowedValues)) {
                                    value = resultDefault;
                                    break;
                                }
                            }
                        }
                    } else if (valueType == TYPES.o) value = [value[_strX] || defaultValue, value[_strY] || defaultValue];
                    else value = resultDefault;

                    return {
                        x: value[0],
                        y: value[1]
                    };
                }

                function generateMargin(marginTopRightBottomLeftArray) {
                    var result = [];
                    var currValue;
                    var currValueType;
                    var valueDirections = [_strTop, _strRight, _strBottom, _strLeft];

                    for (i = 0; i < marginTopRightBottomLeftArray[strLength]; i++) {
                        if (i === valueDirections[strLength]) break;
                        currValue = marginTopRightBottomLeftArray[i];
                        currValueType = type(currValue);
                        if (currValueType == TYPES.b) result.push(currValue ? parseToZeroOrNumber(finalElement.css(_strMarginMinus + valueDirections[i])) : 0);
                        else result.push(currValueType == TYPES.n ? currValue : 0);
                    }

                    return result;
                }

                if (possibleElementIsJQuery || possibleElementIsHTMLElement) {
                    //get settings
                    var margin = coordinatesIsElementObj ? coordinates.margin : 0;
                    var axis = coordinatesIsElementObj ? coordinates.axis : 0;
                    var scroll = coordinatesIsElementObj ? coordinates.scroll : 0;
                    var block = coordinatesIsElementObj ? coordinates.block : 0;
                    var marginDefault = [0, 0, 0, 0];
                    var marginType = type(margin);
                    var marginLength;
                    finalElement = possibleElementIsJQuery ? possibleElement : FRAMEWORK(possibleElement);

                    if (finalElement[strLength] > 0) {
                        //margin can be [ boolean, number, array of 2, array of 4, object ]
                        if (marginType == TYPES.n || marginType == TYPES.b) margin = generateMargin([margin, margin, margin, margin]);
                        else if (marginType == TYPES.a) {
                            marginLength = margin[strLength];
                            if (marginLength === 2) margin = generateMargin([margin[0], margin[1], margin[0], margin[1]]);
                            else if (marginLength >= 4) margin = generateMargin(margin);
                            else margin = marginDefault;
                        } else if (marginType == TYPES.o) margin = generateMargin([margin[_strTop], margin[_strRight], margin[_strBottom], margin[_strLeft]]);
                        else margin = marginDefault; //block = type(block) === TYPES.b ? block ? [ strNearest, strBegin ] : [ strNearest, strEnd ] : block;

                        settingsAxis = checkSettingsStringValue(axis, elementObjSettingsAxisValues) ? axis : 'xy';
                        settingsScroll = getPerAxisValue(scroll, TYPES.s, strAlways, elementObjSettingsScrollValues);
                        settingsBlock = getPerAxisValue(block, TYPES.s, strBegin, elementObjSettingsBlockValues);
                        settingsMargin = margin;
                        var viewportScroll = {
                            l: _scrollHorizontalInfo._currentScroll,
                            t: _scrollVerticalInfo._currentScroll
                        }; // use padding element instead of viewport element because padding element has never padding, margin or position applied.

                        var viewportOffset = _paddingElement.offset(); //get coordinates

                        var elementOffset = finalElement.offset();
                        var doNotScroll = {
                            x: settingsScroll.x == strNever || settingsAxis == _strY,
                            y: settingsScroll.y == strNever || settingsAxis == _strX
                        };
                        elementOffset[_strTop] -= settingsMargin[0];
                        elementOffset[_strLeft] -= settingsMargin[3];
                        var elementScrollCoordinates = {
                            x: MATH.round(elementOffset[_strLeft] - viewportOffset[_strLeft] + viewportScroll.l),
                            y: MATH.round(elementOffset[_strTop] - viewportOffset[_strTop] + viewportScroll.t)
                        };

                        if (_isRTL) {
                            if (!_rtlScrollBehavior.n && !_rtlScrollBehavior.i)
                                elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + viewportScroll.l);
                            if (_rtlScrollBehavior.n && normalizeRTL) elementScrollCoordinates.x *= -1;
                            if (_rtlScrollBehavior.i && normalizeRTL)
                                elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + (_scrollHorizontalInfo._maxScroll - viewportScroll.l));
                        } //measuring is required

                        if (settingsBlock.x != strBegin || settingsBlock.y != strBegin || settingsScroll.x == strIfNeeded || settingsScroll.y == strIfNeeded || _isRTL) {
                            var measuringElm = finalElement[0];
                            var rawElementSize = _supportTransform
                                ? measuringElm[LEXICON.bCR]()
                                : {
                                      width: measuringElm[LEXICON.oW],
                                      height: measuringElm[LEXICON.oH]
                                  };
                            var elementSize = {
                                w: rawElementSize[_strWidth] + settingsMargin[3] + settingsMargin[1],
                                h: rawElementSize[_strHeight] + settingsMargin[0] + settingsMargin[2]
                            };

                            var finalizeBlock = function finalizeBlock(isX) {
                                var vars = getScrollbarVars(isX);
                                var wh = vars._w_h;
                                var lt = vars._left_top;
                                var xy = vars._x_y;
                                var blockIsEnd = settingsBlock[xy] == (isX ? (_isRTL ? strBegin : strEnd) : strEnd);
                                var blockIsCenter = settingsBlock[xy] == strCenter;
                                var blockIsNearest = settingsBlock[xy] == strNearest;
                                var scrollNever = settingsScroll[xy] == strNever;
                                var scrollIfNeeded = settingsScroll[xy] == strIfNeeded;
                                var vpSize = _viewportSize[wh];
                                var vpOffset = viewportOffset[lt];
                                var elSize = elementSize[wh];
                                var elOffset = elementOffset[lt];
                                var divide = blockIsCenter ? 2 : 1;
                                var elementCenterOffset = elOffset + elSize / 2;
                                var viewportCenterOffset = vpOffset + vpSize / 2;
                                var isInView = elSize <= vpSize && elOffset >= vpOffset && elOffset + elSize <= vpOffset + vpSize;
                                if (scrollNever) doNotScroll[xy] = true;
                                else if (!doNotScroll[xy]) {
                                    if (blockIsNearest || scrollIfNeeded) {
                                        doNotScroll[xy] = scrollIfNeeded ? isInView : false;
                                        blockIsEnd = elSize < vpSize ? elementCenterOffset > viewportCenterOffset : elementCenterOffset < viewportCenterOffset;
                                    }

                                    elementScrollCoordinates[xy] -=
                                        blockIsEnd || blockIsCenter ? (vpSize / divide - elSize / divide) * (isX && _isRTL && normalizeRTL ? -1 : 1) : 0;
                                }
                            };

                            finalizeBlock(true);
                            finalizeBlock(false);
                        }

                        if (doNotScroll.y) delete elementScrollCoordinates.y;
                        if (doNotScroll.x) delete elementScrollCoordinates.x;
                        coordinates = elementScrollCoordinates;
                    }
                }

                finalScroll[_strScrollLeft] = getFinalScroll(true, getRawScroll(true, coordinates));
                finalScroll[_strScrollTop] = getFinalScroll(false, getRawScroll(false, coordinates));
                doScrollLeft = finalScroll[_strScrollLeft] !== undefined;
                doScrollTop = finalScroll[_strScrollTop] !== undefined;

                if ((doScrollLeft || doScrollTop) && (duration > 0 || durationIsObject)) {
                    if (durationIsObject) {
                        duration.complete = proxyCompleteCallback;

                        _viewportElement.animate(finalScroll, duration);
                    } else {
                        animationOptions = {
                            duration: duration,
                            complete: proxyCompleteCallback
                        };

                        if (type(easing) == TYPES.a || FRAMEWORK.isPlainObject(easing)) {
                            specialEasing[_strScrollLeft] = easing[0] || easing.x;
                            specialEasing[_strScrollTop] = easing[1] || easing.y;
                            animationOptions.specialEasing = specialEasing;
                        } else {
                            animationOptions.easing = easing;
                        }

                        _viewportElement.animate(finalScroll, animationOptions);
                    }
                } else {
                    if (doScrollLeft) _viewportElement[_strScrollLeft](finalScroll[_strScrollLeft]);
                    if (doScrollTop) _viewportElement[_strScrollTop](finalScroll[_strScrollTop]);
                }
            };
            /**
             * Stops all scroll animations.
             * @returns {*} The current OverlayScrollbars instance (for chaining).
             */

            _base.scrollStop = function(param1, param2, param3) {
                _viewportElement.stop(param1, param2, param3);

                return _base;
            };
            /**
             * Returns all relevant elements.
             * @param elementName The name of the element which shall be returned.
             * @returns {{target: *, host: *, padding: *, viewport: *, content: *, scrollbarHorizontal: {scrollbar: *, track: *, handle: *}, scrollbarVertical: {scrollbar: *, track: *, handle: *}, scrollbarCorner: *} | *}
             */

            _base.getElements = function(elementName) {
                var obj = {
                    target: _targetElementNative,
                    host: _hostElementNative,
                    padding: _paddingElementNative,
                    viewport: _viewportElementNative,
                    content: _contentElementNative,
                    scrollbarHorizontal: {
                        scrollbar: _scrollbarHorizontalElement[0],
                        track: _scrollbarHorizontalTrackElement[0],
                        handle: _scrollbarHorizontalHandleElement[0]
                    },
                    scrollbarVertical: {
                        scrollbar: _scrollbarVerticalElement[0],
                        track: _scrollbarVerticalTrackElement[0],
                        handle: _scrollbarVerticalHandleElement[0]
                    },
                    scrollbarCorner: _scrollbarCornerElement[0]
                };
                return type(elementName) == TYPES.s ? getObjectPropVal(obj, elementName) : obj;
            };
            /**
             * Returns a object which describes the current state of this instance.
             * @param stateProperty A specific property from the state object which shall be returned.
             * @returns {{widthAuto, heightAuto, overflowAmount, hideOverflow, hasOverflow, contentScrollSize, viewportSize, hostSize, autoUpdate} | *}
             */

            _base.getState = function(stateProperty) {
                function prepare(obj) {
                    if (!FRAMEWORK.isPlainObject(obj)) return obj;
                    var extended = extendDeep({}, obj);

                    var changePropertyName = function changePropertyName(from, to) {
                        if (extended[LEXICON.hOP](from)) {
                            extended[to] = extended[from];
                            delete extended[from];
                        }
                    };

                    changePropertyName('w', _strWidth); //change w to width

                    changePropertyName('h', _strHeight); //change h to height

                    delete extended.c; //delete c (the 'changed' prop)

                    return extended;
                }

                var obj = {
                    destroyed: !!prepare(_destroyed),
                    sleeping: !!prepare(_sleeping),
                    autoUpdate: prepare(!_mutationObserversConnected),
                    widthAuto: prepare(_widthAutoCache),
                    heightAuto: prepare(_heightAutoCache),
                    padding: prepare(_cssPaddingCache),
                    overflowAmount: prepare(_overflowAmountCache),
                    hideOverflow: prepare(_hideOverflowCache),
                    hasOverflow: prepare(_hasOverflowCache),
                    contentScrollSize: prepare(_contentScrollSizeCache),
                    viewportSize: prepare(_viewportSize),
                    hostSize: prepare(_hostSizeCache),
                    documentMixed: prepare(_documentMixed)
                };
                return type(stateProperty) == TYPES.s ? getObjectPropVal(obj, stateProperty) : obj;
            };
            /**
             * Gets all or specific extension instance.
             * @param extName The name of the extension from which the instance shall be got.
             * @returns {{}} The instance of the extension with the given name or undefined if the instance couldn't be found.
             */

            _base.ext = function(extName) {
                var result;

                var privateMethods = _extensionsPrivateMethods.split(' ');

                var i = 0;

                if (type(extName) == TYPES.s) {
                    if (_extensions[LEXICON.hOP](extName)) {
                        result = extendDeep({}, _extensions[extName]);

                        for (; i < privateMethods.length; i++) {
                            delete result[privateMethods[i]];
                        }
                    }
                } else {
                    result = {};

                    for (i in _extensions) {
                        result[i] = extendDeep({}, _base.ext(i));
                    }
                }

                return result;
            };
            /**
             * Adds a extension to this instance.
             * @param extName The name of the extension which shall be added.
             * @param extensionOptions The extension options which shall be used.
             * @returns {{}} The instance of the added extension or undefined if the extension couldn't be added properly.
             */

            _base.addExt = function(extName, extensionOptions) {
                var registeredExtensionObj = _plugin.extension(extName);

                var instance;
                var instanceAdded;
                var instanceContract;
                var contractResult;
                var contractFulfilled = true;

                if (registeredExtensionObj) {
                    if (!_extensions[LEXICON.hOP](extName)) {
                        instance = registeredExtensionObj.extensionFactory.call(_base, extendDeep({}, registeredExtensionObj.defaultOptions), FRAMEWORK, COMPATIBILITY);

                        if (instance) {
                            instanceContract = instance.contract;

                            if (type(instanceContract) == TYPES.f) {
                                contractResult = instanceContract(window);
                                contractFulfilled = type(contractResult) == TYPES.b ? contractResult : contractFulfilled;
                            }

                            if (contractFulfilled) {
                                _extensions[extName] = instance;
                                instanceAdded = instance.added;
                                if (type(instanceAdded) == TYPES.f) instanceAdded(extensionOptions);
                                return _base.ext(extName);
                            }
                        }
                    } else return _base.ext(extName);
                } else console.warn('A extension with the name "' + extName + '" isn\'t registered.');
            };
            /**
             * Removes a extension from this instance.
             * @param extName The name of the extension which shall be removed.
             * @returns {boolean} True if the extension was removed, false otherwise e.g. if the extension wasn't added before.
             */

            _base.removeExt = function(extName) {
                var instance = _extensions[extName];
                var instanceRemoved;

                if (instance) {
                    delete _extensions[extName];
                    instanceRemoved = instance.removed;
                    if (type(instanceRemoved) == TYPES.f) instanceRemoved();
                    return true;
                }

                return false;
            };
            /**
             * Constructs the plugin.
             * @param targetElement The element to which the plugin shall be applied.
             * @param options The initial options of the plugin.
             * @param extensions The extension(s) which shall be added right after the initialization.
             * @returns {boolean} True if the plugin was successfully initialized, false otherwise.
             */

            function construct(targetElement, options, extensions) {
                _defaultOptions = globals.defaultOptions;
                _nativeScrollbarStyling = globals.nativeScrollbarStyling;
                _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);
                _nativeScrollbarIsOverlaid = extendDeep({}, globals.nativeScrollbarIsOverlaid);
                _overlayScrollbarDummySize = extendDeep({}, globals.overlayScrollbarDummySize);
                _rtlScrollBehavior = extendDeep({}, globals.rtlScrollBehavior); //parse & set options but don't update

                setOptions(extendDeep({}, _defaultOptions, options));
                _cssCalc = globals.cssCalc;
                _msieVersion = globals.msie;
                _autoUpdateRecommended = globals.autoUpdateRecommended;
                _supportTransition = globals.supportTransition;
                _supportTransform = globals.supportTransform;
                _supportPassiveEvents = globals.supportPassiveEvents;
                _supportResizeObserver = globals.supportResizeObserver;
                _supportMutationObserver = globals.supportMutationObserver;
                _restrictedMeasuring = globals.restrictedMeasuring;
                _documentElement = FRAMEWORK(targetElement.ownerDocument);
                _documentElementNative = _documentElement[0];
                _windowElement = FRAMEWORK(_documentElementNative.defaultView || _documentElementNative.parentWindow);
                _windowElementNative = _windowElement[0];
                _htmlElement = findFirst(_documentElement, 'html');
                _bodyElement = findFirst(_htmlElement, 'body');
                _targetElement = FRAMEWORK(targetElement);
                _targetElementNative = _targetElement[0];
                _isTextarea = _targetElement.is('textarea');
                _isBody = _targetElement.is('body');
                _documentMixed = _documentElementNative !== document;
                /* On a div Element The if checks only whether:
                 * - the targetElement has the class "os-host"
                 * - the targetElement has a a child with the class "os-padding"
                 *
                 * If that's the case, its assumed the DOM has already the following structure:
                 * (The ".os-host" element is the targetElement)
                 *
                 *  <div class="os-host">
                 *      <div class="os-resize-observer-host"></div>
                 *      <div class="os-padding">
                 *          <div class="os-viewport">
                 *              <div class="os-content"></div>
                 *          </div>
                 *      </div>
                 *      <div class="os-scrollbar os-scrollbar-horizontal ">
                 *          <div class="os-scrollbar-track">
                 *              <div class="os-scrollbar-handle"></div>
                 *          </div>
                 *      </div>
                 *      <div class="os-scrollbar os-scrollbar-vertical">
                 *          <div class="os-scrollbar-track">
                 *              <div class="os-scrollbar-handle"></div>
                 *          </div>
                 *      </div>
                 *      <div class="os-scrollbar-corner"></div>
                 *  </div>
                 *
                 * =====================================================================================
                 *
                 * On a Textarea Element The if checks only whether:
                 * - the targetElement has the class "os-textarea"
                 * - the targetElement is inside a element with the class "os-content"
                 *
                 * If that's the case, its assumed the DOM has already the following structure:
                 * (The ".os-textarea" (textarea) element is the targetElement)
                 *
                 *  <div class="os-host-textarea">
                 *      <div class="os-resize-observer-host"></div>
                 *      <div class="os-padding os-text-inherit">
                 *          <div class="os-viewport os-text-inherit">
                 *              <div class="os-content os-text-inherit">
                 *                  <div class="os-textarea-cover"></div>
                 *                  <textarea class="os-textarea os-text-inherit"></textarea>
                 *              </div>
                 *          </div>
                 *      </div>
                 *      <div class="os-scrollbar os-scrollbar-horizontal ">
                 *          <div class="os-scrollbar-track">
                 *              <div class="os-scrollbar-handle"></div>
                 *          </div>
                 *      </div>
                 *      <div class="os-scrollbar os-scrollbar-vertical">
                 *          <div class="os-scrollbar-track">
                 *              <div class="os-scrollbar-handle"></div>
                 *          </div>
                 *      </div>
                 *      <div class="os-scrollbar-corner"></div>
                 *  </div>
                 */

                _domExists = _isTextarea
                    ? _targetElement.hasClass(_classNameTextareaElement) && _targetElement.parent().hasClass(_classNameContentElement)
                    : _targetElement.hasClass(_classNameHostElement) && _targetElement.children(_strDot + _classNamePaddingElement)[LEXICON.l];
                var initBodyScroll;

                var _bodyMouseTouchDownListener; //check if the plugin hasn't to be initialized

                if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y && !_currentPreparedOptions.nativeScrollbarsOverlaid.initialize) {
                    dispatchCallback('onInitializationWithdrawn');

                    if (_domExists) {
                        setupStructureDOM(true);
                        setupScrollbarsDOM(true);
                        setupScrollbarCornerDOM(true);
                    }

                    _destroyed = true;
                    _sleeping = true;
                    return _base;
                }

                if (_isBody) {
                    initBodyScroll = {};
                    initBodyScroll.l = MATH.max(_targetElement[_strScrollLeft](), _htmlElement[_strScrollLeft](), _windowElement[_strScrollLeft]());
                    initBodyScroll.t = MATH.max(_targetElement[_strScrollTop](), _htmlElement[_strScrollTop](), _windowElement[_strScrollTop]());

                    _bodyMouseTouchDownListener = function bodyMouseTouchDownListener() {
                        _viewportElement.removeAttr('tabindex');

                        setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, _bodyMouseTouchDownListener, true, true);
                    };
                } //build OverlayScrollbars DOM

                setupStructureDOM();
                setupScrollbarsDOM();
                setupScrollbarCornerDOM(); //create OverlayScrollbars events

                setupStructureEvents();
                setupScrollbarEvents(true);
                setupScrollbarEvents(false);
                setupScrollbarCornerEvents(); //create mutation observers

                createMutationObservers(); //build resize observer for the host element

                setupResizeObserver(_sizeObserverElement, hostOnResized);

                if (_isBody) {
                    //apply the body scroll to handle it right in the update method
                    _viewportElement[_strScrollLeft](initBodyScroll.l)[_strScrollTop](initBodyScroll.t); //set the focus on the viewport element so you dont have to click on the page to use keyboard keys (up / down / space) for scrolling

                    if (document.activeElement == targetElement && _viewportElementNative.focus) {
                        //set a tabindex to make the viewportElement focusable
                        _viewportElement.attr('tabindex', '-1');

                        _viewportElementNative.focus();
                        /* the tabindex has to be removed due to;
                         * If you set the tabindex attribute on an <div>, then its child content cannot be scrolled with the arrow keys unless you set tabindex on the content, too
                         * https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
                         */

                        setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, _bodyMouseTouchDownListener, false, true);
                    }
                } //update for the first time & initialize cache

                _base.update(_strAuto); //the plugin is initialized now!

                _initialized = true;
                dispatchCallback('onInitialized'); //call all callbacks which would fire before the initialized was complete

                each(_callbacksInitQeueue, function(index, value) {
                    dispatchCallback(value.n, value.a);
                });
                _callbacksInitQeueue = []; //add extensions

                if (type(extensions) == TYPES.s) extensions = [extensions];
                if (COMPATIBILITY.isA(extensions))
                    each(extensions, function(index, value) {
                        _base.addExt(value);
                    });
                else if (FRAMEWORK.isPlainObject(extensions))
                    each(extensions, function(key, value) {
                        _base.addExt(key, value);
                    }); //add the transition class for transitions AFTER the first update & AFTER the applied extensions (for preventing unwanted transitions)

                setTimeout(function() {
                    if (_supportTransition && !_destroyed) addClass(_hostElement, _classNameHostTransition);
                }, 333);
                return _base;
            }

            if (_plugin.valid(construct(pluginTargetElement, options, extensions))) {
                INSTANCES(pluginTargetElement, _base);
            }

            return _base;
        }
        /**
         * Initializes a new OverlayScrollbarsInstance object or changes options if already initialized or returns the current instance.
         * @param pluginTargetElements The elements to which the Plugin shall be initialized.
         * @param options The custom options with which the plugin shall be initialized.
         * @param extensions The extension(s) which shall be added right after initialization.
         * @returns {*}
         */

        _plugin = window[PLUGINNAME] = function(pluginTargetElements, options, extensions) {
            if (arguments[LEXICON.l] === 0) return this;
            var arr = [];
            var optsIsPlainObj = FRAMEWORK.isPlainObject(options);
            var inst;
            var result; //pluginTargetElements is null or undefined

            if (!pluginTargetElements) return optsIsPlainObj || !options ? result : arr;
            /*
         pluginTargetElements will be converted to:
         1. A jQueryElement Array
         2. A HTMLElement Array
         3. A Array with a single HTML Element
         so pluginTargetElements is always a array.
      */

            pluginTargetElements = pluginTargetElements[LEXICON.l] != undefined ? pluginTargetElements : [pluginTargetElements[0] || pluginTargetElements];
            initOverlayScrollbarsStatics();

            if (pluginTargetElements[LEXICON.l] > 0) {
                if (optsIsPlainObj) {
                    FRAMEWORK.each(pluginTargetElements, function(i, v) {
                        inst = v;
                        if (inst !== undefined) arr.push(OverlayScrollbarsInstance(inst, options, extensions, _pluginsGlobals, _pluginsAutoUpdateLoop));
                    });
                } else {
                    FRAMEWORK.each(pluginTargetElements, function(i, v) {
                        inst = INSTANCES(v);
                        if ((options === '!' && _plugin.valid(inst)) || (COMPATIBILITY.type(options) == TYPES.f && options(v, inst))) arr.push(inst);
                        else if (options === undefined) arr.push(inst);
                    });
                }

                result = arr[LEXICON.l] === 1 ? arr[0] : arr;
            }

            return result;
        };
        /**
         * Returns a object which contains global information about the plugin and each instance of it.
         * The returned object is just a copy, that means that changes to the returned object won't have any effect to the original object.
         */

        _plugin.globals = function() {
            initOverlayScrollbarsStatics();
            var globals = FRAMEWORK.extend(true, {}, _pluginsGlobals);
            delete globals['msie'];
            return globals;
        };
        /**
         * Gets or Sets the default options for each new plugin initialization.
         * @param newDefaultOptions The object with which the default options shall be extended.
         */

        _plugin.defaultOptions = function(newDefaultOptions) {
            initOverlayScrollbarsStatics();
            var currDefaultOptions = _pluginsGlobals.defaultOptions;
            if (newDefaultOptions === undefined) return FRAMEWORK.extend(true, {}, currDefaultOptions); //set the new default options

            _pluginsGlobals.defaultOptions = FRAMEWORK.extend(
                true,
                {},
                currDefaultOptions,
                _pluginsOptions._validate(newDefaultOptions, _pluginsOptions._template, true, currDefaultOptions)._default
            );
        };
        /**
         * Checks whether the passed instance is a non-destroyed OverlayScrollbars instance.
         * @param osInstance The potential OverlayScrollbars instance which shall be checked.
         * @returns {boolean} True if the passed value is a non-destroyed OverlayScrollbars instance, false otherwise.
         */

        _plugin.valid = function(osInstance) {
            return _instanceof(osInstance, _plugin) && !osInstance.getState().destroyed;
        };
        /**
         * Registers, Unregisters or returns a extension.
         * Register: Pass the name and the extension. (defaultOptions is optional)
         * Unregister: Pass the name and anything except a function as extension parameter.
         * Get extension: Pass the name of the extension which shall be got.
         * Get all extensions: Pass no arguments.
         * @param extensionName The name of the extension which shall be registered, unregistered or returned.
         * @param extension A function which generates the instance of the extension or anything other to remove a already registered extension.
         * @param defaultOptions The default options which shall be used for the registered extension.
         */

        _plugin.extension = function(extensionName, extension, defaultOptions) {
            var extNameTypeString = COMPATIBILITY.type(extensionName) == TYPES.s;
            var argLen = arguments[LEXICON.l];
            var i = 0;

            if (argLen < 1 || !extNameTypeString) {
                //return a copy of all extension objects
                return FRAMEWORK.extend(
                    true,
                    {
                        length: _pluginsExtensions[LEXICON.l]
                    },
                    _pluginsExtensions
                );
            } else if (extNameTypeString) {
                if (COMPATIBILITY.type(extension) == TYPES.f) {
                    //register extension
                    _pluginsExtensions.push({
                        name: extensionName,
                        extensionFactory: extension,
                        defaultOptions: defaultOptions
                    });
                } else {
                    for (; i < _pluginsExtensions[LEXICON.l]; i++) {
                        if (_pluginsExtensions[i].name === extensionName) {
                            if (argLen > 1) _pluginsExtensions.splice(i, 1);
                            //remove extension
                            else return FRAMEWORK.extend(true, {}, _pluginsExtensions[i]); //return extension with the given name
                        }
                    }
                }
            }
        };

        return _plugin;
    })();

    if (JQUERY && JQUERY.fn) {
        /**
         * The jQuery initialization interface.
         * @param options The initial options for the construction of the plugin. To initialize the plugin, this option has to be a object! If it isn't a object, the instance(s) are returned and the plugin wont be initialized.
         * @param extensions The extension(s) which shall be added right after initialization.
         * @returns {*} After initialization it returns the jQuery element array, else it returns the instance(s) of the elements which are selected.
         */
        JQUERY.fn.overlayScrollbars = function(options, extensions) {
            var _elements = this;

            if (JQUERY.isPlainObject(options)) {
                JQUERY.each(_elements, function() {
                    PLUGIN(this, options, extensions);
                });
                return _elements;
            } else return PLUGIN(_elements, options);
        };
    }

    return PLUGIN;
});

/*! picturefill - v3.0.2 - 2016-02-12
 * https://scottjehl.github.io/picturefill/
 * Copyright (c) 2016 https://github.com/scottjehl/picturefill/blob/master/Authors.txt; Licensed MIT
 */
!function(a){var b=navigator.userAgent;a.HTMLPictureElement&&/ecko/.test(b)&&b.match(/rv\:(\d+)/)&&RegExp.$1<45&&addEventListener("resize",function(){var b,c=document.createElement("source"),d=function(a){var b,d,e=a.parentNode;"PICTURE"===e.nodeName.toUpperCase()?(b=c.cloneNode(),e.insertBefore(b,e.firstElementChild),setTimeout(function(){e.removeChild(b)})):(!a._pfLastSize||a.offsetWidth>a._pfLastSize)&&(a._pfLastSize=a.offsetWidth,d=a.sizes,a.sizes+=",100vw",setTimeout(function(){a.sizes=d}))},e=function(){var a,b=document.querySelectorAll("picture > img, img[srcset][sizes]");for(a=0;a<b.length;a++)d(b[a])},f=function(){clearTimeout(b),b=setTimeout(e,99)},g=a.matchMedia&&matchMedia("(orientation: landscape)"),h=function(){f(),g&&g.addListener&&g.addListener(f)};return c.srcset="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",/^[c|i]|d$/.test(document.readyState||"")?h():document.addEventListener("DOMContentLoaded",h),f}())}(window),function(a,b,c){"use strict";function d(a){return" "===a||"	"===a||"\n"===a||"\f"===a||"\r"===a}function e(b,c){var d=new a.Image;return d.onerror=function(){A[b]=!1,ba()},d.onload=function(){A[b]=1===d.width,ba()},d.src=c,"pending"}function f(){M=!1,P=a.devicePixelRatio,N={},O={},s.DPR=P||1,Q.width=Math.max(a.innerWidth||0,z.clientWidth),Q.height=Math.max(a.innerHeight||0,z.clientHeight),Q.vw=Q.width/100,Q.vh=Q.height/100,r=[Q.height,Q.width,P].join("-"),Q.em=s.getEmValue(),Q.rem=Q.em}function g(a,b,c,d){var e,f,g,h;return"saveData"===B.algorithm?a>2.7?h=c+1:(f=b-c,e=Math.pow(a-.6,1.5),g=f*e,d&&(g+=.1*e),h=a+g):h=c>1?Math.sqrt(a*b):a,h>c}function h(a){var b,c=s.getSet(a),d=!1;"pending"!==c&&(d=r,c&&(b=s.setRes(c),s.applySetCandidate(b,a))),a[s.ns].evaled=d}function i(a,b){return a.res-b.res}function j(a,b,c){var d;return!c&&b&&(c=a[s.ns].sets,c=c&&c[c.length-1]),d=k(b,c),d&&(b=s.makeUrl(b),a[s.ns].curSrc=b,a[s.ns].curCan=d,d.res||aa(d,d.set.sizes)),d}function k(a,b){var c,d,e;if(a&&b)for(e=s.parseSet(b),a=s.makeUrl(a),c=0;c<e.length;c++)if(a===s.makeUrl(e[c].url)){d=e[c];break}return d}function l(a,b){var c,d,e,f,g=a.getElementsByTagName("source");for(c=0,d=g.length;d>c;c++)e=g[c],e[s.ns]=!0,f=e.getAttribute("srcset"),f&&b.push({srcset:f,media:e.getAttribute("media"),type:e.getAttribute("type"),sizes:e.getAttribute("sizes")})}function m(a,b){function c(b){var c,d=b.exec(a.substring(m));return d?(c=d[0],m+=c.length,c):void 0}function e(){var a,c,d,e,f,i,j,k,l,m=!1,o={};for(e=0;e<h.length;e++)f=h[e],i=f[f.length-1],j=f.substring(0,f.length-1),k=parseInt(j,10),l=parseFloat(j),X.test(j)&&"w"===i?((a||c)&&(m=!0),0===k?m=!0:a=k):Y.test(j)&&"x"===i?((a||c||d)&&(m=!0),0>l?m=!0:c=l):X.test(j)&&"h"===i?((d||c)&&(m=!0),0===k?m=!0:d=k):m=!0;m||(o.url=g,a&&(o.w=a),c&&(o.d=c),d&&(o.h=d),d||c||a||(o.d=1),1===o.d&&(b.has1x=!0),o.set=b,n.push(o))}function f(){for(c(T),i="",j="in descriptor";;){if(k=a.charAt(m),"in descriptor"===j)if(d(k))i&&(h.push(i),i="",j="after descriptor");else{if(","===k)return m+=1,i&&h.push(i),void e();if("("===k)i+=k,j="in parens";else{if(""===k)return i&&h.push(i),void e();i+=k}}else if("in parens"===j)if(")"===k)i+=k,j="in descriptor";else{if(""===k)return h.push(i),void e();i+=k}else if("after descriptor"===j)if(d(k));else{if(""===k)return void e();j="in descriptor",m-=1}m+=1}}for(var g,h,i,j,k,l=a.length,m=0,n=[];;){if(c(U),m>=l)return n;g=c(V),h=[],","===g.slice(-1)?(g=g.replace(W,""),e()):f()}}function n(a){function b(a){function b(){f&&(g.push(f),f="")}function c(){g[0]&&(h.push(g),g=[])}for(var e,f="",g=[],h=[],i=0,j=0,k=!1;;){if(e=a.charAt(j),""===e)return b(),c(),h;if(k){if("*"===e&&"/"===a[j+1]){k=!1,j+=2,b();continue}j+=1}else{if(d(e)){if(a.charAt(j-1)&&d(a.charAt(j-1))||!f){j+=1;continue}if(0===i){b(),j+=1;continue}e=" "}else if("("===e)i+=1;else if(")"===e)i-=1;else{if(","===e){b(),c(),j+=1;continue}if("/"===e&&"*"===a.charAt(j+1)){k=!0,j+=2;continue}}f+=e,j+=1}}}function c(a){return k.test(a)&&parseFloat(a)>=0?!0:l.test(a)?!0:"0"===a||"-0"===a||"+0"===a?!0:!1}var e,f,g,h,i,j,k=/^(?:[+-]?[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?(?:ch|cm|em|ex|in|mm|pc|pt|px|rem|vh|vmin|vmax|vw)$/i,l=/^calc\((?:[0-9a-z \.\+\-\*\/\(\)]+)\)$/i;for(f=b(a),g=f.length,e=0;g>e;e++)if(h=f[e],i=h[h.length-1],c(i)){if(j=i,h.pop(),0===h.length)return j;if(h=h.join(" "),s.matchesMedia(h))return j}return"100vw"}b.createElement("picture");var o,p,q,r,s={},t=!1,u=function(){},v=b.createElement("img"),w=v.getAttribute,x=v.setAttribute,y=v.removeAttribute,z=b.documentElement,A={},B={algorithm:""},C="data-pfsrc",D=C+"set",E=navigator.userAgent,F=/rident/.test(E)||/ecko/.test(E)&&E.match(/rv\:(\d+)/)&&RegExp.$1>35,G="currentSrc",H=/\s+\+?\d+(e\d+)?w/,I=/(\([^)]+\))?\s*(.+)/,J=a.picturefillCFG,K="position:absolute;left:0;visibility:hidden;display:block;padding:0;border:none;font-size:1em;width:1em;overflow:hidden;clip:rect(0px, 0px, 0px, 0px)",L="font-size:100%!important;",M=!0,N={},O={},P=a.devicePixelRatio,Q={px:1,"in":96},R=b.createElement("a"),S=!1,T=/^[ \t\n\r\u000c]+/,U=/^[, \t\n\r\u000c]+/,V=/^[^ \t\n\r\u000c]+/,W=/[,]+$/,X=/^\d+$/,Y=/^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/,Z=function(a,b,c,d){a.addEventListener?a.addEventListener(b,c,d||!1):a.attachEvent&&a.attachEvent("on"+b,c)},$=function(a){var b={};return function(c){return c in b||(b[c]=a(c)),b[c]}},_=function(){var a=/^([\d\.]+)(em|vw|px)$/,b=function(){for(var a=arguments,b=0,c=a[0];++b in a;)c=c.replace(a[b],a[++b]);return c},c=$(function(a){return"return "+b((a||"").toLowerCase(),/\band\b/g,"&&",/,/g,"||",/min-([a-z-\s]+):/g,"e.$1>=",/max-([a-z-\s]+):/g,"e.$1<=",/calc([^)]+)/g,"($1)",/(\d+[\.]*[\d]*)([a-z]+)/g,"($1 * e.$2)",/^(?!(e.[a-z]|[0-9\.&=|><\+\-\*\(\)\/])).*/gi,"")+";"});return function(b,d){var e;if(!(b in N))if(N[b]=!1,d&&(e=b.match(a)))N[b]=e[1]*Q[e[2]];else try{N[b]=new Function("e",c(b))(Q)}catch(f){}return N[b]}}(),aa=function(a,b){return a.w?(a.cWidth=s.calcListLength(b||"100vw"),a.res=a.w/a.cWidth):a.res=a.d,a},ba=function(a){if(t){var c,d,e,f=a||{};if(f.elements&&1===f.elements.nodeType&&("IMG"===f.elements.nodeName.toUpperCase()?f.elements=[f.elements]:(f.context=f.elements,f.elements=null)),c=f.elements||s.qsa(f.context||b,f.reevaluate||f.reselect?s.sel:s.selShort),e=c.length){for(s.setupRun(f),S=!0,d=0;e>d;d++)s.fillImg(c[d],f);s.teardownRun(f)}}};o=a.console&&console.warn?function(a){console.warn(a)}:u,G in v||(G="src"),A["image/jpeg"]=!0,A["image/gif"]=!0,A["image/png"]=!0,A["image/svg+xml"]=b.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image","1.1"),s.ns=("pf"+(new Date).getTime()).substr(0,9),s.supSrcset="srcset"in v,s.supSizes="sizes"in v,s.supPicture=!!a.HTMLPictureElement,s.supSrcset&&s.supPicture&&!s.supSizes&&!function(a){v.srcset="data:,a",a.src="data:,a",s.supSrcset=v.complete===a.complete,s.supPicture=s.supSrcset&&s.supPicture}(b.createElement("img")),s.supSrcset&&!s.supSizes?!function(){var a="data:image/gif;base64,R0lGODlhAgABAPAAAP///wAAACH5BAAAAAAALAAAAAACAAEAAAICBAoAOw==",c="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",d=b.createElement("img"),e=function(){var a=d.width;2===a&&(s.supSizes=!0),q=s.supSrcset&&!s.supSizes,t=!0,setTimeout(ba)};d.onload=e,d.onerror=e,d.setAttribute("sizes","9px"),d.srcset=c+" 1w,"+a+" 9w",d.src=c}():t=!0,s.selShort="picture>img,img[srcset]",s.sel=s.selShort,s.cfg=B,s.DPR=P||1,s.u=Q,s.types=A,s.setSize=u,s.makeUrl=$(function(a){return R.href=a,R.href}),s.qsa=function(a,b){return"querySelector"in a?a.querySelectorAll(b):[]},s.matchesMedia=function(){return a.matchMedia&&(matchMedia("(min-width: 0.1em)")||{}).matches?s.matchesMedia=function(a){return!a||matchMedia(a).matches}:s.matchesMedia=s.mMQ,s.matchesMedia.apply(this,arguments)},s.mMQ=function(a){return a?_(a):!0},s.calcLength=function(a){var b=_(a,!0)||!1;return 0>b&&(b=!1),b},s.supportsType=function(a){return a?A[a]:!0},s.parseSize=$(function(a){var b=(a||"").match(I);return{media:b&&b[1],length:b&&b[2]}}),s.parseSet=function(a){return a.cands||(a.cands=m(a.srcset,a)),a.cands},s.getEmValue=function(){var a;if(!p&&(a=b.body)){var c=b.createElement("div"),d=z.style.cssText,e=a.style.cssText;c.style.cssText=K,z.style.cssText=L,a.style.cssText=L,a.appendChild(c),p=c.offsetWidth,a.removeChild(c),p=parseFloat(p,10),z.style.cssText=d,a.style.cssText=e}return p||16},s.calcListLength=function(a){if(!(a in O)||B.uT){var b=s.calcLength(n(a));O[a]=b?b:Q.width}return O[a]},s.setRes=function(a){var b;if(a){b=s.parseSet(a);for(var c=0,d=b.length;d>c;c++)aa(b[c],a.sizes)}return b},s.setRes.res=aa,s.applySetCandidate=function(a,b){if(a.length){var c,d,e,f,h,k,l,m,n,o=b[s.ns],p=s.DPR;if(k=o.curSrc||b[G],l=o.curCan||j(b,k,a[0].set),l&&l.set===a[0].set&&(n=F&&!b.complete&&l.res-.1>p,n||(l.cached=!0,l.res>=p&&(h=l))),!h)for(a.sort(i),f=a.length,h=a[f-1],d=0;f>d;d++)if(c=a[d],c.res>=p){e=d-1,h=a[e]&&(n||k!==s.makeUrl(c.url))&&g(a[e].res,c.res,p,a[e].cached)?a[e]:c;break}h&&(m=s.makeUrl(h.url),o.curSrc=m,o.curCan=h,m!==k&&s.setSrc(b,h),s.setSize(b))}},s.setSrc=function(a,b){var c;a.src=b.url,"image/svg+xml"===b.set.type&&(c=a.style.width,a.style.width=a.offsetWidth+1+"px",a.offsetWidth+1&&(a.style.width=c))},s.getSet=function(a){var b,c,d,e=!1,f=a[s.ns].sets;for(b=0;b<f.length&&!e;b++)if(c=f[b],c.srcset&&s.matchesMedia(c.media)&&(d=s.supportsType(c.type))){"pending"===d&&(c=d),e=c;break}return e},s.parseSets=function(a,b,d){var e,f,g,h,i=b&&"PICTURE"===b.nodeName.toUpperCase(),j=a[s.ns];(j.src===c||d.src)&&(j.src=w.call(a,"src"),j.src?x.call(a,C,j.src):y.call(a,C)),(j.srcset===c||d.srcset||!s.supSrcset||a.srcset)&&(e=w.call(a,"srcset"),j.srcset=e,h=!0),j.sets=[],i&&(j.pic=!0,l(b,j.sets)),j.srcset?(f={srcset:j.srcset,sizes:w.call(a,"sizes")},j.sets.push(f),g=(q||j.src)&&H.test(j.srcset||""),g||!j.src||k(j.src,f)||f.has1x||(f.srcset+=", "+j.src,f.cands.push({url:j.src,d:1,set:f}))):j.src&&j.sets.push({srcset:j.src,sizes:null}),j.curCan=null,j.curSrc=c,j.supported=!(i||f&&!s.supSrcset||g&&!s.supSizes),h&&s.supSrcset&&!j.supported&&(e?(x.call(a,D,e),a.srcset=""):y.call(a,D)),j.supported&&!j.srcset&&(!j.src&&a.src||a.src!==s.makeUrl(j.src))&&(null===j.src?a.removeAttribute("src"):a.src=j.src),j.parsed=!0},s.fillImg=function(a,b){var c,d=b.reselect||b.reevaluate;a[s.ns]||(a[s.ns]={}),c=a[s.ns],(d||c.evaled!==r)&&((!c.parsed||b.reevaluate)&&s.parseSets(a,a.parentNode,b),c.supported?c.evaled=r:h(a))},s.setupRun=function(){(!S||M||P!==a.devicePixelRatio)&&f()},s.supPicture?(ba=u,s.fillImg=u):!function(){var c,d=a.attachEvent?/d$|^c/:/d$|^c|^i/,e=function(){var a=b.readyState||"";f=setTimeout(e,"loading"===a?200:999),b.body&&(s.fillImgs(),c=c||d.test(a),c&&clearTimeout(f))},f=setTimeout(e,b.body?9:99),g=function(a,b){var c,d,e=function(){var f=new Date-d;b>f?c=setTimeout(e,b-f):(c=null,a())};return function(){d=new Date,c||(c=setTimeout(e,b))}},h=z.clientHeight,i=function(){M=Math.max(a.innerWidth||0,z.clientWidth)!==Q.width||z.clientHeight!==h,h=z.clientHeight,M&&s.fillImgs()};Z(a,"resize",g(i,99)),Z(b,"readystatechange",e)}(),s.picturefill=ba,s.fillImgs=ba,s.teardownRun=u,ba._=s,a.picturefillCFG={pf:s,push:function(a){var b=a.shift();"function"==typeof s[b]?s[b].apply(s,a):(B[b]=a[0],S&&s.fillImgs({reselect:!0}))}};for(;J&&J.length;)a.picturefillCFG.push(J.shift());a.picturefill=ba,"object"==typeof module&&"object"==typeof module.exports?module.exports=ba:"function"==typeof define&&define.amd&&define("picturefill",function(){return ba}),s.supPicture||(A["image/webp"]=e("image/webp","data:image/webp;base64,UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAABBxAR/Q9ERP8DAABWUDggGAAAADABAJ0BKgEAAQADADQlpAADcAD++/1QAA=="))}(window,document);
/**
 * Owl Carousel v2.3.4
 * Copyright 2013-2018 David Deutsch
 * Licensed under: SEE LICENSE IN https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE
 */
/**
 * Owl carousel
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 * @todo Lazy Load Icon
 * @todo prevent animationend bubling
 * @todo itemsScaleUp
 * @todo Test Zepto
 * @todo stagePadding calculate wrong active classes
 */
;(function($, window, document, undefined) {

	/**
	 * Creates a carousel.
	 * @class The Owl Carousel.
	 * @public
	 * @param {HTMLElement|jQuery} element - The element to create the carousel for.
	 * @param {Object} [options] - The options
	 */
	function Owl(element, options) {

		/**
		 * Current settings for the carousel.
		 * @public
		 */
		this.settings = null;

		/**
		 * Current options set by the caller including defaults.
		 * @public
		 */
		this.options = $.extend({}, Owl.Defaults, options);

		/**
		 * Plugin element.
		 * @public
		 */
		this.$element = $(element);

		/**
		 * Proxied event handlers.
		 * @protected
		 */
		this._handlers = {};

		/**
		 * References to the running plugins of this carousel.
		 * @protected
		 */
		this._plugins = {};

		/**
		 * Currently suppressed events to prevent them from being retriggered.
		 * @protected
		 */
		this._supress = {};

		/**
		 * Absolute current position.
		 * @protected
		 */
		this._current = null;

		/**
		 * Animation speed in milliseconds.
		 * @protected
		 */
		this._speed = null;

		/**
		 * Coordinates of all items in pixel.
		 * @todo The name of this member is missleading.
		 * @protected
		 */
		this._coordinates = [];

		/**
		 * Current breakpoint.
		 * @todo Real media queries would be nice.
		 * @protected
		 */
		this._breakpoint = null;

		/**
		 * Current width of the plugin element.
		 */
		this._width = null;

		/**
		 * All real items.
		 * @protected
		 */
		this._items = [];

		/**
		 * All cloned items.
		 * @protected
		 */
		this._clones = [];

		/**
		 * Merge values of all items.
		 * @todo Maybe this could be part of a plugin.
		 * @protected
		 */
		this._mergers = [];

		/**
		 * Widths of all items.
		 */
		this._widths = [];

		/**
		 * Invalidated parts within the update process.
		 * @protected
		 */
		this._invalidated = {};

		/**
		 * Ordered list of workers for the update process.
		 * @protected
		 */
		this._pipe = [];

		/**
		 * Current state information for the drag operation.
		 * @todo #261
		 * @protected
		 */
		this._drag = {
			time: null,
			target: null,
			pointer: null,
			stage: {
				start: null,
				current: null
			},
			direction: null
		};

		/**
		 * Current state information and their tags.
		 * @type {Object}
		 * @protected
		 */
		this._states = {
			current: {},
			tags: {
				'initializing': [ 'busy' ],
				'animating': [ 'busy' ],
				'dragging': [ 'interacting' ]
			}
		};

		$.each([ 'onResize', 'onThrottledResize' ], $.proxy(function(i, handler) {
			this._handlers[handler] = $.proxy(this[handler], this);
		}, this));

		$.each(Owl.Plugins, $.proxy(function(key, plugin) {
			this._plugins[key.charAt(0).toLowerCase() + key.slice(1)]
				= new plugin(this);
		}, this));

		$.each(Owl.Workers, $.proxy(function(priority, worker) {
			this._pipe.push({
				'filter': worker.filter,
				'run': $.proxy(worker.run, this)
			});
		}, this));

		this.setup();
		this.initialize();
	}

	/**
	 * Default options for the carousel.
	 * @public
	 */
	Owl.Defaults = {
		items: 3,
		loop: false,
		center: false,
		rewind: false,
		checkVisibility: true,

		mouseDrag: true,
		touchDrag: true,
		pullDrag: true,
		freeDrag: false,

		margin: 0,
		stagePadding: 0,

		merge: false,
		mergeFit: true,
		autoWidth: false,

		startPosition: 0,
		rtl: false,

		smartSpeed: 250,
		fluidSpeed: false,
		dragEndSpeed: false,

		responsive: {},
		responsiveRefreshRate: 200,
		responsiveBaseElement: window,

		fallbackEasing: 'swing',
		slideTransition: '',

		info: false,

		nestedItemSelector: false,
		itemElement: 'div',
		stageElement: 'div',

		refreshClass: 'owl-refresh',
		loadedClass: 'owl-loaded',
		loadingClass: 'owl-loading',
		rtlClass: 'owl-rtl',
		responsiveClass: 'owl-responsive',
		dragClass: 'owl-drag',
		itemClass: 'owl-item',
		stageClass: 'owl-stage',
		stageOuterClass: 'owl-stage-outer',
		grabClass: 'owl-grab'
	};

	/**
	 * Enumeration for width.
	 * @public
	 * @readonly
	 * @enum {String}
	 */
	Owl.Width = {
		Default: 'default',
		Inner: 'inner',
		Outer: 'outer'
	};

	/**
	 * Enumeration for types.
	 * @public
	 * @readonly
	 * @enum {String}
	 */
	Owl.Type = {
		Event: 'event',
		State: 'state'
	};

	/**
	 * Contains all registered plugins.
	 * @public
	 */
	Owl.Plugins = {};

	/**
	 * List of workers involved in the update process.
	 */
	Owl.Workers = [ {
		filter: [ 'width', 'settings' ],
		run: function() {
			this._width = this.$element.width();
		}
	}, {
		filter: [ 'width', 'items', 'settings' ],
		run: function(cache) {
			cache.current = this._items && this._items[this.relative(this._current)];
		}
	}, {
		filter: [ 'items', 'settings' ],
		run: function() {
			this.$stage.children('.cloned').remove();
		}
	}, {
		filter: [ 'width', 'items', 'settings' ],
		run: function(cache) {
			var margin = this.settings.margin || '',
				grid = !this.settings.autoWidth,
				rtl = this.settings.rtl,
				css = {
					'width': 'auto',
					'margin-left': rtl ? margin : '',
					'margin-right': rtl ? '' : margin
				};

			!grid && this.$stage.children().css(css);

			cache.css = css;
		}
	}, {
		filter: [ 'width', 'items', 'settings' ],
		run: function(cache) {
			var width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,
				merge = null,
				iterator = this._items.length,
				grid = !this.settings.autoWidth,
				widths = [];

			cache.items = {
				merge: false,
				width: width
			};

			while (iterator--) {
				merge = this._mergers[iterator];
				merge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge;

				cache.items.merge = merge > 1 || cache.items.merge;

				widths[iterator] = !grid ? this._items[iterator].width() : width * merge;
			}

			this._widths = widths;
		}
	}, {
		filter: [ 'items', 'settings' ],
		run: function() {
			var clones = [],
				items = this._items,
				settings = this.settings,
				// TODO: Should be computed from number of min width items in stage
				view = Math.max(settings.items * 2, 4),
				size = Math.ceil(items.length / 2) * 2,
				repeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0,
				append = '',
				prepend = '';

			repeat /= 2;

			while (repeat > 0) {
				// Switch to only using appended clones
				clones.push(this.normalize(clones.length / 2, true));
				append = append + items[clones[clones.length - 1]][0].outerHTML;
				clones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));
				prepend = items[clones[clones.length - 1]][0].outerHTML + prepend;
				repeat -= 1;
			}

			this._clones = clones;

			$(append).addClass('cloned').appendTo(this.$stage);
			$(prepend).addClass('cloned').prependTo(this.$stage);
		}
	}, {
		filter: [ 'width', 'items', 'settings' ],
		run: function() {
			var rtl = this.settings.rtl ? 1 : -1,
				size = this._clones.length + this._items.length,
				iterator = -1,
				previous = 0,
				current = 0,
				coordinates = [];

			while (++iterator < size) {
				previous = coordinates[iterator - 1] || 0;
				current = this._widths[this.relative(iterator)] + this.settings.margin;
				coordinates.push(previous + current * rtl);
			}

			this._coordinates = coordinates;
		}
	}, {
		filter: [ 'width', 'items', 'settings' ],
		run: function() {
			var padding = this.settings.stagePadding,
				coordinates = this._coordinates,
				css = {
					'width': Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,
					'padding-left': padding || '',
					'padding-right': padding || ''
				};

			this.$stage.css(css);
		}
	}, {
		filter: [ 'width', 'items', 'settings' ],
		run: function(cache) {
			var iterator = this._coordinates.length,
				grid = !this.settings.autoWidth,
				items = this.$stage.children();

			if (grid && cache.items.merge) {
				while (iterator--) {
					cache.css.width = this._widths[this.relative(iterator)];
					items.eq(iterator).css(cache.css);
				}
			} else if (grid) {
				cache.css.width = cache.items.width;
				items.css(cache.css);
			}
		}
	}, {
		filter: [ 'items' ],
		run: function() {
			this._coordinates.length < 1 && this.$stage.removeAttr('style');
		}
	}, {
		filter: [ 'width', 'items', 'settings' ],
		run: function(cache) {
			cache.current = cache.current ? this.$stage.children().index(cache.current) : 0;
			cache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));
			this.reset(cache.current);
		}
	}, {
		filter: [ 'position' ],
		run: function() {
			this.animate(this.coordinates(this._current));
		}
	}, {
		filter: [ 'width', 'position', 'items', 'settings' ],
		run: function() {
			var rtl = this.settings.rtl ? 1 : -1,
				padding = this.settings.stagePadding * 2,
				begin = this.coordinates(this.current()) + padding,
				end = begin + this.width() * rtl,
				inner, outer, matches = [], i, n;

			for (i = 0, n = this._coordinates.length; i < n; i++) {
				inner = this._coordinates[i - 1] || 0;
				outer = Math.abs(this._coordinates[i]) + padding * rtl;

				if ((this.op(inner, '<=', begin) && (this.op(inner, '>', end)))
					|| (this.op(outer, '<', begin) && this.op(outer, '>', end))) {
					matches.push(i);
				}
			}

			this.$stage.children('.active').removeClass('active');
			this.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass('active');

			this.$stage.children('.center').removeClass('center');
			if (this.settings.center) {
				this.$stage.children().eq(this.current()).addClass('center');
			}
		}
	} ];

	/**
	 * Create the stage DOM element
	 */
	Owl.prototype.initializeStage = function() {
		this.$stage = this.$element.find('.' + this.settings.stageClass);

		// if the stage is already in the DOM, grab it and skip stage initialization
		if (this.$stage.length) {
			return;
		}

		this.$element.addClass(this.options.loadingClass);

		// create stage
		this.$stage = $('<' + this.settings.stageElement + '>', {
			"class": this.settings.stageClass
		}).wrap( $( '<div/>', {
			"class": this.settings.stageOuterClass
		}));

		// append stage
		this.$element.append(this.$stage.parent());
	};

	/**
	 * Create item DOM elements
	 */
	Owl.prototype.initializeItems = function() {
		var $items = this.$element.find('.owl-item');

		// if the items are already in the DOM, grab them and skip item initialization
		if ($items.length) {
			this._items = $items.get().map(function(item) {
				return $(item);
			});

			this._mergers = this._items.map(function() {
				return 1;
			});

			this.refresh();

			return;
		}

		// append content
		this.replace(this.$element.children().not(this.$stage.parent()));

		// check visibility
		if (this.isVisible()) {
			// update view
			this.refresh();
		} else {
			// invalidate width
			this.invalidate('width');
		}

		this.$element
			.removeClass(this.options.loadingClass)
			.addClass(this.options.loadedClass);
	};

	/**
	 * Initializes the carousel.
	 * @protected
	 */
	Owl.prototype.initialize = function() {
		this.enter('initializing');
		this.trigger('initialize');

		this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);

		if (this.settings.autoWidth && !this.is('pre-loading')) {
			var imgs, nestedSelector, width;
			imgs = this.$element.find('img');
			nestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;
			width = this.$element.children(nestedSelector).width();

			if (imgs.length && width <= 0) {
				this.preloadAutoWidthImages(imgs);
			}
		}

		this.initializeStage();
		this.initializeItems();

		// register event handlers
		this.registerEventHandlers();

		this.leave('initializing');
		this.trigger('initialized');
	};

	/**
	 * @returns {Boolean} visibility of $element
	 *                    if you know the carousel will always be visible you can set `checkVisibility` to `false` to
	 *                    prevent the expensive browser layout forced reflow the $element.is(':visible') does
	 */
	Owl.prototype.isVisible = function() {
		return this.settings.checkVisibility
			? this.$element.is(':visible')
			: true;
	};

	/**
	 * Setups the current settings.
	 * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?
	 * @todo Support for media queries by using `matchMedia` would be nice.
	 * @public
	 */
	Owl.prototype.setup = function() {
		var viewport = this.viewport(),
			overwrites = this.options.responsive,
			match = -1,
			settings = null;

		if (!overwrites) {
			settings = $.extend({}, this.options);
		} else {
			$.each(overwrites, function(breakpoint) {
				if (breakpoint <= viewport && breakpoint > match) {
					match = Number(breakpoint);
				}
			});

			settings = $.extend({}, this.options, overwrites[match]);
			if (typeof settings.stagePadding === 'function') {
				settings.stagePadding = settings.stagePadding();
			}
			delete settings.responsive;

			// responsive class
			if (settings.responsiveClass) {
				this.$element.attr('class',
					this.$element.attr('class').replace(new RegExp('(' + this.options.responsiveClass + '-)\\S+\\s', 'g'), '$1' + match)
				);
			}
		}

		this.trigger('change', { property: { name: 'settings', value: settings } });
		this._breakpoint = match;
		this.settings = settings;
		this.invalidate('settings');
		this.trigger('changed', { property: { name: 'settings', value: this.settings } });
	};

	/**
	 * Updates option logic if necessery.
	 * @protected
	 */
	Owl.prototype.optionsLogic = function() {
		if (this.settings.autoWidth) {
			this.settings.stagePadding = false;
			this.settings.merge = false;
		}
	};

	/**
	 * Prepares an item before add.
	 * @todo Rename event parameter `content` to `item`.
	 * @protected
	 * @returns {jQuery|HTMLElement} - The item container.
	 */
	Owl.prototype.prepare = function(item) {
		var event = this.trigger('prepare', { content: item });

		if (!event.data) {
			event.data = $('<' + this.settings.itemElement + '/>')
				.addClass(this.options.itemClass).append(item)
		}

		this.trigger('prepared', { content: event.data });

		return event.data;
	};

	/**
	 * Updates the view.
	 * @public
	 */
	Owl.prototype.update = function() {
		var i = 0,
			n = this._pipe.length,
			filter = $.proxy(function(p) { return this[p] }, this._invalidated),
			cache = {};

		while (i < n) {
			if (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {
				this._pipe[i].run(cache);
			}
			i++;
		}

		this._invalidated = {};

		!this.is('valid') && this.enter('valid');
	};

	/**
	 * Gets the width of the view.
	 * @public
	 * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.
	 * @returns {Number} - The width of the view in pixel.
	 */
	Owl.prototype.width = function(dimension) {
		dimension = dimension || Owl.Width.Default;
		switch (dimension) {
			case Owl.Width.Inner:
			case Owl.Width.Outer:
				return this._width;
			default:
				return this._width - this.settings.stagePadding * 2 + this.settings.margin;
		}
	};

	/**
	 * Refreshes the carousel primarily for adaptive purposes.
	 * @public
	 */
	Owl.prototype.refresh = function() {
		this.enter('refreshing');
		this.trigger('refresh');

		this.setup();

		this.optionsLogic();

		this.$element.addClass(this.options.refreshClass);

		this.update();

		this.$element.removeClass(this.options.refreshClass);

		this.leave('refreshing');
		this.trigger('refreshed');
	};

	/**
	 * Checks window `resize` event.
	 * @protected
	 */
	Owl.prototype.onThrottledResize = function() {
		window.clearTimeout(this.resizeTimer);
		this.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);
	};

	/**
	 * Checks window `resize` event.
	 * @protected
	 */
	Owl.prototype.onResize = function() {
		if (!this._items.length) {
			return false;
		}

		if (this._width === this.$element.width()) {
			return false;
		}

		if (!this.isVisible()) {
			return false;
		}

		this.enter('resizing');

		if (this.trigger('resize').isDefaultPrevented()) {
			this.leave('resizing');
			return false;
		}

		this.invalidate('width');

		this.refresh();

		this.leave('resizing');
		this.trigger('resized');
	};

	/**
	 * Registers event handlers.
	 * @todo Check `msPointerEnabled`
	 * @todo #261
	 * @protected
	 */
	Owl.prototype.registerEventHandlers = function() {
		if ($.support.transition) {
			this.$stage.on($.support.transition.end + '.owl.core', $.proxy(this.onTransitionEnd, this));
		}

		if (this.settings.responsive !== false) {
			this.on(window, 'resize', this._handlers.onThrottledResize);
		}

		if (this.settings.mouseDrag) {
			this.$element.addClass(this.options.dragClass);
			this.$stage.on('mousedown.owl.core', $.proxy(this.onDragStart, this));
			this.$stage.on('dragstart.owl.core selectstart.owl.core', function() { return false });
		}

		if (this.settings.touchDrag){
			this.$stage.on('touchstart.owl.core', $.proxy(this.onDragStart, this));
			this.$stage.on('touchcancel.owl.core', $.proxy(this.onDragEnd, this));
		}
	};

	/**
	 * Handles `touchstart` and `mousedown` events.
	 * @todo Horizontal swipe threshold as option
	 * @todo #261
	 * @protected
	 * @param {Event} event - The event arguments.
	 */
	Owl.prototype.onDragStart = function(event) {
		var stage = null;

		if (event.which === 3) {
			return;
		}

		if ($.support.transform) {
			stage = this.$stage.css('transform').replace(/.*\(|\)| /g, '').split(',');
			stage = {
				x: stage[stage.length === 16 ? 12 : 4],
				y: stage[stage.length === 16 ? 13 : 5]
			};
		} else {
			stage = this.$stage.position();
			stage = {
				x: this.settings.rtl ?
					stage.left + this.$stage.width() - this.width() + this.settings.margin :
					stage.left,
				y: stage.top
			};
		}

		if (this.is('animating')) {
			$.support.transform ? this.animate(stage.x) : this.$stage.stop()
			this.invalidate('position');
		}

		this.$element.toggleClass(this.options.grabClass, event.type === 'mousedown');

		this.speed(0);

		this._drag.time = new Date().getTime();
		this._drag.target = $(event.target);
		this._drag.stage.start = stage;
		this._drag.stage.current = stage;
		this._drag.pointer = this.pointer(event);

		$(document).on('mouseup.owl.core touchend.owl.core', $.proxy(this.onDragEnd, this));

		$(document).one('mousemove.owl.core touchmove.owl.core', $.proxy(function(event) {
			var delta = this.difference(this._drag.pointer, this.pointer(event));

			$(document).on('mousemove.owl.core touchmove.owl.core', $.proxy(this.onDragMove, this));

			if (Math.abs(delta.x) < Math.abs(delta.y) && this.is('valid')) {
				return;
			}

			event.preventDefault();

			this.enter('dragging');
			this.trigger('drag');
		}, this));
	};

	/**
	 * Handles the `touchmove` and `mousemove` events.
	 * @todo #261
	 * @protected
	 * @param {Event} event - The event arguments.
	 */
	Owl.prototype.onDragMove = function(event) {
		var minimum = null,
			maximum = null,
			pull = null,
			delta = this.difference(this._drag.pointer, this.pointer(event)),
			stage = this.difference(this._drag.stage.start, delta);

		if (!this.is('dragging')) {
			return;
		}

		event.preventDefault();

		if (this.settings.loop) {
			minimum = this.coordinates(this.minimum());
			maximum = this.coordinates(this.maximum() + 1) - minimum;
			stage.x = (((stage.x - minimum) % maximum + maximum) % maximum) + minimum;
		} else {
			minimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());
			maximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());
			pull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;
			stage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);
		}

		this._drag.stage.current = stage;

		this.animate(stage.x);
	};

	/**
	 * Handles the `touchend` and `mouseup` events.
	 * @todo #261
	 * @todo Threshold for click event
	 * @protected
	 * @param {Event} event - The event arguments.
	 */
	Owl.prototype.onDragEnd = function(event) {
		var delta = this.difference(this._drag.pointer, this.pointer(event)),
			stage = this._drag.stage.current,
			direction = delta.x > 0 ^ this.settings.rtl ? 'left' : 'right';

		$(document).off('.owl.core');

		this.$element.removeClass(this.options.grabClass);

		if (delta.x !== 0 && this.is('dragging') || !this.is('valid')) {
			this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);
			this.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));
			this.invalidate('position');
			this.update();

			this._drag.direction = direction;

			if (Math.abs(delta.x) > 3 || new Date().getTime() - this._drag.time > 300) {
				this._drag.target.one('click.owl.core', function() { return false; });
			}
		}

		if (!this.is('dragging')) {
			return;
		}

		this.leave('dragging');
		this.trigger('dragged');
	};

	/**
	 * Gets absolute position of the closest item for a coordinate.
	 * @todo Setting `freeDrag` makes `closest` not reusable. See #165.
	 * @protected
	 * @param {Number} coordinate - The coordinate in pixel.
	 * @param {String} direction - The direction to check for the closest item. Ether `left` or `right`.
	 * @return {Number} - The absolute position of the closest item.
	 */
	Owl.prototype.closest = function(coordinate, direction) {
		var position = -1,
			pull = 30,
			width = this.width(),
			coordinates = this.coordinates();

		if (!this.settings.freeDrag) {
			// check closest item
			$.each(coordinates, $.proxy(function(index, value) {
				// on a left pull, check on current index
				if (direction === 'left' && coordinate > value - pull && coordinate < value + pull) {
					position = index;
				// on a right pull, check on previous index
				// to do so, subtract width from value and set position = index + 1
				} else if (direction === 'right' && coordinate > value - width - pull && coordinate < value - width + pull) {
					position = index + 1;
				} else if (this.op(coordinate, '<', value)
					&& this.op(coordinate, '>', coordinates[index + 1] !== undefined ? coordinates[index + 1] : value - width)) {
					position = direction === 'left' ? index + 1 : index;
				}
				return position === -1;
			}, this));
		}

		if (!this.settings.loop) {
			// non loop boundries
			if (this.op(coordinate, '>', coordinates[this.minimum()])) {
				position = coordinate = this.minimum();
			} else if (this.op(coordinate, '<', coordinates[this.maximum()])) {
				position = coordinate = this.maximum();
			}
		}

		return position;
	};

	/**
	 * Animates the stage.
	 * @todo #270
	 * @public
	 * @param {Number} coordinate - The coordinate in pixels.
	 */
	Owl.prototype.animate = function(coordinate) {
		var animate = this.speed() > 0;

		this.is('animating') && this.onTransitionEnd();

		if (animate) {
			this.enter('animating');
			this.trigger('translate');
		}

		if ($.support.transform3d && $.support.transition) {
			this.$stage.css({
				transform: 'translate3d(' + coordinate + 'px,0px,0px)',
				transition: (this.speed() / 1000) + 's' + (
					this.settings.slideTransition ? ' ' + this.settings.slideTransition : ''
				)
			});
		} else if (animate) {
			this.$stage.animate({
				left: coordinate + 'px'
			}, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this));
		} else {
			this.$stage.css({
				left: coordinate + 'px'
			});
		}
	};

	/**
	 * Checks whether the carousel is in a specific state or not.
	 * @param {String} state - The state to check.
	 * @returns {Boolean} - The flag which indicates if the carousel is busy.
	 */
	Owl.prototype.is = function(state) {
		return this._states.current[state] && this._states.current[state] > 0;
	};

	/**
	 * Sets the absolute position of the current item.
	 * @public
	 * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.
	 * @returns {Number} - The absolute position of the current item.
	 */
	Owl.prototype.current = function(position) {
		if (position === undefined) {
			return this._current;
		}

		if (this._items.length === 0) {
			return undefined;
		}

		position = this.normalize(position);

		if (this._current !== position) {
			var event = this.trigger('change', { property: { name: 'position', value: position } });

			if (event.data !== undefined) {
				position = this.normalize(event.data);
			}

			this._current = position;

			this.invalidate('position');

			this.trigger('changed', { property: { name: 'position', value: this._current } });
		}

		return this._current;
	};

	/**
	 * Invalidates the given part of the update routine.
	 * @param {String} [part] - The part to invalidate.
	 * @returns {Array.<String>} - The invalidated parts.
	 */
	Owl.prototype.invalidate = function(part) {
		if ($.type(part) === 'string') {
			this._invalidated[part] = true;
			this.is('valid') && this.leave('valid');
		}
		return $.map(this._invalidated, function(v, i) { return i });
	};

	/**
	 * Resets the absolute position of the current item.
	 * @public
	 * @param {Number} position - The absolute position of the new item.
	 */
	Owl.prototype.reset = function(position) {
		position = this.normalize(position);

		if (position === undefined) {
			return;
		}

		this._speed = 0;
		this._current = position;

		this.suppress([ 'translate', 'translated' ]);

		this.animate(this.coordinates(position));

		this.release([ 'translate', 'translated' ]);
	};

	/**
	 * Normalizes an absolute or a relative position of an item.
	 * @public
	 * @param {Number} position - The absolute or relative position to normalize.
	 * @param {Boolean} [relative=false] - Whether the given position is relative or not.
	 * @returns {Number} - The normalized position.
	 */
	Owl.prototype.normalize = function(position, relative) {
		var n = this._items.length,
			m = relative ? 0 : this._clones.length;

		if (!this.isNumeric(position) || n < 1) {
			position = undefined;
		} else if (position < 0 || position >= n + m) {
			position = ((position - m / 2) % n + n) % n + m / 2;
		}

		return position;
	};

	/**
	 * Converts an absolute position of an item into a relative one.
	 * @public
	 * @param {Number} position - The absolute position to convert.
	 * @returns {Number} - The converted position.
	 */
	Owl.prototype.relative = function(position) {
		position -= this._clones.length / 2;
		return this.normalize(position, true);
	};

	/**
	 * Gets the maximum position for the current item.
	 * @public
	 * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
	 * @returns {Number}
	 */
	Owl.prototype.maximum = function(relative) {
		var settings = this.settings,
			maximum = this._coordinates.length,
			iterator,
			reciprocalItemsWidth,
			elementWidth;

		if (settings.loop) {
			maximum = this._clones.length / 2 + this._items.length - 1;
		} else if (settings.autoWidth || settings.merge) {
			iterator = this._items.length;
			if (iterator) {
				reciprocalItemsWidth = this._items[--iterator].width();
				elementWidth = this.$element.width();
				while (iterator--) {
					reciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;
					if (reciprocalItemsWidth > elementWidth) {
						break;
					}
				}
			}
			maximum = iterator + 1;
		} else if (settings.center) {
			maximum = this._items.length - 1;
		} else {
			maximum = this._items.length - settings.items;
		}

		if (relative) {
			maximum -= this._clones.length / 2;
		}

		return Math.max(maximum, 0);
	};

	/**
	 * Gets the minimum position for the current item.
	 * @public
	 * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
	 * @returns {Number}
	 */
	Owl.prototype.minimum = function(relative) {
		return relative ? 0 : this._clones.length / 2;
	};

	/**
	 * Gets an item at the specified relative position.
	 * @public
	 * @param {Number} [position] - The relative position of the item.
	 * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
	 */
	Owl.prototype.items = function(position) {
		if (position === undefined) {
			return this._items.slice();
		}

		position = this.normalize(position, true);
		return this._items[position];
	};

	/**
	 * Gets an item at the specified relative position.
	 * @public
	 * @param {Number} [position] - The relative position of the item.
	 * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
	 */
	Owl.prototype.mergers = function(position) {
		if (position === undefined) {
			return this._mergers.slice();
		}

		position = this.normalize(position, true);
		return this._mergers[position];
	};

	/**
	 * Gets the absolute positions of clones for an item.
	 * @public
	 * @param {Number} [position] - The relative position of the item.
	 * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.
	 */
	Owl.prototype.clones = function(position) {
		var odd = this._clones.length / 2,
			even = odd + this._items.length,
			map = function(index) { return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2 };

		if (position === undefined) {
			return $.map(this._clones, function(v, i) { return map(i) });
		}

		return $.map(this._clones, function(v, i) { return v === position ? map(i) : null });
	};

	/**
	 * Sets the current animation speed.
	 * @public
	 * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.
	 * @returns {Number} - The current animation speed in milliseconds.
	 */
	Owl.prototype.speed = function(speed) {
		if (speed !== undefined) {
			this._speed = speed;
		}

		return this._speed;
	};

	/**
	 * Gets the coordinate of an item.
	 * @todo The name of this method is missleanding.
	 * @public
	 * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.
	 * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.
	 */
	Owl.prototype.coordinates = function(position) {
		var multiplier = 1,
			newPosition = position - 1,
			coordinate;

		if (position === undefined) {
			return $.map(this._coordinates, $.proxy(function(coordinate, index) {
				return this.coordinates(index);
			}, this));
		}

		if (this.settings.center) {
			if (this.settings.rtl) {
				multiplier = -1;
				newPosition = position + 1;
			}

			coordinate = this._coordinates[position];
			coordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;
		} else {
			coordinate = this._coordinates[newPosition] || 0;
		}

		coordinate = Math.ceil(coordinate);

		return coordinate;
	};

	/**
	 * Calculates the speed for a translation.
	 * @protected
	 * @param {Number} from - The absolute position of the start item.
	 * @param {Number} to - The absolute position of the target item.
	 * @param {Number} [factor=undefined] - The time factor in milliseconds.
	 * @returns {Number} - The time in milliseconds for the translation.
	 */
	Owl.prototype.duration = function(from, to, factor) {
		if (factor === 0) {
			return 0;
		}

		return Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs((factor || this.settings.smartSpeed));
	};

	/**
	 * Slides to the specified item.
	 * @public
	 * @param {Number} position - The position of the item.
	 * @param {Number} [speed] - The time in milliseconds for the transition.
	 */
	Owl.prototype.to = function(position, speed) {
		var current = this.current(),
			revert = null,
			distance = position - this.relative(current),
			direction = (distance > 0) - (distance < 0),
			items = this._items.length,
			minimum = this.minimum(),
			maximum = this.maximum();

		if (this.settings.loop) {
			if (!this.settings.rewind && Math.abs(distance) > items / 2) {
				distance += direction * -1 * items;
			}

			position = current + distance;
			revert = ((position - minimum) % items + items) % items + minimum;

			if (revert !== position && revert - distance <= maximum && revert - distance > 0) {
				current = revert - distance;
				position = revert;
				this.reset(current);
			}
		} else if (this.settings.rewind) {
			maximum += 1;
			position = (position % maximum + maximum) % maximum;
		} else {
			position = Math.max(minimum, Math.min(maximum, position));
		}

		this.speed(this.duration(current, position, speed));
		this.current(position);

		if (this.isVisible()) {
			this.update();
		}
	};

	/**
	 * Slides to the next item.
	 * @public
	 * @param {Number} [speed] - The time in milliseconds for the transition.
	 */
	Owl.prototype.next = function(speed) {
		speed = speed || false;
		this.to(this.relative(this.current()) + 1, speed);
	};

	/**
	 * Slides to the previous item.
	 * @public
	 * @param {Number} [speed] - The time in milliseconds for the transition.
	 */
	Owl.prototype.prev = function(speed) {
		speed = speed || false;
		this.to(this.relative(this.current()) - 1, speed);
	};

	/**
	 * Handles the end of an animation.
	 * @protected
	 * @param {Event} event - The event arguments.
	 */
	Owl.prototype.onTransitionEnd = function(event) {

		// if css2 animation then event object is undefined
		if (event !== undefined) {
			event.stopPropagation();

			// Catch only owl-stage transitionEnd event
			if ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {
				return false;
			}
		}

		this.leave('animating');
		this.trigger('translated');
	};

	/**
	 * Gets viewport width.
	 * @protected
	 * @return {Number} - The width in pixel.
	 */
	Owl.prototype.viewport = function() {
		var width;
		if (this.options.responsiveBaseElement !== window) {
			width = $(this.options.responsiveBaseElement).width();
		} else if (window.innerWidth) {
			width = window.innerWidth;
		} else if (document.documentElement && document.documentElement.clientWidth) {
			width = document.documentElement.clientWidth;
		} else {
			console.warn('Can not detect viewport width.');
		}
		return width;
	};

	/**
	 * Replaces the current content.
	 * @public
	 * @param {HTMLElement|jQuery|String} content - The new content.
	 */
	Owl.prototype.replace = function(content) {
		this.$stage.empty();
		this._items = [];

		if (content) {
			content = (content instanceof jQuery) ? content : $(content);
		}

		if (this.settings.nestedItemSelector) {
			content = content.find('.' + this.settings.nestedItemSelector);
		}

		content.filter(function() {
			return this.nodeType === 1;
		}).each($.proxy(function(index, item) {
			item = this.prepare(item);
			this.$stage.append(item);
			this._items.push(item);
			this._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
		}, this));

		this.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);

		this.invalidate('items');
	};

	/**
	 * Adds an item.
	 * @todo Use `item` instead of `content` for the event arguments.
	 * @public
	 * @param {HTMLElement|jQuery|String} content - The item content to add.
	 * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.
	 */
	Owl.prototype.add = function(content, position) {
		var current = this.relative(this._current);

		position = position === undefined ? this._items.length : this.normalize(position, true);
		content = content instanceof jQuery ? content : $(content);

		this.trigger('add', { content: content, position: position });

		content = this.prepare(content);

		if (this._items.length === 0 || position === this._items.length) {
			this._items.length === 0 && this.$stage.append(content);
			this._items.length !== 0 && this._items[position - 1].after(content);
			this._items.push(content);
			this._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
		} else {
			this._items[position].before(content);
			this._items.splice(position, 0, content);
			this._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
		}

		this._items[current] && this.reset(this._items[current].index());

		this.invalidate('items');

		this.trigger('added', { content: content, position: position });
	};

	/**
	 * Removes an item by its position.
	 * @todo Use `item` instead of `content` for the event arguments.
	 * @public
	 * @param {Number} position - The relative position of the item to remove.
	 */
	Owl.prototype.remove = function(position) {
		position = this.normalize(position, true);

		if (position === undefined) {
			return;
		}

		this.trigger('remove', { content: this._items[position], position: position });

		this._items[position].remove();
		this._items.splice(position, 1);
		this._mergers.splice(position, 1);

		this.invalidate('items');

		this.trigger('removed', { content: null, position: position });
	};

	/**
	 * Preloads images with auto width.
	 * @todo Replace by a more generic approach
	 * @protected
	 */
	Owl.prototype.preloadAutoWidthImages = function(images) {
		images.each($.proxy(function(i, element) {
			this.enter('pre-loading');
			element = $(element);
			$(new Image()).one('load', $.proxy(function(e) {
				element.attr('src', e.target.src);
				element.css('opacity', 1);
				this.leave('pre-loading');
				!this.is('pre-loading') && !this.is('initializing') && this.refresh();
			}, this)).attr('src', element.attr('src') || element.attr('data-src') || element.attr('data-src-retina'));
		}, this));
	};

	/**
	 * Destroys the carousel.
	 * @public
	 */
	Owl.prototype.destroy = function() {

		this.$element.off('.owl.core');
		this.$stage.off('.owl.core');
		$(document).off('.owl.core');

		if (this.settings.responsive !== false) {
			window.clearTimeout(this.resizeTimer);
			this.off(window, 'resize', this._handlers.onThrottledResize);
		}

		for (var i in this._plugins) {
			this._plugins[i].destroy();
		}

		this.$stage.children('.cloned').remove();

		this.$stage.unwrap();
		this.$stage.children().contents().unwrap();
		this.$stage.children().unwrap();
		this.$stage.remove();
		this.$element
			.removeClass(this.options.refreshClass)
			.removeClass(this.options.loadingClass)
			.removeClass(this.options.loadedClass)
			.removeClass(this.options.rtlClass)
			.removeClass(this.options.dragClass)
			.removeClass(this.options.grabClass)
			.attr('class', this.$element.attr('class').replace(new RegExp(this.options.responsiveClass + '-\\S+\\s', 'g'), ''))
			.removeData('owl.carousel');
	};

	/**
	 * Operators to calculate right-to-left and left-to-right.
	 * @protected
	 * @param {Number} [a] - The left side operand.
	 * @param {String} [o] - The operator.
	 * @param {Number} [b] - The right side operand.
	 */
	Owl.prototype.op = function(a, o, b) {
		var rtl = this.settings.rtl;
		switch (o) {
			case '<':
				return rtl ? a > b : a < b;
			case '>':
				return rtl ? a < b : a > b;
			case '>=':
				return rtl ? a <= b : a >= b;
			case '<=':
				return rtl ? a >= b : a <= b;
			default:
				break;
		}
	};

	/**
	 * Attaches to an internal event.
	 * @protected
	 * @param {HTMLElement} element - The event source.
	 * @param {String} event - The event name.
	 * @param {Function} listener - The event handler to attach.
	 * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.
	 */
	Owl.prototype.on = function(element, event, listener, capture) {
		if (element.addEventListener) {
			element.addEventListener(event, listener, capture);
		} else if (element.attachEvent) {
			element.attachEvent('on' + event, listener);
		}
	};

	/**
	 * Detaches from an internal event.
	 * @protected
	 * @param {HTMLElement} element - The event source.
	 * @param {String} event - The event name.
	 * @param {Function} listener - The attached event handler to detach.
	 * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.
	 */
	Owl.prototype.off = function(element, event, listener, capture) {
		if (element.removeEventListener) {
			element.removeEventListener(event, listener, capture);
		} else if (element.detachEvent) {
			element.detachEvent('on' + event, listener);
		}
	};

	/**
	 * Triggers a public event.
	 * @todo Remove `status`, `relatedTarget` should be used instead.
	 * @protected
	 * @param {String} name - The event name.
	 * @param {*} [data=null] - The event data.
	 * @param {String} [namespace=carousel] - The event namespace.
	 * @param {String} [state] - The state which is associated with the event.
	 * @param {Boolean} [enter=false] - Indicates if the call enters the specified state or not.
	 * @returns {Event} - The event arguments.
	 */
	Owl.prototype.trigger = function(name, data, namespace, state, enter) {
		var status = {
			item: { count: this._items.length, index: this.current() }
		}, handler = $.camelCase(
			$.grep([ 'on', name, namespace ], function(v) { return v })
				.join('-').toLowerCase()
		), event = $.Event(
			[ name, 'owl', namespace || 'carousel' ].join('.').toLowerCase(),
			$.extend({ relatedTarget: this }, status, data)
		);

		if (!this._supress[name]) {
			$.each(this._plugins, function(name, plugin) {
				if (plugin.onTrigger) {
					plugin.onTrigger(event);
				}
			});

			this.register({ type: Owl.Type.Event, name: name });
			this.$element.trigger(event);

			if (this.settings && typeof this.settings[handler] === 'function') {
				this.settings[handler].call(this, event);
			}
		}

		return event;
	};

	/**
	 * Enters a state.
	 * @param name - The state name.
	 */
	Owl.prototype.enter = function(name) {
		$.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {
			if (this._states.current[name] === undefined) {
				this._states.current[name] = 0;
			}

			this._states.current[name]++;
		}, this));
	};

	/**
	 * Leaves a state.
	 * @param name - The state name.
	 */
	Owl.prototype.leave = function(name) {
		$.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {
			this._states.current[name]--;
		}, this));
	};

	/**
	 * Registers an event or state.
	 * @public
	 * @param {Object} object - The event or state to register.
	 */
	Owl.prototype.register = function(object) {
		if (object.type === Owl.Type.Event) {
			if (!$.event.special[object.name]) {
				$.event.special[object.name] = {};
			}

			if (!$.event.special[object.name].owl) {
				var _default = $.event.special[object.name]._default;
				$.event.special[object.name]._default = function(e) {
					if (_default && _default.apply && (!e.namespace || e.namespace.indexOf('owl') === -1)) {
						return _default.apply(this, arguments);
					}
					return e.namespace && e.namespace.indexOf('owl') > -1;
				};
				$.event.special[object.name].owl = true;
			}
		} else if (object.type === Owl.Type.State) {
			if (!this._states.tags[object.name]) {
				this._states.tags[object.name] = object.tags;
			} else {
				this._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);
			}

			this._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function(tag, i) {
				return $.inArray(tag, this._states.tags[object.name]) === i;
			}, this));
		}
	};

	/**
	 * Suppresses events.
	 * @protected
	 * @param {Array.<String>} events - The events to suppress.
	 */
	Owl.prototype.suppress = function(events) {
		$.each(events, $.proxy(function(index, event) {
			this._supress[event] = true;
		}, this));
	};

	/**
	 * Releases suppressed events.
	 * @protected
	 * @param {Array.<String>} events - The events to release.
	 */
	Owl.prototype.release = function(events) {
		$.each(events, $.proxy(function(index, event) {
			delete this._supress[event];
		}, this));
	};

	/**
	 * Gets unified pointer coordinates from event.
	 * @todo #261
	 * @protected
	 * @param {Event} - The `mousedown` or `touchstart` event.
	 * @returns {Object} - Contains `x` and `y` coordinates of current pointer position.
	 */
	Owl.prototype.pointer = function(event) {
		var result = { x: null, y: null };

		event = event.originalEvent || event || window.event;

		event = event.touches && event.touches.length ?
			event.touches[0] : event.changedTouches && event.changedTouches.length ?
				event.changedTouches[0] : event;

		if (event.pageX) {
			result.x = event.pageX;
			result.y = event.pageY;
		} else {
			result.x = event.clientX;
			result.y = event.clientY;
		}

		return result;
	};

	/**
	 * Determines if the input is a Number or something that can be coerced to a Number
	 * @protected
	 * @param {Number|String|Object|Array|Boolean|RegExp|Function|Symbol} - The input to be tested
	 * @returns {Boolean} - An indication if the input is a Number or can be coerced to a Number
	 */
	Owl.prototype.isNumeric = function(number) {
		return !isNaN(parseFloat(number));
	};

	/**
	 * Gets the difference of two vectors.
	 * @todo #261
	 * @protected
	 * @param {Object} - The first vector.
	 * @param {Object} - The second vector.
	 * @returns {Object} - The difference.
	 */
	Owl.prototype.difference = function(first, second) {
		return {
			x: first.x - second.x,
			y: first.y - second.y
		};
	};

	/**
	 * The jQuery Plugin for the Owl Carousel
	 * @todo Navigation plugin `next` and `prev`
	 * @public
	 */
	$.fn.owlCarousel = function(option) {
		var args = Array.prototype.slice.call(arguments, 1);

		return this.each(function() {
			var $this = $(this),
				data = $this.data('owl.carousel');

			if (!data) {
				data = new Owl(this, typeof option == 'object' && option);
				$this.data('owl.carousel', data);

				$.each([
					'next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'
				], function(i, event) {
					data.register({ type: Owl.Type.Event, name: event });
					data.$element.on(event + '.owl.carousel.core', $.proxy(function(e) {
						if (e.namespace && e.relatedTarget !== this) {
							this.suppress([ event ]);
							data[event].apply(this, [].slice.call(arguments, 1));
							this.release([ event ]);
						}
					}, data));
				});
			}

			if (typeof option == 'string' && option.charAt(0) !== '_') {
				data[option].apply(data, args);
			}
		});
	};

	/**
	 * The constructor for the jQuery Plugin
	 * @public
	 */
	$.fn.owlCarousel.Constructor = Owl;

})(window.Zepto || window.jQuery, window, document);

/**
 * AutoRefresh Plugin
 * @version 2.3.4
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

	/**
	 * Creates the auto refresh plugin.
	 * @class The Auto Refresh Plugin
	 * @param {Owl} carousel - The Owl Carousel
	 */
	var AutoRefresh = function(carousel) {
		/**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
		this._core = carousel;

		/**
		 * Refresh interval.
		 * @protected
		 * @type {number}
		 */
		this._interval = null;

		/**
		 * Whether the element is currently visible or not.
		 * @protected
		 * @type {Boolean}
		 */
		this._visible = null;

		/**
		 * All event handlers.
		 * @protected
		 * @type {Object}
		 */
		this._handlers = {
			'initialized.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.autoRefresh) {
					this.watch();
				}
			}, this)
		};

		// set default options
		this._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options);

		// register event handlers
		this._core.$element.on(this._handlers);
	};

	/**
	 * Default options.
	 * @public
	 */
	AutoRefresh.Defaults = {
		autoRefresh: true,
		autoRefreshInterval: 500
	};

	/**
	 * Watches the element.
	 */
	AutoRefresh.prototype.watch = function() {
		if (this._interval) {
			return;
		}

		this._visible = this._core.isVisible();
		this._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval);
	};

	/**
	 * Refreshes the element.
	 */
	AutoRefresh.prototype.refresh = function() {
		if (this._core.isVisible() === this._visible) {
			return;
		}

		this._visible = !this._visible;

		this._core.$element.toggleClass('owl-hidden', !this._visible);

		this._visible && (this._core.invalidate('width') && this._core.refresh());
	};

	/**
	 * Destroys the plugin.
	 */
	AutoRefresh.prototype.destroy = function() {
		var handler, property;

		window.clearInterval(this._interval);

		for (handler in this._handlers) {
			this._core.$element.off(handler, this._handlers[handler]);
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] != 'function' && (this[property] = null);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh;

})(window.Zepto || window.jQuery, window, document);

/**
 * Lazy Plugin
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

	/**
	 * Creates the lazy plugin.
	 * @class The Lazy Plugin
	 * @param {Owl} carousel - The Owl Carousel
	 */
	var Lazy = function(carousel) {

		/**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
		this._core = carousel;

		/**
		 * Already loaded items.
		 * @protected
		 * @type {Array.<jQuery>}
		 */
		this._loaded = [];

		/**
		 * Event handlers.
		 * @protected
		 * @type {Object}
		 */
		this._handlers = {
			'initialized.owl.carousel change.owl.carousel resized.owl.carousel': $.proxy(function(e) {
				if (!e.namespace) {
					return;
				}

				if (!this._core.settings || !this._core.settings.lazyLoad) {
					return;
				}

				if ((e.property && e.property.name == 'position') || e.type == 'initialized') {
					var settings = this._core.settings,
						n = (settings.center && Math.ceil(settings.items / 2) || settings.items),
						i = ((settings.center && n * -1) || 0),
						position = (e.property && e.property.value !== undefined ? e.property.value : this._core.current()) + i,
						clones = this._core.clones().length,
						load = $.proxy(function(i, v) { this.load(v) }, this);
					//TODO: Need documentation for this new option
					if (settings.lazyLoadEager > 0) {
						n += settings.lazyLoadEager;
						// If the carousel is looping also preload images that are to the "left"
						if (settings.loop) {
              position -= settings.lazyLoadEager;
              n++;
            }
					}

					while (i++ < n) {
						this.load(clones / 2 + this._core.relative(position));
						clones && $.each(this._core.clones(this._core.relative(position)), load);
						position++;
					}
				}
			}, this)
		};

		// set the default options
		this._core.options = $.extend({}, Lazy.Defaults, this._core.options);

		// register event handler
		this._core.$element.on(this._handlers);
	};

	/**
	 * Default options.
	 * @public
	 */
	Lazy.Defaults = {
		lazyLoad: false,
		lazyLoadEager: 0
	};

	/**
	 * Loads all resources of an item at the specified position.
	 * @param {Number} position - The absolute position of the item.
	 * @protected
	 */
	Lazy.prototype.load = function(position) {
		var $item = this._core.$stage.children().eq(position),
			$elements = $item && $item.find('.owl-lazy');

		if (!$elements || $.inArray($item.get(0), this._loaded) > -1) {
			return;
		}

		$elements.each($.proxy(function(index, element) {
			var $element = $(element), image,
                url = (window.devicePixelRatio > 1 && $element.attr('data-src-retina')) || $element.attr('data-src') || $element.attr('data-srcset');

			this._core.trigger('load', { element: $element, url: url }, 'lazy');

			if ($element.is('img')) {
				$element.one('load.owl.lazy', $.proxy(function() {
					$element.css('opacity', 1);
					this._core.trigger('loaded', { element: $element, url: url }, 'lazy');
				}, this)).attr('src', url);
            } else if ($element.is('source')) {
                $element.one('load.owl.lazy', $.proxy(function() {
                    this._core.trigger('loaded', { element: $element, url: url }, 'lazy');
                }, this)).attr('srcset', url);
			} else {
				image = new Image();
				image.onload = $.proxy(function() {
					$element.css({
						'background-image': 'url("' + url + '")',
						'opacity': '1'
					});
					this._core.trigger('loaded', { element: $element, url: url }, 'lazy');
				}, this);
				image.src = url;
			}
		}, this));

		this._loaded.push($item.get(0));
	};

	/**
	 * Destroys the plugin.
	 * @public
	 */
	Lazy.prototype.destroy = function() {
		var handler, property;

		for (handler in this.handlers) {
			this._core.$element.off(handler, this.handlers[handler]);
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] != 'function' && (this[property] = null);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;

})(window.Zepto || window.jQuery, window, document);

/**
 * AutoHeight Plugin
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

	/**
	 * Creates the auto height plugin.
	 * @class The Auto Height Plugin
	 * @param {Owl} carousel - The Owl Carousel
	 */
	var AutoHeight = function(carousel) {
		/**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
		this._core = carousel;

		this._previousHeight = null;

		/**
		 * All event handlers.
		 * @protected
		 * @type {Object}
		 */
		this._handlers = {
			'initialized.owl.carousel refreshed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.autoHeight) {
					this.update();
				}
			}, this),
			'changed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.autoHeight && e.property.name === 'position'){
					this.update();
				}
			}, this),
			'loaded.owl.lazy': $.proxy(function(e) {
				if (e.namespace && this._core.settings.autoHeight
					&& e.element.closest('.' + this._core.settings.itemClass).index() === this._core.current()) {
					this.update();
				}
			}, this)
		};

		// set default options
		this._core.options = $.extend({}, AutoHeight.Defaults, this._core.options);

		// register event handlers
		this._core.$element.on(this._handlers);
		this._intervalId = null;
		var refThis = this;

		// These changes have been taken from a PR by gavrochelegnou proposed in #1575
		// and have been made compatible with the latest jQuery version
		$(window).on('load', function() {
			if (refThis._core.settings.autoHeight) {
				refThis.update();
			}
		});

		// Autoresize the height of the carousel when window is resized
		// When carousel has images, the height is dependent on the width
		// and should also change on resize
		$(window).resize(function() {
			if (refThis._core.settings.autoHeight) {
				if (refThis._intervalId != null) {
					clearTimeout(refThis._intervalId);
				}

				refThis._intervalId = setTimeout(function() {
					refThis.update();
				}, 250);
			}
		});

	};

	/**
	 * Default options.
	 * @public
	 */
	AutoHeight.Defaults = {
		autoHeight: false,
		autoHeightClass: 'owl-height'
	};

	/**
	 * Updates the view.
	 */
	AutoHeight.prototype.update = function() {
		var start = this._core._current,
			end = start + this._core.settings.items,
			lazyLoadEnabled = this._core.settings.lazyLoad,
			visible = this._core.$stage.children().toArray().slice(start, end),
			heights = [],
			maxheight = 0;

		$.each(visible, function(index, item) {
			heights.push($(item).height());
		});

		maxheight = Math.max.apply(null, heights);

		if (maxheight <= 1 && lazyLoadEnabled && this._previousHeight) {
			maxheight = this._previousHeight;
		}

		this._previousHeight = maxheight;

		this._core.$stage.parent()
			.height(maxheight)
			.addClass(this._core.settings.autoHeightClass);
	};

	AutoHeight.prototype.destroy = function() {
		var handler, property;

		for (handler in this._handlers) {
			this._core.$element.off(handler, this._handlers[handler]);
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] !== 'function' && (this[property] = null);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;

})(window.Zepto || window.jQuery, window, document);

/**
 * Video Plugin
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

	/**
	 * Creates the video plugin.
	 * @class The Video Plugin
	 * @param {Owl} carousel - The Owl Carousel
	 */
	var Video = function(carousel) {
		/**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
		this._core = carousel;

		/**
		 * Cache all video URLs.
		 * @protected
		 * @type {Object}
		 */
		this._videos = {};

		/**
		 * Current playing item.
		 * @protected
		 * @type {jQuery}
		 */
		this._playing = null;

		/**
		 * All event handlers.
		 * @todo The cloned content removale is too late
		 * @protected
		 * @type {Object}
		 */
		this._handlers = {
			'initialized.owl.carousel': $.proxy(function(e) {
				if (e.namespace) {
					this._core.register({ type: 'state', name: 'playing', tags: [ 'interacting' ] });
				}
			}, this),
			'resize.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.video && this.isInFullScreen()) {
					e.preventDefault();
				}
			}, this),
			'refreshed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.is('resizing')) {
					this._core.$stage.find('.cloned .owl-video-frame').remove();
				}
			}, this),
			'changed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && e.property.name === 'position' && this._playing) {
					this.stop();
				}
			}, this),
			'prepared.owl.carousel': $.proxy(function(e) {
				if (!e.namespace) {
					return;
				}

				var $element = $(e.content).find('.owl-video');

				if ($element.length) {
					$element.css('display', 'none');
					this.fetch($element, $(e.content));
				}
			}, this)
		};

		// set default options
		this._core.options = $.extend({}, Video.Defaults, this._core.options);

		// register event handlers
		this._core.$element.on(this._handlers);

		this._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function(e) {
			this.play(e);
		}, this));
	};

	/**
	 * Default options.
	 * @public
	 */
	Video.Defaults = {
		video: false,
		videoHeight: false,
		videoWidth: false
	};

	/**
	 * Gets the video ID and the type (YouTube/Vimeo/vzaar only).
	 * @protected
	 * @param {jQuery} target - The target containing the video data.
	 * @param {jQuery} item - The item containing the video.
	 */
	Video.prototype.fetch = function(target, item) {
			var type = (function() {
					if (target.attr('data-vimeo-id')) {
						return 'vimeo';
					} else if (target.attr('data-vzaar-id')) {
						return 'vzaar'
					} else {
						return 'youtube';
					}
				})(),
				id = target.attr('data-vimeo-id') || target.attr('data-youtube-id') || target.attr('data-vzaar-id'),
				width = target.attr('data-width') || this._core.settings.videoWidth,
				height = target.attr('data-height') || this._core.settings.videoHeight,
				url = target.attr('href');

		if (url) {

			/*
					Parses the id's out of the following urls (and probably more):
					https://www.youtube.com/watch?v=:id
					https://youtu.be/:id
					https://vimeo.com/:id
					https://vimeo.com/channels/:channel/:id
					https://vimeo.com/groups/:group/videos/:id
					https://app.vzaar.com/videos/:id

					Visual example: https://regexper.com/#(http%3A%7Chttps%3A%7C)%5C%2F%5C%2F(player.%7Cwww.%7Capp.)%3F(vimeo%5C.com%7Cyoutu(be%5C.com%7C%5C.be%7Cbe%5C.googleapis%5C.com)%7Cvzaar%5C.com)%5C%2F(video%5C%2F%7Cvideos%5C%2F%7Cembed%5C%2F%7Cchannels%5C%2F.%2B%5C%2F%7Cgroups%5C%2F.%2B%5C%2F%7Cwatch%5C%3Fv%3D%7Cv%5C%2F)%3F(%5BA-Za-z0-9._%25-%5D*)(%5C%26%5CS%2B)%3F
			*/

			id = url.match(/(http:|https:|)\/\/(player.|www.|app.)?(vimeo\.com|youtu(be\.com|\.be|be\.googleapis\.com|be\-nocookie\.com)|vzaar\.com)\/(video\/|videos\/|embed\/|channels\/.+\/|groups\/.+\/|watch\?v=|v\/)?([A-Za-z0-9._%-]*)(\&\S+)?/);

			if (id[3].indexOf('youtu') > -1) {
				type = 'youtube';
			} else if (id[3].indexOf('vimeo') > -1) {
				type = 'vimeo';
			} else if (id[3].indexOf('vzaar') > -1) {
				type = 'vzaar';
			} else {
				throw new Error('Video URL not supported.');
			}
			id = id[6];
		} else {
			throw new Error('Missing video URL.');
		}

		this._videos[url] = {
			type: type,
			id: id,
			width: width,
			height: height
		};

		item.attr('data-video', url);

		this.thumbnail(target, this._videos[url]);
	};

	/**
	 * Creates video thumbnail.
	 * @protected
	 * @param {jQuery} target - The target containing the video data.
	 * @param {Object} info - The video info object.
	 * @see `fetch`
	 */
	Video.prototype.thumbnail = function(target, video) {
		var tnLink,
			icon,
			path,
			dimensions = video.width && video.height ? 'width:' + video.width + 'px;height:' + video.height + 'px;' : '',
			customTn = target.find('img'),
			srcType = 'src',
			lazyClass = '',
			settings = this._core.settings,
			create = function(path) {
				icon = '<div class="owl-video-play-icon"></div>';

				if (settings.lazyLoad) {
					tnLink = $('<div/>',{
						"class": 'owl-video-tn ' + lazyClass,
						"srcType": path
					});
				} else {
					tnLink = $( '<div/>', {
						"class": "owl-video-tn",
						"style": 'opacity:1;background-image:url(' + path + ')'
					});
				}
				target.after(tnLink);
				target.after(icon);
			};

		// wrap video content into owl-video-wrapper div
		target.wrap( $( '<div/>', {
			"class": "owl-video-wrapper",
			"style": dimensions
		}));

		if (this._core.settings.lazyLoad) {
			srcType = 'data-src';
			lazyClass = 'owl-lazy';
		}

		// custom thumbnail
		if (customTn.length) {
			create(customTn.attr(srcType));
			customTn.remove();
			return false;
		}

		if (video.type === 'youtube') {
			path = "//img.youtube.com/vi/" + video.id + "/hqdefault.jpg";
			create(path);
		} else if (video.type === 'vimeo') {
			$.ajax({
				type: 'GET',
				url: '//vimeo.com/api/v2/video/' + video.id + '.json',
				jsonp: 'callback',
				dataType: 'jsonp',
				success: function(data) {
					path = data[0].thumbnail_large;
					create(path);
				}
			});
		} else if (video.type === 'vzaar') {
			$.ajax({
				type: 'GET',
				url: '//vzaar.com/api/videos/' + video.id + '.json',
				jsonp: 'callback',
				dataType: 'jsonp',
				success: function(data) {
					path = data.framegrab_url;
					create(path);
				}
			});
		}
	};

	/**
	 * Stops the current video.
	 * @public
	 */
	Video.prototype.stop = function() {
		this._core.trigger('stop', null, 'video');
		this._playing.find('.owl-video-frame').remove();
		this._playing.removeClass('owl-video-playing');
		this._playing = null;
		this._core.leave('playing');
		this._core.trigger('stopped', null, 'video');
	};

	/**
	 * Starts the current video.
	 * @public
	 * @param {Event} event - The event arguments.
	 */
	Video.prototype.play = function(event) {
		var target = $(event.target),
			item = target.closest('.' + this._core.settings.itemClass),
			video = this._videos[item.attr('data-video')],
			width = video.width || '100%',
			height = video.height || this._core.$stage.height(),
			html,
			iframe;

		if (this._playing) {
			return;
		}

		this._core.enter('playing');
		this._core.trigger('play', null, 'video');

		item = this._core.items(this._core.relative(item.index()));

		this._core.reset(item.index());

		html = $( '<iframe frameborder="0" allowfullscreen mozallowfullscreen webkitAllowFullScreen ></iframe>' );
		html.attr( 'height', height );
		html.attr( 'width', width );
		if (video.type === 'youtube') {
			html.attr( 'src', '//www.youtube.com/embed/' + video.id + '?autoplay=1&rel=0&v=' + video.id );
		} else if (video.type === 'vimeo') {
			html.attr( 'src', '//player.vimeo.com/video/' + video.id + '?autoplay=1' );
		} else if (video.type === 'vzaar') {
			html.attr( 'src', '//view.vzaar.com/' + video.id + '/player?autoplay=true' );
		}

		iframe = $(html).wrap( '<div class="owl-video-frame" />' ).insertAfter(item.find('.owl-video'));

		this._playing = item.addClass('owl-video-playing');
	};

	/**
	 * Checks whether an video is currently in full screen mode or not.
	 * @todo Bad style because looks like a readonly method but changes members.
	 * @protected
	 * @returns {Boolean}
	 */
	Video.prototype.isInFullScreen = function() {
		var element = document.fullscreenElement || document.mozFullScreenElement ||
				document.webkitFullscreenElement;

		return element && $(element).parent().hasClass('owl-video-frame');
	};

	/**
	 * Destroys the plugin.
	 */
	Video.prototype.destroy = function() {
		var handler, property;

		this._core.$element.off('click.owl.video');

		for (handler in this._handlers) {
			this._core.$element.off(handler, this._handlers[handler]);
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] != 'function' && (this[property] = null);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.Video = Video;

})(window.Zepto || window.jQuery, window, document);

/**
 * Animate Plugin
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

	/**
	 * Creates the animate plugin.
	 * @class The Navigation Plugin
	 * @param {Owl} scope - The Owl Carousel
	 */
	var Animate = function(scope) {
		this.core = scope;
		this.core.options = $.extend({}, Animate.Defaults, this.core.options);
		this.swapping = true;
		this.previous = undefined;
		this.next = undefined;

		this.handlers = {
			'change.owl.carousel': $.proxy(function(e) {
				if (e.namespace && e.property.name == 'position') {
					this.previous = this.core.current();
					this.next = e.property.value;
				}
			}, this),
			'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function(e) {
				if (e.namespace) {
					this.swapping = e.type == 'translated';
				}
			}, this),
			'translate.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {
					this.swap();
				}
			}, this)
		};

		this.core.$element.on(this.handlers);
	};

	/**
	 * Default options.
	 * @public
	 */
	Animate.Defaults = {
		animateOut: false,
		animateIn: false
	};

	/**
	 * Toggles the animation classes whenever an translations starts.
	 * @protected
	 * @returns {Boolean|undefined}
	 */
	Animate.prototype.swap = function() {

		if (this.core.settings.items !== 1) {
			return;
		}

		if (!$.support.animation || !$.support.transition) {
			return;
		}

		this.core.speed(0);

		var left,
			clear = $.proxy(this.clear, this),
			previous = this.core.$stage.children().eq(this.previous),
			next = this.core.$stage.children().eq(this.next),
			incoming = this.core.settings.animateIn,
			outgoing = this.core.settings.animateOut;

		if (this.core.current() === this.previous) {
			return;
		}

		if (outgoing) {
			left = this.core.coordinates(this.previous) - this.core.coordinates(this.next);
			previous.one($.support.animation.end, clear)
				.css( { 'left': left + 'px' } )
				.addClass('animated owl-animated-out')
				.addClass(outgoing);
		}

		if (incoming) {
			next.one($.support.animation.end, clear)
				.addClass('animated owl-animated-in')
				.addClass(incoming);
		}
	};

	Animate.prototype.clear = function(e) {
		$(e.target).css( { 'left': '' } )
			.removeClass('animated owl-animated-out owl-animated-in')
			.removeClass(this.core.settings.animateIn)
			.removeClass(this.core.settings.animateOut);
		this.core.onTransitionEnd();
	};

	/**
	 * Destroys the plugin.
	 * @public
	 */
	Animate.prototype.destroy = function() {
		var handler, property;

		for (handler in this.handlers) {
			this.core.$element.off(handler, this.handlers[handler]);
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] != 'function' && (this[property] = null);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.Animate = Animate;

})(window.Zepto || window.jQuery, window, document);

/**
 * Autoplay Plugin
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author Artus Kolanowski
 * @author David Deutsch
 * @author Tom De Caluw
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

	/**
	 * Creates the autoplay plugin.
	 * @class The Autoplay Plugin
	 * @param {Owl} scope - The Owl Carousel
	 */
	var Autoplay = function(carousel) {
		/**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
		this._core = carousel;

		/**
		 * The autoplay timeout id.
		 * @type {Number}
		 */
		this._call = null;

		/**
		 * Depending on the state of the plugin, this variable contains either
		 * the start time of the timer or the current timer value if it's
		 * paused. Since we start in a paused state we initialize the timer
		 * value.
		 * @type {Number}
		 */
		this._time = 0;

		/**
		 * Stores the timeout currently used.
		 * @type {Number}
		 */
		this._timeout = 0;

		/**
		 * Indicates whenever the autoplay is paused.
		 * @type {Boolean}
		 */
		this._paused = true;

		/**
		 * All event handlers.
		 * @protected
		 * @type {Object}
		 */
		this._handlers = {
			'changed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && e.property.name === 'settings') {
					if (this._core.settings.autoplay) {
						this.play();
					} else {
						this.stop();
					}
				} else if (e.namespace && e.property.name === 'position' && this._paused) {
					// Reset the timer. This code is triggered when the position
					// of the carousel was changed through user interaction.
					this._time = 0;
				}
			}, this),
			'initialized.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.autoplay) {
					this.play();
				}
			}, this),
			'play.owl.autoplay': $.proxy(function(e, t, s) {
				if (e.namespace) {
					this.play(t, s);
				}
			}, this),
			'stop.owl.autoplay': $.proxy(function(e) {
				if (e.namespace) {
					this.stop();
				}
			}, this),
			'mouseover.owl.autoplay': $.proxy(function() {
				if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
					this.pause();
				}
			}, this),
			'mouseleave.owl.autoplay': $.proxy(function() {
				if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
					this.play();
				}
			}, this),
			'touchstart.owl.core': $.proxy(function() {
				if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
					this.pause();
				}
			}, this),
			'touchend.owl.core': $.proxy(function() {
				if (this._core.settings.autoplayHoverPause) {
					this.play();
				}
			}, this)
		};

		// register event handlers
		this._core.$element.on(this._handlers);

		// set default options
		this._core.options = $.extend({}, Autoplay.Defaults, this._core.options);
	};

	/**
	 * Default options.
	 * @public
	 */
	Autoplay.Defaults = {
		autoplay: false,
		autoplayTimeout: 5000,
		autoplayHoverPause: false,
		autoplaySpeed: false
	};

	/**
	 * Transition to the next slide and set a timeout for the next transition.
	 * @private
	 * @param {Number} [speed] - The animation speed for the animations.
	 */
	Autoplay.prototype._next = function(speed) {
		this._call = window.setTimeout(
			$.proxy(this._next, this, speed),
			this._timeout * (Math.round(this.read() / this._timeout) + 1) - this.read()
		);

		if (this._core.is('interacting') || document.hidden) {
			return;
		}
		this._core.next(speed || this._core.settings.autoplaySpeed);
	}

	/**
	 * Reads the current timer value when the timer is playing.
	 * @public
	 */
	Autoplay.prototype.read = function() {
		return new Date().getTime() - this._time;
	};

	/**
	 * Starts the autoplay.
	 * @public
	 * @param {Number} [timeout] - The interval before the next animation starts.
	 * @param {Number} [speed] - The animation speed for the animations.
	 */
	Autoplay.prototype.play = function(timeout, speed) {
		var elapsed;

		if (!this._core.is('rotating')) {
			this._core.enter('rotating');
		}

		timeout = timeout || this._core.settings.autoplayTimeout;

		// Calculate the elapsed time since the last transition. If the carousel
		// wasn't playing this calculation will yield zero.
		elapsed = Math.min(this._time % (this._timeout || timeout), timeout);

		if (this._paused) {
			// Start the clock.
			this._time = this.read();
			this._paused = false;
		} else {
			// Clear the active timeout to allow replacement.
			window.clearTimeout(this._call);
		}

		// Adjust the origin of the timer to match the new timeout value.
		this._time += this.read() % timeout - elapsed;

		this._timeout = timeout;
		this._call = window.setTimeout($.proxy(this._next, this, speed), timeout - elapsed);
	};

	/**
	 * Stops the autoplay.
	 * @public
	 */
	Autoplay.prototype.stop = function() {
		if (this._core.is('rotating')) {
			// Reset the clock.
			this._time = 0;
			this._paused = true;

			window.clearTimeout(this._call);
			this._core.leave('rotating');
		}
	};

	/**
	 * Pauses the autoplay.
	 * @public
	 */
	Autoplay.prototype.pause = function() {
		if (this._core.is('rotating') && !this._paused) {
			// Pause the clock.
			this._time = this.read();
			this._paused = true;

			window.clearTimeout(this._call);
		}
	};

	/**
	 * Destroys the plugin.
	 */
	Autoplay.prototype.destroy = function() {
		var handler, property;

		this.stop();

		for (handler in this._handlers) {
			this._core.$element.off(handler, this._handlers[handler]);
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] != 'function' && (this[property] = null);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;

})(window.Zepto || window.jQuery, window, document);

/**
 * Navigation Plugin
 * @version 2.3.4
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {
	'use strict';

	/**
	 * Creates the navigation plugin.
	 * @class The Navigation Plugin
	 * @param {Owl} carousel - The Owl Carousel.
	 */
	var Navigation = function(carousel) {
		/**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
		this._core = carousel;

		/**
		 * Indicates whether the plugin is initialized or not.
		 * @protected
		 * @type {Boolean}
		 */
		this._initialized = false;

		/**
		 * The current paging indexes.
		 * @protected
		 * @type {Array}
		 */
		this._pages = [];

		/**
		 * All DOM elements of the user interface.
		 * @protected
		 * @type {Object}
		 */
		this._controls = {};

		/**
		 * Markup for an indicator.
		 * @protected
		 * @type {Array.<String>}
		 */
		this._templates = [];

		/**
		 * The carousel element.
		 * @type {jQuery}
		 */
		this.$element = this._core.$element;

		/**
		 * Overridden methods of the carousel.
		 * @protected
		 * @type {Object}
		 */
		this._overrides = {
			next: this._core.next,
			prev: this._core.prev,
			to: this._core.to
		};

		/**
		 * All event handlers.
		 * @protected
		 * @type {Object}
		 */
		this._handlers = {
			'prepared.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.dotsData) {
					this._templates.push('<div class="' + this._core.settings.dotClass + '">' +
						$(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot') + '</div>');
				}
			}, this),
			'added.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.dotsData) {
					this._templates.splice(e.position, 0, this._templates.pop());
				}
			}, this),
			'remove.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.dotsData) {
					this._templates.splice(e.position, 1);
				}
			}, this),
			'changed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && e.property.name == 'position') {
					this.draw();
				}
			}, this),
			'initialized.owl.carousel': $.proxy(function(e) {
				if (e.namespace && !this._initialized) {
					this._core.trigger('initialize', null, 'navigation');
					this.initialize();
					this.update();
					this.draw();
					this._initialized = true;
					this._core.trigger('initialized', null, 'navigation');
				}
			}, this),
			'refreshed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._initialized) {
					this._core.trigger('refresh', null, 'navigation');
					this.update();
					this.draw();
					this._core.trigger('refreshed', null, 'navigation');
				}
			}, this)
		};

		// set default options
		this._core.options = $.extend({}, Navigation.Defaults, this._core.options);

		// register event handlers
		this.$element.on(this._handlers);
	};

	/**
	 * Default options.
	 * @public
	 * @todo Rename `slideBy` to `navBy`
	 */
	Navigation.Defaults = {
		nav: false,
		navText: [
			'<span aria-label="' + 'Previous' + '">&#x2039;</span>',
			'<span aria-label="' + 'Next' + '">&#x203a;</span>'
		],
		navSpeed: false,
		navElement: 'button type="button" role="presentation"',
		navContainer: false,
		navContainerClass: 'owl-nav',
		navClass: [
			'owl-prev',
			'owl-next'
		],
		slideBy: 1,
		dotClass: 'owl-dot',
		dotsClass: 'owl-dots',
		dots: true,
		dotsEach: false,
		dotsData: false,
		dotsSpeed: false,
		dotsContainer: false
	};

	/**
	 * Initializes the layout of the plugin and extends the carousel.
	 * @protected
	 */
	Navigation.prototype.initialize = function() {
		var override,
			settings = this._core.settings;

		// create DOM structure for relative navigation
		this._controls.$relative = (settings.navContainer ? $(settings.navContainer)
			: $('<div>').addClass(settings.navContainerClass).appendTo(this.$element)).addClass('disabled');

		this._controls.$previous = $('<' + settings.navElement + '>')
			.addClass(settings.navClass[0])
			.html(settings.navText[0])
			.prependTo(this._controls.$relative)
			.on('click', $.proxy(function(e) {
				this.prev(settings.navSpeed);
			}, this));
		this._controls.$next = $('<' + settings.navElement + '>')
			.addClass(settings.navClass[1])
			.html(settings.navText[1])
			.appendTo(this._controls.$relative)
			.on('click', $.proxy(function(e) {
				this.next(settings.navSpeed);
			}, this));

		// create DOM structure for absolute navigation
		if (!settings.dotsData) {
			this._templates = [ $('<button role="button">')
				.addClass(settings.dotClass)
				.append($('<span>'))
				.prop('outerHTML') ];
		}

		this._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer)
			: $('<div>').addClass(settings.dotsClass).appendTo(this.$element)).addClass('disabled');

		this._controls.$absolute.on('click', 'button', $.proxy(function(e) {
			var index = $(e.target).parent().is(this._controls.$absolute)
				? $(e.target).index() : $(e.target).parent().index();

			e.preventDefault();

			this.to(index, settings.dotsSpeed);
		}, this));

		/*$el.on('focusin', function() {
			$(document).off(".carousel");

			$(document).on('keydown.carousel', function(e) {
				if(e.keyCode == 37) {
					$el.trigger('prev.owl')
				}
				if(e.keyCode == 39) {
					$el.trigger('next.owl')
				}
			});
		});*/

		// override public methods of the carousel
		for (override in this._overrides) {
			this._core[override] = $.proxy(this[override], this);
		}
	};

	/**
	 * Destroys the plugin.
	 * @protected
	 */
	Navigation.prototype.destroy = function() {
		var handler, control, property, override, settings;
		settings = this._core.settings;

		for (handler in this._handlers) {
			this.$element.off(handler, this._handlers[handler]);
		}
		for (control in this._controls) {
			if (control === '$relative' && settings.navContainer) {
				this._controls[control].html('');
			} else {
				this._controls[control].remove();
			}
		}
		for (override in this.overides) {
			this._core[override] = this._overrides[override];
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] != 'function' && (this[property] = null);
		}
	};

	/**
	 * Updates the internal state.
	 * @protected
	 */
	Navigation.prototype.update = function() {
		var i, j, k,
			lower = this._core.clones().length / 2,
			upper = lower + this._core.items().length,
			maximum = this._core.maximum(true),
			settings = this._core.settings,
			size = settings.center || settings.autoWidth || settings.dotsData
				? 1 : settings.dotsEach || settings.items;

		if (settings.slideBy !== 'page') {
			settings.slideBy = Math.min(settings.slideBy, settings.items);
		}

		if (settings.dots || settings.slideBy == 'page') {
			this._pages = [];

			for (i = lower, j = 0, k = 0; i < upper; i++) {
				if (j >= size || j === 0) {
					this._pages.push({
						start: Math.min(maximum, i - lower),
						end: i - lower + size - 1
					});
					if (Math.min(maximum, i - lower) === maximum) {
						break;
					}
					j = 0, ++k;
				}
				j += this._core.mergers(this._core.relative(i));
			}
		}
	};

	/**
	 * Draws the user interface.
	 * @todo The option `dotsData` wont work.
	 * @protected
	 */
	Navigation.prototype.draw = function() {
		var difference,
			settings = this._core.settings,
			disabled = this._core.items().length <= settings.items,
			index = this._core.relative(this._core.current()),
			loop = settings.loop || settings.rewind;

		this._controls.$relative.toggleClass('disabled', !settings.nav || disabled);

		if (settings.nav) {
			this._controls.$previous.toggleClass('disabled', !loop && index <= this._core.minimum(true));
			this._controls.$next.toggleClass('disabled', !loop && index >= this._core.maximum(true));
		}

		this._controls.$absolute.toggleClass('disabled', !settings.dots || disabled);

		if (settings.dots) {
			difference = this._pages.length - this._controls.$absolute.children().length;

			if (settings.dotsData && difference !== 0) {
				this._controls.$absolute.html(this._templates.join(''));
			} else if (difference > 0) {
				this._controls.$absolute.append(new Array(difference + 1).join(this._templates[0]));
			} else if (difference < 0) {
				this._controls.$absolute.children().slice(difference).remove();
			}

			this._controls.$absolute.find('.active').removeClass('active');
			this._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass('active');
		}
	};

	/**
	 * Extends event data.
	 * @protected
	 * @param {Event} event - The event object which gets thrown.
	 */
	Navigation.prototype.onTrigger = function(event) {
		var settings = this._core.settings;

		event.page = {
			index: $.inArray(this.current(), this._pages),
			count: this._pages.length,
			size: settings && (settings.center || settings.autoWidth || settings.dotsData
				? 1 : settings.dotsEach || settings.items)
		};
	};

	/**
	 * Gets the current page position of the carousel.
	 * @protected
	 * @returns {Number}
	 */
	Navigation.prototype.current = function() {
		var current = this._core.relative(this._core.current());
		return $.grep(this._pages, $.proxy(function(page, index) {
			return page.start <= current && page.end >= current;
		}, this)).pop();
	};

	/**
	 * Gets the current succesor/predecessor position.
	 * @protected
	 * @returns {Number}
	 */
	Navigation.prototype.getPosition = function(successor) {
		var position, length,
			settings = this._core.settings;

		if (settings.slideBy == 'page') {
			position = $.inArray(this.current(), this._pages);
			length = this._pages.length;
			successor ? ++position : --position;
			position = this._pages[((position % length) + length) % length].start;
		} else {
			position = this._core.relative(this._core.current());
			length = this._core.items().length;
			successor ? position += settings.slideBy : position -= settings.slideBy;
		}

		return position;
	};

	/**
	 * Slides to the next item or page.
	 * @public
	 * @param {Number} [speed=false] - The time in milliseconds for the transition.
	 */
	Navigation.prototype.next = function(speed) {
		$.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);
	};

	/**
	 * Slides to the previous item or page.
	 * @public
	 * @param {Number} [speed=false] - The time in milliseconds for the transition.
	 */
	Navigation.prototype.prev = function(speed) {
		$.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);
	};

	/**
	 * Slides to the specified item or page.
	 * @public
	 * @param {Number} position - The position of the item or page.
	 * @param {Number} [speed] - The time in milliseconds for the transition.
	 * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.
	 */
	Navigation.prototype.to = function(position, speed, standard) {
		var length;

		if (!standard && this._pages.length) {
			length = this._pages.length;
			$.proxy(this._overrides.to, this._core)(this._pages[((position % length) + length) % length].start, speed);
		} else {
			$.proxy(this._overrides.to, this._core)(position, speed);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;

})(window.Zepto || window.jQuery, window, document);

/**
 * Hash Plugin
 * @version 2.3.4
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {
	'use strict';

	/**
	 * Creates the hash plugin.
	 * @class The Hash Plugin
	 * @param {Owl} carousel - The Owl Carousel
	 */
	var Hash = function(carousel) {
		/**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
		this._core = carousel;

		/**
		 * Hash index for the items.
		 * @protected
		 * @type {Object}
		 */
		this._hashes = {};

		/**
		 * The carousel element.
		 * @type {jQuery}
		 */
		this.$element = this._core.$element;

		/**
		 * All event handlers.
		 * @protected
		 * @type {Object}
		 */
		this._handlers = {
			'initialized.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.startPosition === 'URLHash') {
					$(window).trigger('hashchange.owl.navigation');
				}
			}, this),
			'prepared.owl.carousel': $.proxy(function(e) {
				if (e.namespace) {
					var hash = $(e.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash');

					if (!hash) {
						return;
					}

					this._hashes[hash] = e.content;
				}
			}, this),
			'changed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && e.property.name === 'position') {
					var current = this._core.items(this._core.relative(this._core.current())),
						hash = $.map(this._hashes, function(item, hash) {
							return item === current ? hash : null;
						}).join();

					if (!hash || window.location.hash.slice(1) === hash) {
						return;
					}

					window.location.hash = hash;
				}
			}, this)
		};

		// set default options
		this._core.options = $.extend({}, Hash.Defaults, this._core.options);

		// register the event handlers
		this.$element.on(this._handlers);

		// register event listener for hash navigation
		$(window).on('hashchange.owl.navigation', $.proxy(function(e) {
			var hash = window.location.hash.substring(1),
				items = this._core.$stage.children(),
				position = this._hashes[hash] && items.index(this._hashes[hash]);

			if (position === undefined || position === this._core.current()) {
				return;
			}

			this._core.to(this._core.relative(position), false, true);
		}, this));
	};

	/**
	 * Default options.
	 * @public
	 */
	Hash.Defaults = {
		URLhashListener: false
	};

	/**
	 * Destroys the plugin.
	 * @public
	 */
	Hash.prototype.destroy = function() {
		var handler, property;

		$(window).off('hashchange.owl.navigation');

		for (handler in this._handlers) {
			this._core.$element.off(handler, this._handlers[handler]);
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] != 'function' && (this[property] = null);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.Hash = Hash;

})(window.Zepto || window.jQuery, window, document);

/**
 * Support Plugin
 *
 * @version 2.3.4
 * @author Vivid Planet Software GmbH
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

	var style = $('<support>').get(0).style,
		prefixes = 'Webkit Moz O ms'.split(' '),
		events = {
			transition: {
				end: {
					WebkitTransition: 'webkitTransitionEnd',
					MozTransition: 'transitionend',
					OTransition: 'oTransitionEnd',
					transition: 'transitionend'
				}
			},
			animation: {
				end: {
					WebkitAnimation: 'webkitAnimationEnd',
					MozAnimation: 'animationend',
					OAnimation: 'oAnimationEnd',
					animation: 'animationend'
				}
			}
		},
		tests = {
			csstransforms: function() {
				return !!test('transform');
			},
			csstransforms3d: function() {
				return !!test('perspective');
			},
			csstransitions: function() {
				return !!test('transition');
			},
			cssanimations: function() {
				return !!test('animation');
			}
		};

	function test(property, prefixed) {
		var result = false,
			upper = property.charAt(0).toUpperCase() + property.slice(1);

		$.each((property + ' ' + prefixes.join(upper + ' ') + upper).split(' '), function(i, property) {
			if (style[property] !== undefined) {
				result = prefixed ? property : true;
				return false;
			}
		});

		return result;
	}

	function prefixed(property) {
		return test(property, true);
	}

	if (tests.csstransitions()) {
		/* jshint -W053 */
		$.support.transition = new String(prefixed('transition'))
		$.support.transition.end = events.transition.end[ $.support.transition ];
	}

	if (tests.cssanimations()) {
		/* jshint -W053 */
		$.support.animation = new String(prefixed('animation'))
		$.support.animation.end = events.animation.end[ $.support.animation ];
	}

	if (tests.csstransforms()) {
		/* jshint -W053 */
		$.support.transform = new String(prefixed('transform'));
		$.support.transform3d = tests.csstransforms3d();
	}

})(window.Zepto || window.jQuery, window, document);

/**
 * Detect.js: User-Agent Parser
 * https://github.com/darcyclarke/Detect.js
 * Dual licensed under the MIT and GPL licenses.
 *
 * @version 2.2.2
 * @author Darcy Clarke
 * @url http://darcyclarke.me
 * @createdat Mon Oct 26 2015 08:21:54 GMT-0200 (Horrio brasileiro de vero)
 *
 * Based on UA-Parser (https://github.com/tobie/ua-parser) by Tobie Langel
 *
 * Example Usage:
 * var agentInfo = detect.parse(navigator.userAgent)
 * console.log(agentInfo.browser.family); // Chrome
 *
 */
(function (root, undefined) {
    // Shim Array.prototype.map if necessary
    // Production steps of ECMA-262, Edition 5, 15.4.4.19
    // Reference: http://es5.github.com/#x15.4.4.19
    if (!Array.prototype.map) {
        Array.prototype.map = function (callback, thisArg) {
            var T, A, k;
            if (this == null) {
                throw new TypeError(' this is null or not defined');
            }
            // 1. Let O be the result of calling ToObject passing the |this| value as the argument.
            var O = Object(this);
            // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
            // 3. Let len be ToUint32(lenValue).
            var len = O.length >>> 0;
            // 4. If IsCallable(callback) is false, throw a TypeError exception.
            // See: http://es5.github.com/#x9.11
            if (typeof callback !== 'function') {
                throw new TypeError(callback + ' is not a function');
            }
            // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
            if (thisArg) {
                T = thisArg;
            }
            // 6. Let A be a new array created as if by the expression new Array(len) where Array is
            // the standard built-in constructor with that name and len is the value of len.
            A = new Array(len);
            // 7. Let k be 0
            k = 0;
            // 8. Repeat, while k < len
            while (k < len) {
                var kValue, mappedValue;
                // a. Let Pk be ToString(k).
                //   This is implicit for LHS operands of the in operator
                // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
                //   This step can be combined with c
                // c. If kPresent is true, then
                if (k in O) {
                    // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
                    kValue = O[k];
                    // ii. Let mappedValue be the result of calling the Call internal method of callback
                    // with T as the this value and argument list containing kValue, k, and O.
                    mappedValue = callback.call(T, kValue, k, O);
                    // iii. Call the DefineOwnProperty internal method of A with arguments
                    // Pk, Property Descriptor {Value: mappedValue, : true, Enumerable: true, Configurable: true},
                    // and false.
                    // In browsers that support Object.defineProperty, use the following:
                    // Object.defineProperty(A, Pk, { value: mappedValue, writable: true, enumerable: true, configurable: true });
                    // For best browser support, use the following:
                    A[k] = mappedValue;
                }
                // d. Increase k by 1.
                k++;
            }
            // 9. return A
            return A;
        };
    }
    // Detect
    var detect = (root.detect = (function () {
        // Context
        var _this = function () {};
        // Regexes
        var regexes = {
            browser_parsers: [
                {
                    regex: '^(Opera)/(\\d+)\\.(\\d+) \\(Nintendo Wii',
                    family_replacement: 'Wii',
                    manufacturer: 'Nintendo',
                },
                {
                    regex: '(SeaMonkey|Camino)/(\\d+)\\.(\\d+)\\.?([ab]?\\d+[a-z]*)',
                    family_replacement: 'Camino',
                    other: true,
                },
                {
                    regex: '(Pale[Mm]oon)/(\\d+)\\.(\\d+)\\.?(\\d+)?',
                    family_replacement: 'Pale Moon (Firefox Variant)',
                    other: true,
                },
                {
                    regex: '(Fennec)/(\\d+)\\.(\\d+)\\.?([ab]?\\d+[a-z]*)',
                    family_replacement: 'Firefox Mobile',
                },
                {
                    regex: '(Fennec)/(\\d+)\\.(\\d+)(pre)',
                    family_replacment: 'Firefox Mobile',
                },
                {
                    regex: '(Fennec)/(\\d+)\\.(\\d+)',
                    family_replacement: 'Firefox Mobile',
                },
                {
                    regex: 'Mobile.*(Firefox)/(\\d+)\\.(\\d+)',
                    family_replacement: 'Firefox Mobile',
                },
                {
                    regex: '(Namoroka|Shiretoko|Minefield)/(\\d+)\\.(\\d+)\\.(\\d+(?:pre)?)',
                    family_replacement: 'Firefox ($1)',
                },
                {
                    regex: '(Firefox)/(\\d+)\\.(\\d+)(a\\d+[a-z]*)',
                    family_replacement: 'Firefox Alpha',
                },
                {
                    regex: '(Firefox)/(\\d+)\\.(\\d+)(b\\d+[a-z]*)',
                    family_replacement: 'Firefox Beta',
                },
                {
                    regex: '(Firefox)-(?:\\d+\\.\\d+)?/(\\d+)\\.(\\d+)(a\\d+[a-z]*)',
                    family_replacement: 'Firefox Alpha',
                },
                {
                    regex: '(Firefox)-(?:\\d+\\.\\d+)?/(\\d+)\\.(\\d+)(b\\d+[a-z]*)',
                    family_replacement: 'Firefox Beta',
                },
                {
                    regex: '(Namoroka|Shiretoko|Minefield)/(\\d+)\\.(\\d+)([ab]\\d+[a-z]*)?',
                    family_replacement: 'Firefox ($1)',
                },
                {
                    regex: '(Firefox).*Tablet browser (\\d+)\\.(\\d+)\\.(\\d+)',
                    family_replacement: 'MicroB',
                    tablet: true,
                },
                {
                    regex: '(MozillaDeveloperPreview)/(\\d+)\\.(\\d+)([ab]\\d+[a-z]*)?',
                },
                {
                    regex: '(Flock)/(\\d+)\\.(\\d+)(b\\d+?)',
                    family_replacement: 'Flock',
                    other: true,
                },
                {
                    regex: '(RockMelt)/(\\d+)\\.(\\d+)\\.(\\d+)',
                    family_replacement: 'Rockmelt',
                    other: true,
                },
                {
                    regex: '(Navigator)/(\\d+)\\.(\\d+)\\.(\\d+)',
                    family_replacement: 'Netscape',
                },
                {
                    regex: '(Navigator)/(\\d+)\\.(\\d+)([ab]\\d+)',
                    family_replacement: 'Netscape',
                },
                {
                    regex: '(Netscape6)/(\\d+)\\.(\\d+)\\.(\\d+)',
                    family_replacement: 'Netscape',
                },
                {
                    regex: '(MyIBrow)/(\\d+)\\.(\\d+)',
                    family_replacement: 'My Internet Browser',
                    other: true,
                },
                {
                    regex: '(Opera Tablet).*Version/(\\d+)\\.(\\d+)(?:\\.(\\d+))?',
                    family_replacement: 'Opera Tablet',
                    tablet: true,
                },
                {
                    regex: '(Opera)/.+Opera Mobi.+Version/(\\d+)\\.(\\d+)',
                    family_replacement: 'Opera Mobile',
                },
                {
                    regex: 'Opera Mobi',
                    family_replacement: 'Opera Mobile',
                },
                {
                    regex: '(Opera Mini)/(\\d+)\\.(\\d+)',
                    family_replacement: 'Opera Mini',
                },
                {
                    regex: '(Opera Mini)/att/(\\d+)\\.(\\d+)',
                    family_replacement: 'Opera Mini',
                },
                {
                    regex: '(Opera)/9.80.*Version/(\\d+)\\.(\\d+)(?:\\.(\\d+))?',
                    family_replacement: 'Opera',
                },
                {
                    regex: '(OPR)/(\\d+)\\.(\\d+)(?:\\.(\\d+))?',
                    family_replacement: 'Opera',
                },
                {
                    regex: '(webOSBrowser)/(\\d+)\\.(\\d+)',
                    family_replacement: 'webOS',
                },
                {
                    regex: '(webOS)/(\\d+)\\.(\\d+)',
                    family_replacement: 'webOS',
                },
                {
                    regex: '(wOSBrowser).+TouchPad/(\\d+)\\.(\\d+)',
                    family_replacement: 'webOS TouchPad',
                },
                {
                    regex: '(luakit)',
                    family_replacement: 'LuaKit',
                    other: true,
                },
                {
                    regex: '(Lightning)/(\\d+)\\.(\\d+)([ab]?\\d+[a-z]*)',
                    family_replacement: 'Lightning',
                    other: true,
                },
                {
                    regex: '(Firefox)/(\\d+)\\.(\\d+)\\.(\\d+(?:pre)?) \\(Swiftfox\\)',
                    family_replacement: 'Swiftfox',
                    other: true,
                },
                {
                    regex: '(Firefox)/(\\d+)\\.(\\d+)([ab]\\d+[a-z]*)? \\(Swiftfox\\)',
                    family_replacement: 'Swiftfox',
                    other: true,
                },
                {
                    regex: 'rekonq',
                    family_replacement: 'Rekonq',
                    other: true,
                },
                {
                    regex: '(conkeror|Conkeror)/(\\d+)\\.(\\d+)\\.?(\\d+)?',
                    family_replacement: 'Conkeror',
                    other: true,
                },
                {
                    regex: '(konqueror)/(\\d+)\\.(\\d+)\\.(\\d+)',
                    family_replacement: 'Konqueror',
                    other: true,
                },
                {
                    regex: '(WeTab)-Browser',
                    family_replacement: 'WeTab',
                    other: true,
                },
                {
                    regex: '(Comodo_Dragon)/(\\d+)\\.(\\d+)\\.(\\d+)',
                    family_replacement: 'Comodo Dragon',
                    other: true,
                },
                {
                    regex: '(YottaaMonitor)',
                    family_replacement: 'Yottaa Monitor',
                    other: true,
                },
                {
                    regex: '(Kindle)/(\\d+)\\.(\\d+)',
                    family_replacement: 'Kindle',
                },
                {
                    regex: '(Symphony) (\\d+).(\\d+)',
                    family_replacement: 'Symphony',
                    other: true,
                },
                {
                    regex: 'Minimo',
                    family_replacement: 'Minimo',
                    other: true,
                },
                {
                    regex: '(Edg)/(\\d+)\\.(\\d+)',
                    family_replacement: 'Edge',
                },
                {
                    regex: '(CrMo)/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)',
                    family_replacement: 'Chrome Mobile',
                },
                {
                    regex: '(CriOS)/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)',
                    family_replacement: 'Chrome Mobile iOS',
                },
                {
                    regex: '(Chrome)/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+) Mobile',
                    family_replacement: 'Chrome Mobile',
                },
                {
                    regex: '(chromeframe)/(\\d+)\\.(\\d+)\\.(\\d+)',
                    family_replacement: 'Chrome Frame',
                },
                {
                    regex: '(UC Browser)(\\d+)\\.(\\d+)\\.(\\d+)',
                    family_replacement: 'UC Browser',
                    other: true,
                },
                {
                    regex: '(SLP Browser)/(\\d+)\\.(\\d+)',
                    family_replacement: 'Tizen Browser',
                    other: true,
                },
                {
                    regex: '(Epiphany)/(\\d+)\\.(\\d+).(\\d+)',
                    family_replacement: 'Epiphany',
                    other: true,
                },
                {
                    regex: '(SE 2\\.X) MetaSr (\\d+)\\.(\\d+)',
                    family_replacement: 'Sogou Explorer',
                    other: true,
                },
                {
                    regex: '(Pingdom.com_bot_version_)(\\d+)\\.(\\d+)',
                    family_replacement: 'PingdomBot',
                    other: true,
                },
                {
                    regex: '(facebookexternalhit)/(\\d+)\\.(\\d+)',
                    family_replacement: 'FacebookBot',
                },
                {
                    regex: '(Twitterbot)/(\\d+)\\.(\\d+)',
                    family_replacement: 'TwitterBot',
                },
                {
                    regex:
                        '(AdobeAIR|Chromium|FireWeb|Jasmine|ANTGalio|Midori|Fresco|Lobo|PaleMoon|Maxthon|Lynx|OmniWeb|Dillo|Camino|Demeter|Fluid|Fennec|Shiira|Sunrise|Chrome|Flock|Netscape|Lunascape|WebPilot|NetFront|Netfront|Konqueror|SeaMonkey|Kazehakase|Vienna|Iceape|Iceweasel|IceWeasel|Iron|K-Meleon|Sleipnir|Galeon|GranParadiso|Opera Mini|iCab|NetNewsWire|ThunderBrowse|Iron|Iris|UP\\.Browser|Bunjaloo|Google Earth|Raven for Mac)/(\\d+)\\.(\\d+)\\.(\\d+)',
                },
                {
                    regex:
                        '(Bolt|Jasmine|IceCat|Skyfire|Midori|Maxthon|Lynx|Arora|IBrowse|Dillo|Camino|Shiira|Fennec|Phoenix|Chrome|Flock|Netscape|Lunascape|Epiphany|WebPilot|Opera Mini|Opera|NetFront|Netfront|Konqueror|Googlebot|SeaMonkey|Kazehakase|Vienna|Iceape|Iceweasel|IceWeasel|Iron|K-Meleon|Sleipnir|Galeon|GranParadiso|iCab|NetNewsWire|Iron|Space Bison|Stainless|Orca|Dolfin|BOLT|Minimo|Tizen Browser|Polaris)/(\\d+)\\.(\\d+)',
                },
                {
                    regex: '(iRider|Crazy Browser|SkipStone|iCab|Lunascape|Sleipnir|Maemo Browser) (\\d+)\\.(\\d+)\\.(\\d+)',
                },
                {
                    regex: '(iCab|Lunascape|Opera|Android|Jasmine|Polaris|BREW) (\\d+)\\.(\\d+)\\.?(\\d+)?',
                },
                {
                    regex: '(Android) Donut',
                    v2_replacement: '2',
                    v1_replacement: '1',
                },
                {
                    regex: '(Android) Eclair',
                    v2_replacement: '1',
                    v1_replacement: '2',
                },
                {
                    regex: '(Android) Froyo',
                    v2_replacement: '2',
                    v1_replacement: '2',
                },
                {
                    regex: '(Android) Gingerbread',
                    v2_replacement: '3',
                    v1_replacement: '2',
                },
                {
                    regex: '(Android) Honeycomb',
                    v1_replacement: '3',
                },
                {
                    regex: '(IEMobile)[ /](\\d+)\\.(\\d+)',
                    family_replacement: 'IE Mobile',
                },
                {
                    regex: '(MSIE) (\\d+)\\.(\\d+).*XBLWP7',
                    family_replacement: 'IE Large Screen',
                },
                {
                    regex: '(Firefox)/(\\d+)\\.(\\d+)\\.(\\d+)',
                },
                {
                    regex: '(Firefox)/(\\d+)\\.(\\d+)(pre|[ab]\\d+[a-z]*)?',
                },
                {
                    regex: '(Obigo)InternetBrowser',
                    other: true,
                },
                {
                    regex: '(Obigo)\\-Browser',
                    other: true,
                },
                {
                    regex: '(Obigo|OBIGO)[^\\d]*(\\d+)(?:.(\\d+))?',
                    other: true,
                },
                {
                    regex: '(MAXTHON|Maxthon) (\\d+)\\.(\\d+)',
                    family_replacement: 'Maxthon',
                    other: true,
                },
                {
                    regex: '(Maxthon|MyIE2|Uzbl|Shiira)',
                    v1_replacement: '0',
                    other: true,
                },
                {
                    regex: '(PLAYSTATION) (\\d+)',
                    family_replacement: 'PlayStation',
                    manufacturer: 'Sony',
                },
                {
                    regex: '(PlayStation Portable)[^\\d]+(\\d+).(\\d+)',
                    manufacturer: 'Sony',
                },
                {
                    regex: '(BrowseX) \\((\\d+)\\.(\\d+)\\.(\\d+)',
                    other: true,
                },
                {
                    regex: '(POLARIS)/(\\d+)\\.(\\d+)',
                    family_replacement: 'Polaris',
                    other: true,
                },
                {
                    regex: '(Embider)/(\\d+)\\.(\\d+)',
                    family_replacement: 'Polaris',
                    other: true,
                },
                {
                    regex: '(BonEcho)/(\\d+)\\.(\\d+)\\.(\\d+)',
                    family_replacement: 'Bon Echo',
                    other: true,
                },
                {
                    regex: '(iPod).+Version/(\\d+)\\.(\\d+)\\.(\\d+)',
                    family_replacement: 'Mobile Safari',
                    manufacturer: 'Apple',
                },
                {
                    regex: '(iPod).*Version/(\\d+)\\.(\\d+)',
                    family_replacement: 'Mobile Safari',
                    manufacturer: 'Apple',
                },
                {
                    regex: '(iPod)',
                    family_replacement: 'Mobile Safari',
                    manufacturer: 'Apple',
                },
                {
                    regex: '(iPhone).*Version/(\\d+)\\.(\\d+)\\.(\\d+)',
                    family_replacement: 'Mobile Safari',
                    manufacturer: 'Apple',
                },
                {
                    regex: '(iPhone).*Version/(\\d+)\\.(\\d+)',
                    family_replacement: 'Mobile Safari',
                    manufacturer: 'Apple',
                },
                {
                    regex: '(iPhone)',
                    family_replacement: 'Mobile Safari',
                    manufacturer: 'Apple',
                },
                {
                    regex: '(iPad).*Version/(\\d+)\\.(\\d+)\\.(\\d+)',
                    family_replacement: 'Mobile Safari',
                    tablet: true,
                    manufacturer: 'Apple',
                },
                {
                    regex: '(iPad).*Version/(\\d+)\\.(\\d+)',
                    family_replacement: 'Mobile Safari',
                    tablet: true,
                    manufacturer: 'Apple',
                },
                {
                    regex: '(iPad)',
                    family_replacement: 'Mobile Safari',
                    tablet: true,
                    manufacturer: 'Apple',
                },
                {
                    regex: '(AvantGo) (\\d+).(\\d+)',
                    other: true,
                },
                {
                    regex: '(Avant)',
                    v1_replacement: '1',
                    other: true,
                },
                {
                    regex: '^(Nokia)',
                    family_replacement: 'Nokia Services (WAP) Browser',
                    manufacturer: 'Nokia',
                },
                {
                    regex: '(NokiaBrowser)/(\\d+)\\.(\\d+).(\\d+)\\.(\\d+)',
                    manufacturer: 'Nokia',
                },
                {
                    regex: '(NokiaBrowser)/(\\d+)\\.(\\d+).(\\d+)',
                    manufacturer: 'Nokia',
                },
                {
                    regex: '(NokiaBrowser)/(\\d+)\\.(\\d+)',
                    manufacturer: 'Nokia',
                },
                {
                    regex: '(BrowserNG)/(\\d+)\\.(\\d+).(\\d+)',
                    family_replacement: 'NokiaBrowser',
                    manufacturer: 'Nokia',
                },
                {
                    regex: '(Series60)/5\\.0',
                    v2_replacement: '0',
                    v1_replacement: '7',
                    family_replacement: 'NokiaBrowser',
                    manufacturer: 'Nokia',
                },
                {
                    regex: '(Series60)/(\\d+)\\.(\\d+)',
                    family_replacement: 'Nokia OSS Browser',
                    manufacturer: 'Nokia',
                },
                {
                    regex: '(S40OviBrowser)/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)',
                    family_replacement: 'Nokia Series 40 Ovi Browser',
                    manufacturer: 'Nokia',
                },
                {
                    regex: '(Nokia)[EN]?(\\d+)',
                    manufacturer: 'Nokia',
                },
                {
                    regex: '(PlayBook).+RIM Tablet OS (\\d+)\\.(\\d+)\\.(\\d+)',
                    family_replacement: 'Blackberry WebKit',
                    tablet: true,
                    manufacturer: 'Nokia',
                },
                {
                    regex: '(Black[bB]erry).+Version/(\\d+)\\.(\\d+)\\.(\\d+)',
                    family_replacement: 'Blackberry WebKit',
                    manufacturer: 'RIM',
                },
                {
                    regex: '(Black[bB]erry)\\s?(\\d+)',
                    family_replacement: 'Blackberry',
                    manufacturer: 'RIM',
                },
                {
                    regex: '(OmniWeb)/v(\\d+)\\.(\\d+)',
                    other: true,
                },
                {
                    regex: '(Blazer)/(\\d+)\\.(\\d+)',
                    family_replacement: 'Palm Blazer',
                    manufacturer: 'Palm',
                },
                {
                    regex: '(Pre)/(\\d+)\\.(\\d+)',
                    family_replacement: 'Palm Pre',
                    manufacturer: 'Palm',
                },
                {
                    regex: '(Links) \\((\\d+)\\.(\\d+)',
                    other: true,
                },
                {
                    regex: '(QtWeb) Internet Browser/(\\d+)\\.(\\d+)',
                    other: true,
                },
                {
                    regex: '(Silk)/(\\d+)\\.(\\d+)(?:\\.([0-9\\-]+))?',
                    other: true,
                    tablet: true,
                },
                {
                    regex: '(AppleWebKit)/(\\d+)\\.?(\\d+)?\\+ .* Version/\\d+\\.\\d+.\\d+ Safari/',
                    family_replacement: 'WebKit Nightly',
                },
                {
                    regex: '(Version)/(\\d+)\\.(\\d+)(?:\\.(\\d+))?.*Safari/',
                    family_replacement: 'Safari',
                },
                {
                    regex: '(Safari)/\\d+',
                },
                {
                    regex: '(OLPC)/Update(\\d+)\\.(\\d+)',
                    other: true,
                },
                {
                    regex: '(OLPC)/Update()\\.(\\d+)',
                    v1_replacement: '0',
                    other: true,
                },
                {
                    regex: '(SEMC\\-Browser)/(\\d+)\\.(\\d+)',
                    other: true,
                },
                {
                    regex: '(Teleca)',
                    family_replacement: 'Teleca Browser',
                    other: true,
                },
                {
                    regex: 'Trident(.*)rv.(\\d+)\\.(\\d+)',
                    family_replacement: 'IE',
                },
                {
                    regex: '(MSIE) (\\d+)\\.(\\d+)',
                    family_replacement: 'IE',
                },
            ],
            os_parsers: [
                {
                    regex: '(Android) (\\d+)\\.(\\d+)(?:[.\\-]([a-z0-9]+))?',
                },
                {
                    regex: '(Android)\\-(\\d+)\\.(\\d+)(?:[.\\-]([a-z0-9]+))?',
                },
                {
                    regex: '(Android) Donut',
                    os_v2_replacement: '2',
                    os_v1_replacement: '1',
                },
                {
                    regex: '(Android) Eclair',
                    os_v2_replacement: '1',
                    os_v1_replacement: '2',
                },
                {
                    regex: '(Android) Froyo',
                    os_v2_replacement: '2',
                    os_v1_replacement: '2',
                },
                {
                    regex: '(Android) Gingerbread',
                    os_v2_replacement: '3',
                    os_v1_replacement: '2',
                },
                {
                    regex: '(Android) Honeycomb',
                    os_v1_replacement: '3',
                },
                {
                    regex: '(Silk-Accelerated=[a-z]{4,5})',
                    os_replacement: 'Android',
                },
                {
                    regex: '(Windows Phone 6\\.5)',
                },
                {
                    regex: '(Windows (?:NT 5\\.2|NT 5\\.1))',
                    os_replacement: 'Windows XP',
                },
                {
                    regex: '(XBLWP7)',
                    os_replacement: 'Windows Phone OS',
                },
                {
                    regex: '(Windows NT 6\\.1)',
                    os_replacement: 'Windows 7',
                },
                {
                    regex: '(Windows NT 6\\.0)',
                    os_replacement: 'Windows Vista',
                },
                {
                    regex: '(Windows 98|Windows XP|Windows ME|Windows 95|Windows CE|Windows 7|Windows NT 4\\.0|Windows Vista|Windows 2000)',
                },
                {
                    regex: '(Windows NT 6\\.4|Windows NT 10\\.0)',
                    os_replacement: 'Windows 10',
                },
                {
                    regex: '(Windows NT 6\\.2)',
                    os_replacement: 'Windows 8',
                },
                {
                    regex: '(Windows Phone 8)',
                    os_replacement: 'Windows Phone 8',
                },
                {
                    regex: '(Windows NT 5\\.0)',
                    os_replacement: 'Windows 2000',
                },
                {
                    regex: '(Windows Phone OS) (\\d+)\\.(\\d+)',
                },
                {
                    regex: '(Windows ?Mobile)',
                    os_replacement: 'Windows Mobile',
                },
                {
                    regex: '(WinNT4.0)',
                    os_replacement: 'Windows NT 4.0',
                },
                {
                    regex: '(Win98)',
                    os_replacement: 'Windows 98',
                },
                {
                    regex: '(Tizen)/(\\d+)\\.(\\d+)',
                    other: true,
                },
                {
                    regex: '(Mac OS X) (\\d+)[_.](\\d+)(?:[_.](\\d+))?',
                    manufacturer: 'Apple',
                },
                {
                    regex: '(?:PPC|Intel) (Mac OS X)',
                    manufacturer: 'Apple',
                },
                {
                    regex: '(CPU OS|iPhone OS) (\\d+)_(\\d+)(?:_(\\d+))?',
                    os_replacement: 'iOS',
                    manufacturer: 'Apple',
                },
                {
                    regex: '(iPhone|iPad|iPod); Opera',
                    os_replacement: 'iOS',
                    manufacturer: 'Apple',
                },
                {
                    regex: '(iPad); Opera',
                    tablet: true,
                    manufacturer: 'Apple',
                },
                {
                    regex: '(iPhone|iPad|iPod).*Mac OS X.*Version/(\\d+)\\.(\\d+)',
                    os_replacement: 'iOS',
                    manufacturer: 'Apple',
                },
                {
                    regex: '(CrOS) [a-z0-9_]+ (\\d+)\\.(\\d+)(?:\\.(\\d+))?',
                    os_replacement: 'Chrome OS',
                },
                {
                    regex: '(Debian)-(\\d+)\\.(\\d+)\\.(\\d+)(?:\\.(\\d+))?',
                    other: true,
                },
                {
                    regex: '(Linux Mint)(?:/(\\d+))?',
                    other: true,
                },
                {
                    regex: '(Mandriva)(?: Linux)?/(\\d+)\\.(\\d+)\\.(\\d+)(?:\\.(\\d+))?',
                    other: true,
                },
                {
                    regex: '(Symbian[Oo][Ss])/(\\d+)\\.(\\d+)',
                    os_replacement: 'Symbian OS',
                },
                {
                    regex: '(Symbian/3).+NokiaBrowser/7\\.3',
                    os_replacement: 'Symbian^3 Anna',
                },
                {
                    regex: '(Symbian/3).+NokiaBrowser/7\\.4',
                    os_replacement: 'Symbian^3 Belle',
                },
                {
                    regex: '(Symbian/3)',
                    os_replacement: 'Symbian^3',
                },
                {
                    regex: '(Series 60|SymbOS|S60)',
                    os_replacement: 'Symbian OS',
                },
                {
                    regex: '(MeeGo)',
                    other: true,
                },
                {
                    regex: 'Symbian [Oo][Ss]',
                    os_replacement: 'Symbian OS',
                },
                {
                    regex: '(Black[Bb]erry)[0-9a-z]+/(\\d+)\\.(\\d+)\\.(\\d+)(?:\\.(\\d+))?',
                    os_replacement: 'BlackBerry OS',
                    manufacturer: 'RIM',
                },
                {
                    regex: '(Black[Bb]erry).+Version/(\\d+)\\.(\\d+)\\.(\\d+)(?:\\.(\\d+))?',
                    os_replacement: 'BlackBerry OS',
                    manufacturer: 'RIM',
                },
                {
                    regex: '(RIM Tablet OS) (\\d+)\\.(\\d+)\\.(\\d+)',
                    os_replacement: 'BlackBerry Tablet OS',
                    tablet: true,
                    manufacturer: 'RIM',
                },
                {
                    regex: '(Play[Bb]ook)',
                    os_replacement: 'BlackBerry Tablet OS',
                    tablet: true,
                    manufacturer: 'RIM',
                },
                {
                    regex: '(Black[Bb]erry)',
                    os_replacement: 'Blackberry OS',
                    manufacturer: 'RIM',
                },
                {
                    regex: '(webOS|hpwOS)/(\\d+)\\.(\\d+)(?:\\.(\\d+))?',
                    os_replacement: 'webOS',
                },
                {
                    regex: '(SUSE|Fedora|Red Hat|PCLinuxOS)/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)',
                    other: true,
                },
                {
                    regex: '(SUSE|Fedora|Red Hat|Puppy|PCLinuxOS|CentOS)/(\\d+)\\.(\\d+)\\.(\\d+)',
                    other: true,
                },
                {
                    regex: '(Ubuntu|Kindle|Bada|Lubuntu|BackTrack|Red Hat|Slackware)/(\\d+)\\.(\\d+)',
                },
                {
                    regex: '(Windows|OpenBSD|FreeBSD|NetBSD|Ubuntu|Kubuntu|Android|Arch Linux|CentOS|WeTab|Slackware)',
                },
                {
                    regex: '(Linux|BSD)',
                    other: true,
                },
            ],
            mobile_os_families: ['Windows Phone 6.5', 'Windows CE', 'Symbian OS'],
            device_parsers: [
                {
                    regex: 'HTC ([A-Z][a-z0-9]+) Build',
                    device_replacement: 'HTC $1',
                    manufacturer: 'HTC',
                },
                {
                    regex: 'HTC ([A-Z][a-z0-9 ]+) \\d+\\.\\d+\\.\\d+\\.\\d+',
                    device_replacement: 'HTC $1',
                    manufacturer: 'HTC',
                },
                {
                    regex: 'HTC_Touch_([A-Za-z0-9]+)',
                    device_replacement: 'HTC Touch ($1)',
                    manufacturer: 'HTC',
                },
                {
                    regex: 'USCCHTC(\\d+)',
                    device_replacement: 'HTC $1 (US Cellular)',
                    manufacturer: 'HTC',
                },
                {
                    regex: 'Sprint APA(9292)',
                    device_replacement: 'HTC $1 (Sprint)',
                    manufacturer: 'HTC',
                },
                {
                    regex: 'HTC ([A-Za-z0-9]+ [A-Z])',
                    device_replacement: 'HTC $1',
                    manufacturer: 'HTC',
                },
                {
                    regex: 'HTC-([A-Za-z0-9]+)',
                    device_replacement: 'HTC $1',
                    manufacturer: 'HTC',
                },
                {
                    regex: 'HTC_([A-Za-z0-9]+)',
                    device_replacement: 'HTC $1',
                    manufacturer: 'HTC',
                },
                {
                    regex: 'HTC ([A-Za-z0-9]+)',
                    device_replacement: 'HTC $1',
                    manufacturer: 'HTC',
                },
                {
                    regex: '(ADR[A-Za-z0-9]+)',
                    device_replacement: 'HTC $1',
                    manufacturer: 'HTC',
                },
                {
                    regex: '(HTC)',
                    manufacturer: 'HTC',
                },
                {
                    regex: 'SonyEricsson([A-Za-z0-9]+)/',
                    device_replacement: 'Ericsson $1',
                    other: true,
                    manufacturer: 'Sony',
                },
                {
                    regex: 'Android[\\- ][\\d]+\\.[\\d]+\\; [A-Za-z]{2}\\-[A-Za-z]{2}\\; WOWMobile (.+) Build',
                },
                {
                    regex: 'Android[\\- ][\\d]+\\.[\\d]+\\.[\\d]+; [A-Za-z]{2}\\-[A-Za-z]{2}\\; (.+) Build',
                },
                {
                    regex: 'Android[\\- ][\\d]+\\.[\\d]+\\-update1\\; [A-Za-z]{2}\\-[A-Za-z]{2}\\; (.+) Build',
                },
                {
                    regex: 'Android[\\- ][\\d]+\\.[\\d]+\\; [A-Za-z]{2}\\-[A-Za-z]{2}\\; (.+) Build',
                },
                {
                    regex: 'Android[\\- ][\\d]+\\.[\\d]+\\.[\\d]+; (.+) Build',
                },
                {
                    regex: 'NokiaN([0-9]+)',
                    device_replacement: 'Nokia N$1',
                    manufacturer: 'Nokia',
                },
                {
                    regex: 'Nokia([A-Za-z0-9\\v-]+)',
                    device_replacement: 'Nokia $1',
                    manufacturer: 'Nokia',
                },
                {
                    regex: 'NOKIA ([A-Za-z0-9\\-]+)',
                    device_replacement: 'Nokia $1',
                    manufacturer: 'Nokia',
                },
                {
                    regex: 'Nokia ([A-Za-z0-9\\-]+)',
                    device_replacement: 'Nokia $1',
                    manufacturer: 'Nokia',
                },
                {
                    regex: 'Lumia ([A-Za-z0-9\\-]+)',
                    device_replacement: 'Lumia $1',
                    manufacturer: 'Nokia',
                },
                {
                    regex: 'Symbian',
                    device_replacement: 'Nokia',
                    manufacturer: 'Nokia',
                },
                {
                    regex: '(PlayBook).+RIM Tablet OS',
                    device_replacement: 'Blackberry Playbook',
                    tablet: true,
                    manufacturer: 'RIM',
                },
                {
                    regex: '(Black[Bb]erry [0-9]+);',
                    manufacturer: 'RIM',
                },
                {
                    regex: 'Black[Bb]erry([0-9]+)',
                    device_replacement: 'BlackBerry $1',
                    manufacturer: 'RIM',
                },
                {
                    regex: '(Pre)/(\\d+)\\.(\\d+)',
                    device_replacement: 'Palm Pre',
                    manufacturer: 'Palm',
                },
                {
                    regex: '(Pixi)/(\\d+)\\.(\\d+)',
                    device_replacement: 'Palm Pixi',
                    manufacturer: 'Palm',
                },
                {
                    regex: '(Touchpad)/(\\d+)\\.(\\d+)',
                    device_replacement: 'HP Touchpad',
                    manufacturer: 'HP',
                },
                {
                    regex: 'HPiPAQ([A-Za-z0-9]+)/(\\d+).(\\d+)',
                    device_replacement: 'HP iPAQ $1',
                    manufacturer: 'HP',
                },
                {
                    regex: 'Palm([A-Za-z0-9]+)',
                    device_replacement: 'Palm $1',
                    manufacturer: 'Palm',
                },
                {
                    regex: 'Treo([A-Za-z0-9]+)',
                    device_replacement: 'Palm Treo $1',
                    manufacturer: 'Palm',
                },
                {
                    regex: 'webOS.*(P160UNA)/(\\d+).(\\d+)',
                    device_replacement: 'HP Veer',
                    manufacturer: 'HP',
                },
                {
                    regex: '(Kindle Fire)',
                    manufacturer: 'Amazon',
                },
                {
                    regex: '(Kindle)',
                    manufacturer: 'Amazon',
                },
                {
                    regex: '(Silk)/(\\d+)\\.(\\d+)(?:\\.([0-9\\-]+))?',
                    device_replacement: 'Kindle Fire',
                    tablet: true,
                    manufacturer: 'Amazon',
                },
                {
                    regex: '(iPad) Simulator;',
                    manufacturer: 'Apple',
                },
                {
                    regex: '(iPad);',
                    manufacturer: 'Apple',
                },
                {
                    regex: '(iPod);',
                    manufacturer: 'Apple',
                },
                {
                    regex: '(iPhone) Simulator;',
                    manufacturer: 'Apple',
                },
                {
                    regex: '(iPhone);',
                    manufacturer: 'Apple',
                },
                {
                    regex: 'Nexus\\ ([A-Za-z0-9\\-]+)',
                    device_replacement: 'Nexus $1',
                },
                {
                    regex: 'acer_([A-Za-z0-9]+)_',
                    device_replacement: 'Acer $1',
                    manufacturer: 'Acer',
                },
                {
                    regex: 'acer_([A-Za-z0-9]+)_',
                    device_replacement: 'Acer $1',
                    manufacturer: 'Acer',
                },
                {
                    regex: 'Amoi\\-([A-Za-z0-9]+)',
                    device_replacement: 'Amoi $1',
                    other: true,
                    manufacturer: 'Amoi',
                },
                {
                    regex: 'AMOI\\-([A-Za-z0-9]+)',
                    device_replacement: 'Amoi $1',
                    other: true,
                    manufacturer: 'Amoi',
                },
                {
                    regex: 'Asus\\-([A-Za-z0-9]+)',
                    device_replacement: 'Asus $1',
                    manufacturer: 'Asus',
                },
                {
                    regex: 'ASUS\\-([A-Za-z0-9]+)',
                    device_replacement: 'Asus $1',
                    manufacturer: 'Asus',
                },
                {
                    regex: 'BIRD\\-([A-Za-z0-9]+)',
                    device_replacement: 'Bird $1',
                    other: true,
                },
                {
                    regex: 'BIRD\\.([A-Za-z0-9]+)',
                    device_replacement: 'Bird $1',
                    other: true,
                },
                {
                    regex: 'BIRD ([A-Za-z0-9]+)',
                    device_replacement: 'Bird $1',
                    other: true,
                },
                {
                    regex: 'Dell ([A-Za-z0-9]+)',
                    device_replacement: 'Dell $1',
                    manufacturer: 'Dell',
                },
                {
                    regex: 'DoCoMo/2\\.0 ([A-Za-z0-9]+)',
                    device_replacement: 'DoCoMo $1',
                    other: true,
                },
                {
                    regex: '([A-Za-z0-9]+)\\_W\\;FOMA',
                    device_replacement: 'DoCoMo $1',
                    other: true,
                },
                {
                    regex: '([A-Za-z0-9]+)\\;FOMA',
                    device_replacement: 'DoCoMo $1',
                    other: true,
                },
                {
                    regex: 'vodafone([A-Za-z0-9]+)',
                    device_replacement: 'Huawei Vodafone $1',
                    other: true,
                },
                {
                    regex: 'i\\-mate ([A-Za-z0-9]+)',
                    device_replacement: 'i-mate $1',
                    other: true,
                },
                {
                    regex: 'Kyocera\\-([A-Za-z0-9]+)',
                    device_replacement: 'Kyocera $1',
                    other: true,
                },
                {
                    regex: 'KWC\\-([A-Za-z0-9]+)',
                    device_replacement: 'Kyocera $1',
                    other: true,
                },
                {
                    regex: 'Lenovo\\-([A-Za-z0-9]+)',
                    device_replacement: 'Lenovo $1',
                    manufacturer: 'Lenovo',
                },
                {
                    regex: 'Lenovo\\_([A-Za-z0-9]+)',
                    device_replacement: 'Lenovo $1',
                    manufacturer: 'Levovo',
                },
                {
                    regex: 'LG/([A-Za-z0-9]+)',
                    device_replacement: 'LG $1',
                    manufacturer: 'LG',
                },
                {
                    regex: 'LG-LG([A-Za-z0-9]+)',
                    device_replacement: 'LG $1',
                    manufacturer: 'LG',
                },
                {
                    regex: 'LGE-LG([A-Za-z0-9]+)',
                    device_replacement: 'LG $1',
                    manufacturer: 'LG',
                },
                {
                    regex: 'LGE VX([A-Za-z0-9]+)',
                    device_replacement: 'LG $1',
                    manufacturer: 'LG',
                },
                {
                    regex: 'LG ([A-Za-z0-9]+)',
                    device_replacement: 'LG $1',
                    manufacturer: 'LG',
                },
                {
                    regex: 'LGE LG\\-AX([A-Za-z0-9]+)',
                    device_replacement: 'LG $1',
                    manufacturer: 'LG',
                },
                {
                    regex: 'LG\\-([A-Za-z0-9]+)',
                    device_replacement: 'LG $1',
                    manufacturer: 'LG',
                },
                {
                    regex: 'LGE\\-([A-Za-z0-9]+)',
                    device_replacement: 'LG $1',
                    manufacturer: 'LG',
                },
                {
                    regex: 'LG([A-Za-z0-9]+)',
                    device_replacement: 'LG $1',
                    manufacturer: 'LG',
                },
                {
                    regex: '(KIN)\\.One (\\d+)\\.(\\d+)',
                    device_replacement: 'Microsoft $1',
                },
                {
                    regex: '(KIN)\\.Two (\\d+)\\.(\\d+)',
                    device_replacement: 'Microsoft $1',
                },
                {
                    regex: '(Motorola)\\-([A-Za-z0-9]+)',
                    manufacturer: 'Motorola',
                },
                {
                    regex: 'MOTO\\-([A-Za-z0-9]+)',
                    device_replacement: 'Motorola $1',
                    manufacturer: 'Motorola',
                },
                {
                    regex: 'MOT\\-([A-Za-z0-9]+)',
                    device_replacement: 'Motorola $1',
                    manufacturer: 'Motorola',
                },
                {
                    regex: 'Philips([A-Za-z0-9]+)',
                    device_replacement: 'Philips $1',
                    manufacturer: 'Philips',
                },
                {
                    regex: 'Philips ([A-Za-z0-9]+)',
                    device_replacement: 'Philips $1',
                    manufacturer: 'Philips',
                },
                {
                    regex: 'SAMSUNG-([A-Za-z0-9\\-]+)',
                    device_replacement: 'Samsung $1',
                    manufacturer: 'Samsung',
                },
                {
                    regex: 'SAMSUNG\\; ([A-Za-z0-9\\-]+)',
                    device_replacement: 'Samsung $1',
                    manufacturer: 'Samsung',
                },
                {
                    regex: 'Softbank/1\\.0/([A-Za-z0-9]+)',
                    device_replacement: 'Softbank $1',
                    other: true,
                },
                {
                    regex: 'Softbank/2\\.0/([A-Za-z0-9]+)',
                    device_replacement: 'Softbank $1',
                    other: true,
                },
                {
                    regex: '(hiptop|avantgo|plucker|xiino|blazer|elaine|up.browser|up.link|mmp|smartphone|midp|wap|vodafone|o2|pocket|mobile|pda)',
                    device_replacement: 'Generic Smartphone',
                },
                {
                    regex:
                        '^(1207|3gso|4thp|501i|502i|503i|504i|505i|506i|6310|6590|770s|802s|a wa|acer|acs\\-|airn|alav|asus|attw|au\\-m|aur |aus |abac|acoo|aiko|alco|alca|amoi|anex|anny|anyw|aptu|arch|argo|bell|bird|bw\\-n|bw\\-u|beck|benq|bilb|blac|c55/|cdm\\-|chtm|capi|comp|cond|craw|dall|dbte|dc\\-s|dica|ds\\-d|ds12|dait|devi|dmob|doco|dopo|el49|erk0|esl8|ez40|ez60|ez70|ezos|ezze|elai|emul|eric|ezwa|fake|fly\\-|fly\\_|g\\-mo|g1 u|g560|gf\\-5|grun|gene|go.w|good|grad|hcit|hd\\-m|hd\\-p|hd\\-t|hei\\-|hp i|hpip|hs\\-c|htc |htc\\-|htca|htcg)',
                    device_replacement: 'Generic Feature Phone',
                },
                {
                    regex:
                        '^(htcp|htcs|htct|htc\\_|haie|hita|huaw|hutc|i\\-20|i\\-go|i\\-ma|i230|iac|iac\\-|iac/|ig01|im1k|inno|iris|jata|java|kddi|kgt|kgt/|kpt |kwc\\-|klon|lexi|lg g|lg\\-a|lg\\-b|lg\\-c|lg\\-d|lg\\-f|lg\\-g|lg\\-k|lg\\-l|lg\\-m|lg\\-o|lg\\-p|lg\\-s|lg\\-t|lg\\-u|lg\\-w|lg/k|lg/l|lg/u|lg50|lg54|lge\\-|lge/|lynx|leno|m1\\-w|m3ga|m50/|maui|mc01|mc21|mcca|medi|meri|mio8|mioa|mo01|mo02|mode|modo|mot |mot\\-|mt50|mtp1|mtv |mate|maxo|merc|mits|mobi|motv|mozz|n100|n101|n102|n202|n203|n300|n302|n500|n502|n505|n700|n701|n710|nec\\-|nem\\-|newg|neon)',
                    device_replacement: 'Generic Feature Phone',
                },
                {
                    regex:
                        '^(netf|noki|nzph|o2 x|o2\\-x|opwv|owg1|opti|oran|ot\\-s|p800|pand|pg\\-1|pg\\-2|pg\\-3|pg\\-6|pg\\-8|pg\\-c|pg13|phil|pn\\-2|pt\\-g|palm|pana|pire|pock|pose|psio|qa\\-a|qc\\-2|qc\\-3|qc\\-5|qc\\-7|qc07|qc12|qc21|qc32|qc60|qci\\-|qwap|qtek|r380|r600|raks|rim9|rove|s55/|sage|sams|sc01|sch\\-|scp\\-|sdk/|se47|sec\\-|sec0|sec1|semc|sgh\\-|shar|sie\\-|sk\\-0|sl45|slid|smb3|smt5|sp01|sph\\-|spv |spv\\-|sy01|samm|sany|sava|scoo|send|siem|smar|smit|soft|sony|t\\-mo|t218|t250|t600|t610|t618|tcl\\-|tdg\\-|telm|tim\\-|ts70|tsm\\-|tsm3|tsm5|tx\\-9|tagt)',
                    device_replacement: 'Generic Feature Phone',
                },
                {
                    regex:
                        '^(talk|teli|topl|tosh|up.b|upg1|utst|v400|v750|veri|vk\\-v|vk40|vk50|vk52|vk53|vm40|vx98|virg|vite|voda|vulc|w3c |w3c\\-|wapj|wapp|wapu|wapm|wig |wapi|wapr|wapv|wapy|wapa|waps|wapt|winc|winw|wonu|x700|xda2|xdag|yas\\-|your|zte\\-|zeto|aste|audi|avan|blaz|brew|brvw|bumb|ccwa|cell|cldc|cmd\\-|dang|eml2|fetc|hipt|http|ibro|idea|ikom|ipaq|jbro|jemu|jigs|keji|kyoc|kyok|libw|m\\-cr|midp|mmef|moto|mwbp|mywa|newt|nok6|o2im|pant|pdxg|play|pluc|port|prox|rozo|sama|seri|smal|symb|treo|upsi|vx52|vx53|vx60|vx61|vx70|vx80|vx81|vx83|vx85|wap\\-|webc|whit|wmlb|xda\\-|xda\\_)',
                    device_replacement: 'Generic Feature Phone',
                },
                {
                    regex:
                        '(bot|borg|google(^tv)|yahoo|slurp|msnbot|msrbot|openbot|archiver|netresearch|lycos|scooter|altavista|teoma|gigabot|baiduspider|blitzbot|oegp|charlotte|furlbot|http%20client|polybot|htdig|ichiro|mogimogi|larbin|pompos|scrubby|searchsight|seekbot|semanticdiscovery|silk|snappy|speedy|spider|voila|vortex|voyager|zao|zeal|fast\\-webcrawler|converacrawler|dataparksearch|findlinks)',
                    device_replacement: 'Spider',
                },
            ],
            mobile_browser_families: [
                'Firefox Mobile',
                'Opera Mobile',
                'Opera Mini',
                'Mobile Safari',
                'webOS',
                'IE Mobile',
                'Playstation Portable',
                'Nokia',
                'Blackberry',
                'Palm',
                'Silk',
                'Android',
                'Maemo',
                'Obigo',
                'Netfront',
                'AvantGo',
                'Teleca',
                'SEMC-Browser',
                'Bolt',
                'Iris',
                'UP.Browser',
                'Symphony',
                'Minimo',
                'Bunjaloo',
                'Jasmine',
                'Dolfin',
                'Polaris',
                'BREW',
                'Chrome Mobile',
                'Chrome Mobile iOS',
                'UC Browser',
                'Tizen Browser',
            ],
        };
        // Parsers
        _this.parsers = ['device_parsers', 'browser_parsers', 'os_parsers', 'mobile_os_families', 'mobile_browser_families'];
        // Types
        _this.types = ['browser', 'os', 'device'];
        // Regular Expressions
        _this.regexes =
            regexes ||
            (function () {
                var results = {};
                _this.parsers.map(function (parser) {
                    results[parser] = [];
                });
                return results;
            })();
        // Families
        _this.families = (function () {
            var results = {};
            _this.types.map(function (type) {
                results[type] = [];
            });
            return results;
        })();
        // Utility Variables
        var ArrayProto = Array.prototype,
            ObjProto = Object.prototype,
            FuncProto = Function.prototype,
            nativeForEach = ArrayProto.forEach,
            nativeIndexOf = ArrayProto.indexOf;
        // Find Utility
        var find = function (ua, obj) {
            var ret = {};
            for (var i = 0; i < obj.length; i++) {
                ret = obj[i](ua);
                if (ret) {
                    break;
                }
            }
            return ret;
        };
        // Remove Utility
        var remove = function (arr, props) {
            each(arr, function (obj) {
                each(props, function (prop) {
                    delete obj[prop];
                });
            });
        };
        // Contains Utility
        var contains = function (obj, target) {
            var found = false;
            if (obj == null) return found;
            if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
            found = any(obj, function (value) {
                return value === target;
            });
            return found;
        };
        // Each Utility
        var each = (forEach = function (obj, iterator, context) {
            if (obj == null) return;
            if (nativeForEach && obj.forEach === nativeForEach) {
                obj.forEach(iterator, context);
            } else if (obj.length === +obj.length) {
                for (var i = 0, l = obj.length; i < l; i++) {
                    iterator.call(context, obj[i], i, obj);
                }
            } else {
                for (var key in obj) {
                    if (_.has(obj, key)) {
                        iterator.call(context, obj[key], key, obj);
                    }
                }
            }
        });
        // Extend Utiltiy
        var extend = function (obj) {
            each(slice.call(arguments, 1), function (source) {
                for (var prop in source) {
                    obj[prop] = source[prop];
                }
            });
            return obj;
        };
        // Check String Utility
        var check = function (str) {
            return !!(str && typeof str != 'undefined' && str != null);
        };
        // To Version String Utility
        var toVersionString = function (obj) {
            var output = '';
            obj = obj || {};
            if (check(obj)) {
                if (check(obj.major)) {
                    output += obj.major;
                    if (check(obj.minor)) {
                        output += '.' + obj.minor;
                        if (check(obj.patch)) {
                            output += '.' + obj.patch;
                        }
                    }
                }
            }
            return output;
        };
        // To String Utility
        var toString = function (obj) {
            obj = obj || {};
            var suffix = toVersionString(obj);
            if (suffix) suffix = ' ' + suffix;
            return obj && check(obj.family) ? obj.family + suffix : '';
        };
        // Parse User-Agent String
        _this.parse = function (ua) {
            // Parsers Utility
            var parsers = function (type) {
                return _this.regexes[type + '_parsers'].map(function (obj) {
                    var regexp = new RegExp(obj.regex),
                        rep = obj[(type === 'browser' ? 'family' : type) + '_replacement'],
                        major_rep = obj.major_version_replacement;
                    function parser(ua) {
                        var m = ua.match(regexp);
                        if (!m) return null;
                        var ret = {};
                        ret.family = (rep ? rep.replace('$1', m[1]) : m[1]) || 'other';
                        ret.major = parseInt(major_rep ? major_rep : m[2]) || null;
                        ret.minor = m[3] ? parseInt(m[3]) : null;
                        ret.patch = m[4] ? parseInt(m[4]) : null;
                        ret.tablet = obj.tablet;
                        ret.man = obj.manufacturer || null;
                        return ret;
                    }
                    return parser;
                });
            };
            // User Agent
            var UserAgent = function () {};
            // Browsers Parsed
            var browser_parsers = parsers('browser');
            // Operating Systems Parsed
            var os_parsers = parsers('os');
            // Devices Parsed
            var device_parsers = parsers('device');
            // Set Agent
            var a = new UserAgent();
            // Remember the original user agent string
            a.source = ua;
            // Set Browser
            a.browser = find(ua, browser_parsers);
            if (check(a.browser)) {
                a.browser.name = toString(a.browser);
                a.browser.version = toVersionString(a.browser);
            } else {
                a.browser = {};
            }
            // Set OS
            a.os = find(ua, os_parsers);
            if (check(a.os)) {
                a.os.name = toString(a.os);
                a.os.version = toVersionString(a.os);
            } else {
                a.os = {};
            }
            // Set Device
            a.device = find(ua, device_parsers);
            if (check(a.device)) {
                a.device.name = toString(a.device);
                a.device.version = toVersionString(a.device);
            } else {
                a.device = {
                    tablet: false,
                    family: 'Other',
                };
            }
            // Determine Device Type
            var mobile_agents = {};
            var mobile_browser_families = _this.regexes.mobile_browser_families.map(function (str) {
                mobile_agents[str] = true;
            });
            var mobile_os_families = _this.regexes.mobile_os_families.map(function (str) {
                mobile_agents[str] = true;
            });
            // Is Spider
            if (a.browser.family === 'Spider') {
                a.device.type = 'Spider';
            } else if (a.browser.tablet || a.os.tablet || a.device.tablet) {
                a.device.type = 'Tablet';
            } else if (mobile_agents.hasOwnProperty(a.browser.family)) {
                a.device.type = 'Mobile';
            } else {
                a.device.type = 'Desktop';
            }
            // Determine Device Manufacturer
            a.device.manufacturer = a.browser.man || a.os.man || a.device.man || null;
            // Cleanup Objects
            remove([a.browser, a.os, a.device], ['tablet', 'man']);
            // Return Agent
            return a;
        };
        // Return context
        return _this;
    })());
    // Export the Underscore object for **Node.js** and **"CommonJS"**,
    // backwards-compatibility for the old `require()` API. If we're not
    // CommonJS, add `_` to the global object via a string identifier
    // the Closure Compiler "advanced" mode. Registration as an AMD
    // via define() happens at the end of this file
    if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = detect;
        }
        exports.detect = detect;
    } else {
        root['detect'] = detect;
    }
    // AMD define happens at the end for compatibility with AMD
    // that don't enforce next-turn semantics on modules
    if (typeof define === 'function' && define.amd) {
        define(function (require) {
            return detect;
        });
    }
})(window);

/*!
 * bsStepper v1.7.0 (https://github.com/Johann-S/bs-stepper)
 * Copyright 2018 - 2019 Johann-S <johann.servoire@gmail.com>
 * Licensed under MIT (https://github.com/Johann-S/bs-stepper/blob/master/LICENSE)
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t=t||self).Stepper=e()}(this,function(){"use strict";function t(){return(t=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&(t[s]=n[s])}return t}).apply(this,arguments)}var e=window.Element.prototype.matches,n=function(t,e){return t.closest(e)},s=function(t,e){return new window.Event(t,e)},i=function(t,e){return new window.CustomEvent(t,e)};!function(){if(window.Element.prototype.matches||(e=window.Element.prototype.msMatchesSelector||window.Element.prototype.webkitMatchesSelector),window.Element.prototype.closest||(n=function(t,n){if(!document.documentElement.contains(t))return null;do{if(e.call(t,n))return t;t=t.parentElement||t.parentNode}while(null!==t&&1===t.nodeType);return null}),window.Event&&"function"==typeof window.Event||(s=function(t,e){e=e||{};var n=document.createEvent("Event");return n.initEvent(t,Boolean(e.bubbles),Boolean(e.cancelable)),n}),"function"!=typeof window.CustomEvent){var t=window.Event.prototype.preventDefault;i=function(e,n){var s=document.createEvent("CustomEvent");return n=n||{bubbles:!1,cancelable:!1,detail:null},s.initCustomEvent(e,n.bubbles,n.cancelable,n.detail),s.preventDefault=function(){this.cancelable&&(t.call(this),Object.defineProperty(this,"defaultPrevented",{get:function(){return!0}}))},s}}}();var r={ACTIVE:"active",LINEAR:"linear",BLOCK:"dstepper-block",NONE:"dstepper-none",FADE:"fade",VERTICAL:"vertical"},o="transitionend",c="bsStepper",a=function(t,e,n,s){var o=t[c];if(!o._steps[e].classList.contains(r.ACTIVE)&&!o._stepsContents[e].classList.contains(r.ACTIVE)){var a=i("show.bs-stepper",{cancelable:!0,detail:{from:o._currentIndex,to:e,indexStep:e}});t.dispatchEvent(a);var p=o._steps.filter(function(t){return t.classList.contains(r.ACTIVE)}),d=o._stepsContents.filter(function(t){return t.classList.contains(r.ACTIVE)});a.defaultPrevented||(p.length&&p[0].classList.remove(r.ACTIVE),d.length&&(d[0].classList.remove(r.ACTIVE),t.classList.contains(r.VERTICAL)||o.options.animation||d[0].classList.remove(r.BLOCK)),l(t,o._steps[e],o._steps,n),u(t,o._stepsContents[e],o._stepsContents,d,s))}},l=function(t,e,n,s){n.forEach(function(e){var n=e.querySelector(s.selectors.trigger);n.setAttribute("aria-selected","false"),t.classList.contains(r.LINEAR)&&n.setAttribute("disabled","disabled")}),e.classList.add(r.ACTIVE);var i=e.querySelector(s.selectors.trigger);i.setAttribute("aria-selected","true"),t.classList.contains(r.LINEAR)&&i.removeAttribute("disabled")},u=function(t,e,n,s,a){var l=t[c],u=n.indexOf(e),f=i("shown.bs-stepper",{cancelable:!0,detail:{from:l._currentIndex,to:u,indexStep:u}});if(e.classList.contains(r.FADE)){e.classList.remove(r.NONE);var h=p(e);e.addEventListener(o,function n(){e.classList.add(r.BLOCK),e.removeEventListener(o,n),t.dispatchEvent(f),a()}),s.length&&s[0].classList.add(r.NONE),e.classList.add(r.ACTIVE),d(e,h)}else e.classList.add(r.ACTIVE),e.classList.add(r.BLOCK),t.dispatchEvent(f),a()},p=function(t){if(!t)return 0;var e=window.getComputedStyle(t).transitionDuration;return parseFloat(e)?(e=e.split(",")[0],1e3*parseFloat(e)):0},d=function(t,e){var n=!1,i=e+5;function r(){n=!0,t.removeEventListener(o,r)}t.addEventListener(o,r),window.setTimeout(function(){n||t.dispatchEvent(s(o)),t.removeEventListener(o,r)},i)},f=function(t,e){e.animation&&t.forEach(function(t){t.classList.add(r.FADE),t.classList.add(r.NONE)})},h={linear:!0,animation:!1,selectors:{steps:".step",trigger:".step-trigger",stepper:".bs-stepper"}};return function(){function e(e,n){var s=this;void 0===n&&(n={}),this._element=e,this._currentIndex=0,this._stepsContents=[],this.options=t({},h,{},n),this.options.selectors=t({},h.selectors,{},this.options.selectors),this.options.linear&&this._element.classList.add(r.LINEAR),this._steps=[].slice.call(this._element.querySelectorAll(this.options.selectors.steps)),this._steps.filter(function(t){return t.hasAttribute("data-target")}).forEach(function(t){s._stepsContents.push(s._element.querySelector(t.getAttribute("data-target")))}),f(this._stepsContents,this.options),this._setLinkListeners(),Object.defineProperty(this._element,c,{value:this,writable:!0}),this._steps.length&&a(this._element,this._currentIndex,this.options,function(){})}var s=e.prototype;return s._setLinkListeners=function(){var t=this;this._steps.forEach(function(e){var s,i=e.querySelector(t.options.selectors.trigger);t.options.linear?(t._clickStepLinearListener=(t.options,function(t){t.preventDefault()}),i.addEventListener("click",t._clickStepLinearListener)):(t._clickStepNonLinearListener=(s=t.options,function(t){t.preventDefault();var e=n(t.target,s.selectors.steps),i=n(e,s.selectors.stepper),r=i[c],o=r._steps.indexOf(e);a(i,o,s,function(){r._currentIndex=o})}),i.addEventListener("click",t._clickStepNonLinearListener))})},s.next=function(){var t=this,e=this._currentIndex+1<=this._steps.length-1?this._currentIndex+1:this._steps.length-1;a(this._element,e,this.options,function(){t._currentIndex=e})},s.previous=function(){var t=this,e=this._currentIndex-1>=0?this._currentIndex-1:0;a(this._element,e,this.options,function(){t._currentIndex=e})},s.to=function(t){var e=this,n=t-1,s=n>=0&&n<this._steps.length?n:0;a(this._element,s,this.options,function(){e._currentIndex=s})},s.reset=function(){var t=this;a(this._element,0,this.options,function(){t._currentIndex=0})},s.destroy=function(){var t=this;this._steps.forEach(function(e){var n=e.querySelector(t.options.selectors.trigger);t.options.linear?n.removeEventListener("click",t._clickStepLinearListener):n.removeEventListener("click",t._clickStepNonLinearListener)}),this._element[c]=void 0,this._element=void 0,this._currentIndex=void 0,this._steps=void 0,this._stepsContents=void 0,this._clickStepLinearListener=void 0,this._clickStepNonLinearListener=void 0},e}()});
//# sourceMappingURL=bs-stepper.min.js.map
/**
 *  Add Popin
 * @param {String} id (should start with # : for example '#popin-message-1')
 * @param {String} icon
 * @param {String} title
 * @param {String} style  value:[ 'none' , 'video']
 * @param {String} closeLabel button close label
 * @param {Boolean} isClosable set true if poppin closable by clicking on background
 */
function popinBox(_id, _icon, _title, _style, _closeLabel, _isClosable) {
    if (_id.charAt(0) !== '#') {
        _id = '#' + _id;
    }
    this.id = _id;
    this.icon = _icon;
    this.title = _title;
    this.style = _style;
    this.closeLabel = _closeLabel;
    this.isClosable = _isClosable;

    if (this.closeLabel === undefined) {
        this.closeLabel = 'Fermer : ' + this.title;
    }
    if (this.isClosable === undefined || this.isClosable === '') {
        this.isClosable = true;
    }

    this.bindEvents();
}

popinBox.prototype = {
    id: null,
    previousFocus: null,
    onShow: undefined,
    onHide: undefined,
    previousScrollPosition: 0,

    generatePopin: function () {
        var _id = this.id;
        if (_id.charAt(0) === '#') {
            _id = _id.substr(1);
        }
        //TODO ALLOW CODE BLOCK WHEN BABEL IS ADDED
        // var popin = document.createElement('div');
        // popin.innerHTML = `<div id="${_id}"
        //                 class="o-popin ${this.style}"
        //                 role="dialog"
        //                 aria-label="${this.title}"
        //                 aria-hidden="true">
        //                 <div class="o-popin__body" role="document">
        //                     <div class="o-popin__container">
        //                         <div class="o-popin__header">
        //                             <div class="o-popin__header__icon">
        //                                 <svg class="a-icon--l">
        //                                     <use xlink:href="/etc.clientlibs/labanquepostale/commons/clientlibs/base/resources/svg-icons.svg#${this.icon}"></use>
        //                                 </svg>
        //                             </div>
        //                             <a type="button"
        //                                 class="m-button m-button__icon--alt"
        //                                 data-popin-close="#${_id}"
        //                                 title="${this.closeLabel}"
        //                                 tabindex="1">
        //                                 <svg class="a-icon--s">
        //                                     <use xlink:href="/etc.clientlibs/labanquepostale/commons/clientlibs/base/resources/svg-icons.svg#ic-interface-close"></use>
        //                                 </svg>
        //                                 <span>${this.closeLabel}</span>
        //                             </a>
        //                         </div>
        //                         <div class="o-popin__content__body">
        //                             <div class="o-popin__content">
        //                             </div>
        //                         </div>
        //                     </div>
        //                 </div>
        //             </div>`;

        // TODO : Replace this code by previous one
        var popin = '<div id="'
            .concat(_id, '"\n class="o-popin ')
            .concat(this.style, '"\n role="dialog"\n aria-label="')
            .concat(
                this.title,
                '"\n aria-hidden="true">\n <div class="o-popin__body" role="document">\n <div class="o-popin__header">\n <div class="o-popin__header__icon">\n <svg class="a-icon--l" aria-hidden="true" focusable="false">\n <use xlink:href="/etc.clientlibs/labanquepostale/commons/clientlibs/base/resources/svg-icons.svg#'
            )
            .concat(this.icon, '"></use>\n </svg>\n </div>\n <button type="button"\n class="m-button m-button__icon--alt"\n data-popin-close="#')
            .concat(_id, '"\n title="')
            .concat(
                this.closeLabel,
                '"\n tabindex="0">\n <svg class="a-icon--s" aria-hidden="true" focusable="false">\n <use xlink:href="/etc.clientlibs/labanquepostale/commons/clientlibs/base/resources/svg-icons.svg#ic-interface-close"></use>\n </svg>\n <span>'
            )
            .concat(this.closeLabel, '</span>\n </button>\n </div>\n <div class="o-popin__container">\n <div class="o-popin__content">\n </div>\n </div>\n </div>\n </div>');

        if ($(this.id).length === 0) {
            $('body').append(popin);
            // document.body.appendChild(popin);
            // popin.outerHTML = popin.innerHTML;
        }
    },

    /**
     *  replace content of Popin
     * @param {HTMLElement} el
     */
    addContent: function (el) {
        $(this.id + ' .o-popin__content').html(el);
    },

    /**
     *  Show Popin
     *
     */
    showPopin: function () {
        var that = this,
            _id = this.id,
            ua = detect.parse(navigator.userAgent);

        this.previousScrollPosition = $(document).scrollTop();

        $('html').addClass('u-disabled-scrolling');
        $(_id).addClass('o-popin--is-active');
        $(_id).attr('aria-hidden', 'false');
        $(_id).attr('aria-modal', 'true');

        that.previousFocus = $(':focus');
        var closeButton = $(_id + ' a,' + _id + ' button,' + _id + ' input').first();
        closeButton.focus();
        //get if keyPopin#id event already exist
        var iskeyPopinEventSet = false;
        if ($._data(document, 'events').keydown !== undefined) {
            iskeyPopinEventSet = $._data(document, 'events').keydown.some(function (itemEvent) {
                return 'keyPopin' + _id === itemEvent.namespace;
            });
        }

        //add event listener only if not already declared
        if (!iskeyPopinEventSet) {
            $(document).on('keydown.keyPopin', function (e) {
                if (e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27) {
                    that.hidePopin();
                }
                if (e.key === 'Tab' || e.keyCode === 9) {
                    if (ua.browser.family !== 'IE') {
                        //If IE , setFocusIE() will be used so Iframe can be tab into
                        that.setFocus(e);
                    }
                }
                if ((e.key === 'Enter' || e.keyCode === 13) && $(e.target).is('.m-button')) {
                    if ($(':focus').is(closeButton)) {
                        e.preventDefault();
                        that.hidePopin();
                    }
                }
            });
            if (ua.browser.family === 'IE') {
                //set focus event for Tab on IE

                $(document).on('keydown.focusPopinIE keyup.focusPopinIE', function (e) {
                    if (e.key === 'Tab' || e.keyCode === 9) {
                        that.setFocusIE(e);
                        window.scrollTo(this.previousScrollPosition, 0);
                    }
                });

                //disable scroll if enter focus of non popin element // reset scrollposition
                $(window).on('scroll.focusPopinIE', function (e) {
                    event.preventDefault();
                    //window.scrollTo(this.previousScrollPosition, 0);
                });
            }
        }

        //Close modal on click on overlay background
        if (this.isClosable) {
            $(document).on('click.overlayPopin', '.o-popin', function (event) {
                if (event.target !== this) {
                    return;
                }
                event.preventDefault();
                that.hidePopin();
            });
        }

        if (this.onShow !== undefined) {
            //Callback
            this.onShow();
        }
    },

    /**
     *  Hide Popin
     */
    hidePopin: function () {
        var that = this,
            _id = this.id,
            ua = detect.parse(navigator.userAgent);

        $('html').removeClass('u-disabled-scrolling');
        $(_id).removeClass('o-popin--is-active');

        if (ua.browser.family === 'IE') {
            $('.o-popin').removeClass('o-popin--IE9');
        }

        $(_id).attr('aria-hidden', 'true');
        $(_id).removeAttr('aria-popin');
        $(_id).removeAttr('aria-modal');
        $(document).off('keydown.keyPopin');
        $(document).off('keydown.focusPopinIE keyup.focusPopinIE');
        $(document).off('scroll.focusPopinIE');
        $(document).off('click.overlayPopin');

        if (that.previousFocus !== null && that.previousFocus.length > 0) {
            that.previousFocus.focus();
        } else {
            setTimeout(function () {
                $('body').focus();
            }, 300);
            $('body').attr('tabindex', '-1');
        }

        if (this.onHide !== undefined) {
            this.onHide();
        }
    },

    /**
     *  return true if popin is Open
     */
    isVisible: function () {
        return !$(this.id).attr('aria-hidden');
    },

    /**
     * Set focus for TAB Keyboard event for all browser except IE
     * @param {Event} event
     */
    setFocus: function (event) {
        event.preventDefault();
        var _id = this.id;

        var listFocus = $(_id + ' a,' + _id + ' button,' + _id + ' input,' + _id + ' iframe');
        var index = listFocus.index(listFocus.filter(':focus'));

        if (event.shiftKey === true) {
            index--;
        } else {
            index++;
        }
        if (index >= listFocus.length) {
            index = 0;
        }
        if (index < 0) {
            index = listFocus.length - 1;
        }
        if ($(listFocus[index]).is('iframe')) {
            var iframeEl = listFocus[index];
            setTimeout(function () {
                if (iframeEl.contentWindow) {
                    iframeEl.contentWindow.focus();
                } else if (iframeEl.contentDocument && iframeEl.contentDocument.documentElement) {
                    // For old versions of Safari
                    iframeEl.contentDocument.documentElement.focus();
                }
            }, 100);
        }
        listFocus[index].focus();
    },

    /**
     * Set focus for TAB Keyboard event for IE (makes it so you can TAB into an exeternal iframe inside the popin)
     * @param {Event} event
     */
    setFocusIE: function (event) {
        var el = $(':focus'),
            parent = el.closest(this.id);

        if (!parent.length) {
            event.preventDefault();
            event.stopPropagation();

            //if focus event outside of popin, focus on closing modal button
            var closeButton = $('[data-popin-close="' + this.id + '"]').first();
            closeButton.focus();
        }
    },

    /**
     *  init Event Popin
     */
    bindEvents: function () {
        var that = this;

        //init button trigger opening popin
        $(document).on('click', '[data-popin-target="' + that.id + '"]', function (event) {
            event.preventDefault();
            that.showPopin();
        });

        $(document).on('click', '[data-popin-close="' + that.id + '"]', function (event) {
            event.preventDefault();
            that.hidePopin();
        });

        /**
         * Global event
         */
        $(document).on('showPopin.' + this.id, function () {
            // to use for non link/button opening of popin
            // ex : $('#o-popin').trigger('showPopin');
            that.showPopin();
        });
    },
};

(function ($) {
    /**
     *  init existing inline popin
     */
    var listPopin = $('.o-popin');
    if (listPopin.length) {
        listPopin.each(function () {
            var _id = $(this).attr('id');
            var popin = new popinBox(
                '#' + _id,
                '',
                '',
                '',
                $('[data-popin-close="#' + _id + '"]')
                    .find('.sr-only')
                    .text(),
                true
            );
        });
    }
})(window.jQuery);

function OldBrowser() {}

OldBrowser.prototype = {
    // detectjs library for parsing user agant informations
    ua: detect.parse(navigator.userAgent),
    nbDisplay: parseInt($('.o-popin').attr('data-nbdisplay')),
    browserList: $('.o-popin').attr('data-browserversion'),
    popinId: $('#o-popin--ob'),
    popinSubtitle: $('#o-popin--ob').find('.js-popin__subtitle'),
    closeLabel: $('[data-popin-close="#o-popin--ob"]').find('.sr-only').text(),
    browser: '',
    popin: null,

    showPopin: function () {
        var title = $('#o-popin--ob').find('h2').text();
        var isEdit = this.popinId.parent().hasClass('o-popin-is--edit');

        if (this.popin === undefined || (this.popin === null && !isEdit)) {
            this.popin = new popinBox('#o-popin--ob', '', title, '', this.closeLabel, true);
        }

        this.popin.showPopin();
    },
    init: function () {
        var mobile = $(window).width() < 768 ? true : false;
        var edge = navigator.userAgent.indexOf('Edg') > -1;
        var name;

        if (mobile) {
            name = this.ua.os.family;
        } else if (!mobile && !edge) {
            name = this.ua.browser.family;
        } else if (edge) {
            name = 'Edge';
        }

        var browser = {
            name: name,
            version: mobile ? this.ua.os.major : this.ua.browser.major,
        };
        if (browser !== undefined && browser.name === 'IE') {
            if (!(browser.version > 10)) {
                $('.o-popin').addClass('o-popin--IE9');
            }
        } else {
            $('.o-popin__container').attr('data-scrollbar', '');
        }

        this.browser = browser;
        this.setBrowserType();
        var old = this.compareBrowser();

        if (old) {
            if (sessionStorage.getItem('OB')) {
                var ob = JSON.parse(sessionStorage.getItem('OB'));
                if (ob.display < this.nbDisplay) {
                    ob.display += 1;
                    sessionStorage.setItem('OB', JSON.stringify(ob));
                    this.showPopin();
                }
            } else {
                sessionStorage.setItem(
                    'OB',
                    JSON.stringify({
                        display: 1,
                    })
                );
                this.showPopin();
            }
        }
        this.events();
    },
    compareBrowser: function () {
        if (this.browserList !== undefined) {
            var json = JSON.parse(this.browserList.replace(/'/g, '"'));
            var that = this;
            for (var b = 0; b < json.length; b++) {
                var el = json[b];
                if (el.name === that.browser.name) {
                    if (that.browser.version < el.version) {
                        return true;
                    }
                    break;
                }
            }
        }
        return false;
    },
    setBrowserType: function () {
        function isChromium() {
            for (var i = 0; i < navigator.plugins.length; i++) {
                if (navigator.plugins[i].name === 'Chrome PDF Viewer') {
                    return false;
                }
            }
            return true;
        }
        if (this.ua.browser.family === 'Chrome' && isChromium()) {
            this.browser.name = 'Chromium';
        }
        var browserVersion = this.browser.version;
        var strings = [this.popinSubtitle.text(), this.browser.name, browserVersion];
        var newSubtxt = strings.join(' ');
        this.popinSubtitle.text(newSubtxt);
    },
    events: function () {
        _that = this;
        $(document).ready(function () {
            var hash = window.location.hash;
            if (hash.indexOf('browsermodal') > -1) {
                _that.showPopin();
            }
        });
    },
};

/**
 * init olBrowser
 */
(function ($) {
    var ob = new OldBrowser();
    if ($('#o-popin--ob').length) {
        ob.init();
    }
})(window.jQuery);

/*
 * init curstom scroll bar
 * https://kingsora.github.io/OverlayScrollbars/#!documentation
 */
(function ($) {
    var option = {
        className: 'a-scrollbar',
        clipAlways: true,
        nativeScrollbarsOverlaid: {
            showNativeScrollbars: false,
            initialize: true,
        },
        overflowBehavior: {
            x: 'hidden',
            y: 'scroll',
        },
        scrollbars: {
            visibility: 'auto',
            autoHide: 'never',
            autoHideDelay: 800,
            dragScrolling: true,
            clickScrolling: true,
            touchSupport: true,
            snapHandle: false,
        },
        textarea: {
            dynWidth: false,
            dynHeight: false,
            inheritedAttrs: ['style', 'class'],
        },
    };
    if ($('[data-scrollbar]').length) {
        var instance = $('[data-scrollbar]').overlayScrollbars(option);
    }
})(window.jQuery);

!(function (root, factory) {
    'function' == typeof define && define.amd // AMD. Register as an anonymous module unless amdModuleId is set
        ? define([], function () {
              return (root.svg4everybody = factory());
          })
        : 'object' == typeof module && module.exports // Node. Does not work with strict CommonJS, but
        ? // only CommonJS-like environments that support module.exports,
          // like Node.
          (module.exports = factory())
        : (root.svg4everybody = factory());
})(this, function () {
    /*! svg4everybody v2.1.9 | github.com/jonathantneal/svg4everybody */
    function embed(parent, svg, target, use) {
        // if the target exists
        if (target) {
            // create a document fragment to hold the contents of the target
            var fragment = document.createDocumentFragment(),
                viewBox = !svg.hasAttribute('viewBox') && target.getAttribute('viewBox');
            // conditionally set the viewBox on the svg
            viewBox && svg.setAttribute('viewBox', viewBox);
            // copy the contents of the clone into the fragment
            for (
                // clone the target
                var clone = document.importNode ? document.importNode(target, !0) : target.cloneNode(!0),
                    g = document.createElementNS(svg.namespaceURI || 'http://www.w3.org/2000/svg', 'g');
                clone.childNodes.length;

            ) {
                g.appendChild(clone.firstChild);
            }
            if (use) {
                for (var i = 0; use.attributes.length > i; i++) {
                    var attr = use.attributes[i];
                    'xlink:href' !== attr.name && 'href' !== attr.name && g.setAttribute(attr.name, attr.value);
                }
            }
            fragment.appendChild(g), // append the fragment into the svg
                parent.appendChild(fragment);
        }
    }
    function loadreadystatechange(xhr, use) {
        // listen to changes in the request
        (xhr.onreadystatechange = function () {
            // if the request is ready
            if (4 === xhr.readyState) {
                // get the cached html document
                var cachedDocument = xhr._cachedDocument;
                // ensure the cached html document based on the xhr response
                cachedDocument ||
                    ((cachedDocument = xhr._cachedDocument = document.implementation.createHTMLDocument('')),
                    (cachedDocument.body.innerHTML = xhr.responseText), // ensure domains are the same, otherwise we'll have issues appending the
                    // element in IE 11
                    cachedDocument.domain !== document.domain && (cachedDocument.domain = document.domain),
                    (xhr._cachedTarget = {})), // clear the xhr embeds list and embed each item
                    xhr._embeds.splice(0).map(function (item) {
                        // get the cached target
                        var target = xhr._cachedTarget[item.id];
                        // ensure the cached target
                        target || (target = xhr._cachedTarget[item.id] = cachedDocument.getElementById(item.id)),
                            // embed the target into the svg
                            embed(item.parent, item.svg, target, use);
                    });
            }
        }), // test the ready state change immediately
            xhr.onreadystatechange();
    }
    function svg4everybody(rawopts) {
        function oninterval() {
            // if all <use>s in the array are being bypassed, don't proceed.
            if (numberOfSvgUseElementsToBypass && uses.length - numberOfSvgUseElementsToBypass <= 0) {
                return void requestAnimationFrame(oninterval, 67);
            }
            // if there are <use>s to process, proceed.
            // reset the bypass counter, since the counter will be incremented for every bypassed element,
            // even ones that were counted before.
            numberOfSvgUseElementsToBypass = 0;
            // while the index exists in the live <use> collection
            for (
                // get the cached <use> index
                var index = 0;
                index < uses.length;

            ) {
                // get the current <use>
                var use = uses[index],
                    parent = use.parentNode,
                    svg = getSVGAncestor(parent),
                    src = use.getAttribute('xlink:href') || use.getAttribute('href');
                if ((!src && opts.attributeName && (src = use.getAttribute(opts.attributeName)), svg && src)) {
                    if (polyfill) {
                        if (!opts.validate || opts.validate(src, svg, use)) {
                            // remove the <use> element
                            parent.removeChild(use);
                            // parse the src and get the url and id
                            var srcSplit = src.split('#'),
                                url = srcSplit.shift(),
                                id = srcSplit.join('#');
                            // if the link is external
                            if (url.length) {
                                // get the cached xhr request
                                var xhr = requests[url];
                                // ensure the xhr request exists
                                xhr || ((xhr = requests[url] = new XMLHttpRequest()), xhr.open('GET', url), xhr.send(), (xhr._embeds = [])), // add the svg and id as an item to the xhr embeds list
                                    xhr._embeds.push({
                                        parent: parent,
                                        svg: svg,
                                        id: id,
                                    }), // prepare the xhr ready state change event
                                    loadreadystatechange(xhr, use);
                            } else {
                                // embed the local id into the svg
                                embed(parent, svg, document.getElementById(id), use);
                            }
                        } else {
                            // increase the index when the previous value was not "valid"
                            ++index, ++numberOfSvgUseElementsToBypass;
                        }
                    }
                } else {
                    // increase the index when the previous value was not "valid"
                    ++index;
                }
            }
            // continue the interval
            requestAnimationFrame(oninterval, 67);
        }
        var polyfill,
            opts = Object(rawopts),
            newerIEUA = /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/,
            webkitUA = /\bAppleWebKit\/(\d+)\b/,
            olderEdgeUA = /\bEdge\/12\.(\d+)\b/,
            edgeUA = /\bEdge\/.(\d+)\b/,
            inIframe = window.top !== window.self;
        polyfill =
            'polyfill' in opts
                ? opts.polyfill
                : newerIEUA.test(navigator.userAgent) ||
                  (navigator.userAgent.match(olderEdgeUA) || [])[1] < 10547 ||
                  (navigator.userAgent.match(webkitUA) || [])[1] < 537 ||
                  (edgeUA.test(navigator.userAgent) && inIframe);
        // create xhr requests object
        var requests = {},
            requestAnimationFrame = window.requestAnimationFrame || setTimeout,
            uses = document.getElementsByTagName('use'),
            numberOfSvgUseElementsToBypass = 0;
        // conditionally start the interval if the polyfill is active
        polyfill && oninterval();
    }
    function getSVGAncestor(node) {
        for (var svg = node; 'svg' !== svg.nodeName.toLowerCase() && (svg = svg.parentNode); ) {}
        return svg;
    }
    return svg4everybody;
});

/**
 * @popperjs/core v2.9.1 - MIT License
 */

'use strict';
!(function (e, t) {
    'object' == typeof exports && 'undefined' != typeof module
        ? t(exports)
        : 'function' == typeof define && define.amd
        ? define(['exports'], t)
        : t(((e = 'undefined' != typeof globalThis ? globalThis : e || self).Popper = {}));
})(this, function (e) {
    function t(e) {
        return { width: (e = e.getBoundingClientRect()).width, height: e.height, top: e.top, right: e.right, bottom: e.bottom, left: e.left, x: e.left, y: e.top };
    }
    function n(e) {
        return null == e ? window : '[object Window]' !== e.toString() ? ((e = e.ownerDocument) && e.defaultView) || window : e;
    }
    function o(e) {
        return { scrollLeft: (e = n(e)).pageXOffset, scrollTop: e.pageYOffset };
    }
    function r(e) {
        return e instanceof n(e).Element || e instanceof Element;
    }
    function i(e) {
        return e instanceof n(e).HTMLElement || e instanceof HTMLElement;
    }
    function a(e) {
        return 'undefined' != typeof ShadowRoot && (e instanceof n(e).ShadowRoot || e instanceof ShadowRoot);
    }
    function s(e) {
        return e ? (e.nodeName || '').toLowerCase() : null;
    }
    function f(e) {
        return ((r(e) ? e.ownerDocument : e.document) || window.document).documentElement;
    }
    function p(e) {
        return t(f(e)).left + o(e).scrollLeft;
    }
    function c(e) {
        return n(e).getComputedStyle(e);
    }
    function l(e) {
        return (e = c(e)), /auto|scroll|overlay|hidden/.test(e.overflow + e.overflowY + e.overflowX);
    }
    function u(e, r, a) {
        void 0 === a && (a = !1);
        var c = f(r);
        e = t(e);
        var u = i(r),
            d = { scrollLeft: 0, scrollTop: 0 },
            m = { x: 0, y: 0 };
        return (
            (u || (!u && !a)) &&
                (('body' !== s(r) || l(c)) && (d = r !== n(r) && i(r) ? { scrollLeft: r.scrollLeft, scrollTop: r.scrollTop } : o(r)),
                i(r) ? (((m = t(r)).x += r.clientLeft), (m.y += r.clientTop)) : c && (m.x = p(c))),
            { x: e.left + d.scrollLeft - m.x, y: e.top + d.scrollTop - m.y, width: e.width, height: e.height }
        );
    }
    function d(e) {
        var n = t(e),
            o = e.offsetWidth,
            r = e.offsetHeight;
        return 1 >= Math.abs(n.width - o) && (o = n.width), 1 >= Math.abs(n.height - r) && (r = n.height), { x: e.offsetLeft, y: e.offsetTop, width: o, height: r };
    }
    function m(e) {
        return 'html' === s(e) ? e : e.assignedSlot || e.parentNode || (a(e) ? e.host : null) || f(e);
    }
    function h(e) {
        return 0 <= ['html', 'body', '#document'].indexOf(s(e)) ? e.ownerDocument.body : i(e) && l(e) ? e : h(m(e));
    }
    function v(e, t) {
        var o;
        void 0 === t && (t = []);
        var r = h(e);
        return (
            (e = r === (null == (o = e.ownerDocument) ? void 0 : o.body)),
            (o = n(r)),
            (r = e ? [o].concat(o.visualViewport || [], l(r) ? r : []) : r),
            (t = t.concat(r)),
            e ? t : t.concat(v(m(r)))
        );
    }
    function g(e) {
        return i(e) && 'fixed' !== c(e).position ? e.offsetParent : null;
    }
    function y(e) {
        for (var t = n(e), o = g(e); o && 0 <= ['table', 'td', 'th'].indexOf(s(o)) && 'static' === c(o).position; ) o = g(o);
        if (o && ('html' === s(o) || ('body' === s(o) && 'static' === c(o).position))) return t;
        if (!o)
            e: {
                for (o = -1 !== navigator.userAgent.toLowerCase().indexOf('firefox'), e = m(e); i(e) && 0 > ['html', 'body'].indexOf(s(e)); ) {
                    var r = c(e);
                    if (
                        'none' !== r.transform ||
                        'none' !== r.perspective ||
                        'paint' === r.contain ||
                        -1 !== ['transform', 'perspective'].indexOf(r.willChange) ||
                        (o && 'filter' === r.willChange) ||
                        (o && r.filter && 'none' !== r.filter)
                    ) {
                        o = e;
                        break e;
                    }
                    e = e.parentNode;
                }
                o = null;
            }
        return o || t;
    }
    function b(e) {
        function t(e) {
            o.add(e.name),
                [].concat(e.requires || [], e.requiresIfExists || []).forEach(function (e) {
                    o.has(e) || ((e = n.get(e)) && t(e));
                }),
                r.push(e);
        }
        var n = new Map(),
            o = new Set(),
            r = [];
        return (
            e.forEach(function (e) {
                n.set(e.name, e);
            }),
            e.forEach(function (e) {
                o.has(e.name) || t(e);
            }),
            r
        );
    }
    function w(e) {
        var t;
        return function () {
            return (
                t ||
                    (t = new Promise(function (n) {
                        Promise.resolve().then(function () {
                            (t = void 0), n(e());
                        });
                    })),
                t
            );
        };
    }
    function x(e) {
        return e.split('-')[0];
    }
    function O(e, t) {
        var n = t.getRootNode && t.getRootNode();
        if (e.contains(t)) return !0;
        if (n && a(n))
            do {
                if (t && e.isSameNode(t)) return !0;
                t = t.parentNode || t.host;
            } while (t);
        return !1;
    }
    function j(e) {
        return Object.assign({}, e, { left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height });
    }
    function E(e, r) {
        if ('viewport' === r) {
            r = n(e);
            var a = f(e);
            r = r.visualViewport;
            var s = a.clientWidth;
            a = a.clientHeight;
            var l = 0,
                u = 0;
            r && ((s = r.width), (a = r.height), /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || ((l = r.offsetLeft), (u = r.offsetTop))),
                (e = j((e = { width: s, height: a, x: l + p(e), y: u })));
        } else i(r) ? (((e = t(r)).top += r.clientTop), (e.left += r.clientLeft), (e.bottom = e.top + r.clientHeight), (e.right = e.left + r.clientWidth), (e.width = r.clientWidth), (e.height = r.clientHeight), (e.x = e.left), (e.y = e.top)) : ((u = f(e)), (e = f(u)), (s = o(u)), (r = null == (a = u.ownerDocument) ? void 0 : a.body), (a = _(e.scrollWidth, e.clientWidth, r ? r.scrollWidth : 0, r ? r.clientWidth : 0)), (l = _(e.scrollHeight, e.clientHeight, r ? r.scrollHeight : 0, r ? r.clientHeight : 0)), (u = -s.scrollLeft + p(u)), (s = -s.scrollTop), 'rtl' === c(r || e).direction && (u += _(e.clientWidth, r ? r.clientWidth : 0) - a), (e = j({ width: a, height: l, x: u, y: s })));
        return e;
    }
    function D(e, t, n) {
        return (
            (t =
                'clippingParents' === t
                    ? (function (e) {
                          var t = v(m(e)),
                              n = 0 <= ['absolute', 'fixed'].indexOf(c(e).position) && i(e) ? y(e) : e;
                          return r(n)
                              ? t.filter(function (e) {
                                    return r(e) && O(e, n) && 'body' !== s(e);
                                })
                              : [];
                      })(e)
                    : [].concat(t)),
            ((n = (n = [].concat(t, [n])).reduce(function (t, n) {
                return (n = E(e, n)), (t.top = _(n.top, t.top)), (t.right = U(n.right, t.right)), (t.bottom = U(n.bottom, t.bottom)), (t.left = _(n.left, t.left)), t;
            }, E(e, n[0]))).width = n.right - n.left),
            (n.height = n.bottom - n.top),
            (n.x = n.left),
            (n.y = n.top),
            n
        );
    }
    function L(e) {
        return 0 <= ['top', 'bottom'].indexOf(e) ? 'x' : 'y';
    }
    function P(e) {
        var t = e.reference,
            n = e.element,
            o = (e = e.placement) ? x(e) : null;
        e = e ? e.split('-')[1] : null;
        var r = t.x + t.width / 2 - n.width / 2,
            i = t.y + t.height / 2 - n.height / 2;
        switch (o) {
            case 'top':
                r = { x: r, y: t.y - n.height };
                break;
            case 'bottom':
                r = { x: r, y: t.y + t.height };
                break;
            case 'right':
                r = { x: t.x + t.width, y: i };
                break;
            case 'left':
                r = { x: t.x - n.width, y: i };
                break;
            default:
                r = { x: t.x, y: t.y };
        }
        if (null != (o = o ? L(o) : null))
            switch (((i = 'y' === o ? 'height' : 'width'), e)) {
                case 'start':
                    r[o] -= t[i] / 2 - n[i] / 2;
                    break;
                case 'end':
                    r[o] += t[i] / 2 - n[i] / 2;
            }
        return r;
    }
    function M(e) {
        return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, e);
    }
    function k(e, t) {
        return t.reduce(function (t, n) {
            return (t[n] = e), t;
        }, {});
    }
    function W(e, n) {
        void 0 === n && (n = {});
        var o = n;
        n = void 0 === (n = o.placement) ? e.placement : n;
        var i = o.boundary,
            a = void 0 === i ? 'clippingParents' : i,
            s = void 0 === (i = o.rootBoundary) ? 'viewport' : i;
        i = void 0 === (i = o.elementContext) ? 'popper' : i;
        var p = o.altBoundary,
            c = void 0 !== p && p;
        o = M('number' != typeof (o = void 0 === (o = o.padding) ? 0 : o) ? o : k(o, C));
        var l = e.elements.reference;
        (p = e.rects.popper),
            (a = D(r((c = e.elements[c ? ('popper' === i ? 'reference' : 'popper') : i])) ? c : c.contextElement || f(e.elements.popper), a, s)),
            (c = P({ reference: (s = t(l)), element: p, strategy: 'absolute', placement: n })),
            (p = j(Object.assign({}, p, c))),
            (s = 'popper' === i ? p : s);
        var u = { top: a.top - s.top + o.top, bottom: s.bottom - a.bottom + o.bottom, left: a.left - s.left + o.left, right: s.right - a.right + o.right };
        if (((e = e.modifiersData.offset), 'popper' === i && e)) {
            var d = e[n];
            Object.keys(u).forEach(function (e) {
                var t = 0 <= ['right', 'bottom'].indexOf(e) ? 1 : -1,
                    n = 0 <= ['top', 'bottom'].indexOf(e) ? 'y' : 'x';
                u[e] += d[n] * t;
            });
        }
        return u;
    }
    function A() {
        for (var e = arguments.length, t = Array(e), n = 0; n < e; n++) t[n] = arguments[n];
        return !t.some(function (e) {
            return !(e && 'function' == typeof e.getBoundingClientRect);
        });
    }
    function B(e) {
        void 0 === e && (e = {});
        var t = e.defaultModifiers,
            n = void 0 === t ? [] : t,
            o = void 0 === (e = e.defaultOptions) ? F : e;
        return function (e, t, i) {
            function a() {
                f.forEach(function (e) {
                    return e();
                }),
                    (f = []);
            }
            void 0 === i && (i = o);
            var s = {
                    placement: 'bottom',
                    orderedModifiers: [],
                    options: Object.assign({}, F, o),
                    modifiersData: {},
                    elements: { reference: e, popper: t },
                    attributes: {},
                    styles: {},
                },
                f = [],
                p = !1,
                c = {
                    state: s,
                    setOptions: function (i) {
                        return (
                            a(),
                            (s.options = Object.assign({}, o, s.options, i)),
                            (s.scrollParents = { reference: r(e) ? v(e) : e.contextElement ? v(e.contextElement) : [], popper: v(t) }),
                            (i = (function (e) {
                                var t = b(e);
                                return I.reduce(function (e, n) {
                                    return e.concat(
                                        t.filter(function (e) {
                                            return e.phase === n;
                                        })
                                    );
                                }, []);
                            })(
                                (function (e) {
                                    var t = e.reduce(function (e, t) {
                                        var n = e[t.name];
                                        return (
                                            (e[t.name] = n
                                                ? Object.assign({}, n, t, { options: Object.assign({}, n.options, t.options), data: Object.assign({}, n.data, t.data) })
                                                : t),
                                            e
                                        );
                                    }, {});
                                    return Object.keys(t).map(function (e) {
                                        return t[e];
                                    });
                                })([].concat(n, s.options.modifiers))
                            )),
                            (s.orderedModifiers = i.filter(function (e) {
                                return e.enabled;
                            })),
                            s.orderedModifiers.forEach(function (e) {
                                var t = e.name,
                                    n = e.options;
                                (n = void 0 === n ? {} : n),
                                    'function' == typeof (e = e.effect) && ((t = e({ state: s, name: t, instance: c, options: n })), f.push(t || function () {}));
                            }),
                            c.update()
                        );
                    },
                    forceUpdate: function () {
                        if (!p) {
                            var e = s.elements,
                                t = e.reference;
                            if (A(t, (e = e.popper)))
                                for (
                                    s.rects = { reference: u(t, y(e), 'fixed' === s.options.strategy), popper: d(e) },
                                        s.reset = !1,
                                        s.placement = s.options.placement,
                                        s.orderedModifiers.forEach(function (e) {
                                            return (s.modifiersData[e.name] = Object.assign({}, e.data));
                                        }),
                                        t = 0;
                                    t < s.orderedModifiers.length;
                                    t++
                                )
                                    if (!0 === s.reset) (s.reset = !1), (t = -1);
                                    else {
                                        var n = s.orderedModifiers[t];
                                        e = n.fn;
                                        var o = n.options;
                                        (o = void 0 === o ? {} : o), (n = n.name), 'function' == typeof e && (s = e({ state: s, options: o, name: n, instance: c }) || s);
                                    }
                        }
                    },
                    update: w(function () {
                        return new Promise(function (e) {
                            c.forceUpdate(), e(s);
                        });
                    }),
                    destroy: function () {
                        a(), (p = !0);
                    },
                };
            return A(e, t)
                ? (c.setOptions(i).then(function (e) {
                      !p && i.onFirstUpdate && i.onFirstUpdate(e);
                  }),
                  c)
                : c;
        };
    }
    function T(e) {
        var t,
            o = e.popper,
            r = e.popperRect,
            i = e.placement,
            a = e.offsets,
            s = e.position,
            p = e.gpuAcceleration,
            l = e.adaptive;
        if (!0 === (e = e.roundOffsets)) {
            e = a.y;
            var u = window.devicePixelRatio || 1;
            e = { x: z(z(a.x * u) / u) || 0, y: z(z(e * u) / u) || 0 };
        } else e = 'function' == typeof e ? e(a) : a;
        (e = void 0 === (e = (u = e).x) ? 0 : e), (u = void 0 === (u = u.y) ? 0 : u);
        var d = a.hasOwnProperty('x');
        a = a.hasOwnProperty('y');
        var m,
            h = 'left',
            v = 'top',
            g = window;
        if (l) {
            var b = y(o),
                w = 'clientHeight',
                x = 'clientWidth';
            b === n(o) && 'static' !== c((b = f(o))).position && ((w = 'scrollHeight'), (x = 'scrollWidth')),
                'top' === i && ((v = 'bottom'), (u -= b[w] - r.height), (u *= p ? 1 : -1)),
                'left' === i && ((h = 'right'), (e -= b[x] - r.width), (e *= p ? 1 : -1));
        }
        return (
            (o = Object.assign({ position: s }, l && J)),
            p
                ? Object.assign(
                      {},
                      o,
                      (((m = {})[v] = a ? '0' : ''),
                      (m[h] = d ? '0' : ''),
                      (m.transform = 2 > (g.devicePixelRatio || 1) ? 'translate(' + e + 'px, ' + u + 'px)' : 'translate3d(' + e + 'px, ' + u + 'px, 0)'),
                      m)
                  )
                : Object.assign({}, o, (((t = {})[v] = a ? u + 'px' : ''), (t[h] = d ? e + 'px' : ''), (t.transform = ''), t))
        );
    }
    function H(e) {
        return e.replace(/left|right|bottom|top/g, function (e) {
            return $[e];
        });
    }
    function R(e) {
        return e.replace(/start|end/g, function (e) {
            return ee[e];
        });
    }
    function S(e, t, n) {
        return (
            void 0 === n && (n = { x: 0, y: 0 }), { top: e.top - t.height - n.y, right: e.right - t.width + n.x, bottom: e.bottom - t.height + n.y, left: e.left - t.width - n.x }
        );
    }
    function q(e) {
        return ['top', 'right', 'bottom', 'left'].some(function (t) {
            return 0 <= e[t];
        });
    }
    var C = ['top', 'bottom', 'right', 'left'],
        N = C.reduce(function (e, t) {
            return e.concat([t + '-start', t + '-end']);
        }, []),
        V = [].concat(C, ['auto']).reduce(function (e, t) {
            return e.concat([t, t + '-start', t + '-end']);
        }, []),
        I = 'beforeRead read afterRead beforeMain main afterMain beforeWrite write afterWrite'.split(' '),
        _ = Math.max,
        U = Math.min,
        z = Math.round,
        F = { placement: 'bottom', modifiers: [], strategy: 'absolute' },
        X = { passive: !0 },
        Y = {
            name: 'eventListeners',
            enabled: !0,
            phase: 'write',
            fn: function () {},
            effect: function (e) {
                var t = e.state,
                    o = e.instance,
                    r = (e = e.options).scroll,
                    i = void 0 === r || r,
                    a = void 0 === (e = e.resize) || e,
                    s = n(t.elements.popper),
                    f = [].concat(t.scrollParents.reference, t.scrollParents.popper);
                return (
                    i &&
                        f.forEach(function (e) {
                            e.addEventListener('scroll', o.update, X);
                        }),
                    a && s.addEventListener('resize', o.update, X),
                    function () {
                        i &&
                            f.forEach(function (e) {
                                e.removeEventListener('scroll', o.update, X);
                            }),
                            a && s.removeEventListener('resize', o.update, X);
                    }
                );
            },
            data: {},
        },
        G = {
            name: 'popperOffsets',
            enabled: !0,
            phase: 'read',
            fn: function (e) {
                var t = e.state;
                t.modifiersData[e.name] = P({ reference: t.rects.reference, element: t.rects.popper, strategy: 'absolute', placement: t.placement });
            },
            data: {},
        },
        J = { top: 'auto', right: 'auto', bottom: 'auto', left: 'auto' },
        K = {
            name: 'computeStyles',
            enabled: !0,
            phase: 'beforeWrite',
            fn: function (e) {
                var t = e.state,
                    n = e.options;
                e = void 0 === (e = n.gpuAcceleration) || e;
                var o = n.adaptive;
                (o = void 0 === o || o),
                    (n = void 0 === (n = n.roundOffsets) || n),
                    (e = { placement: x(t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: e }),
                    null != t.modifiersData.popperOffsets &&
                        (t.styles.popper = Object.assign(
                            {},
                            t.styles.popper,
                            T(Object.assign({}, e, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: o, roundOffsets: n }))
                        )),
                    null != t.modifiersData.arrow &&
                        (t.styles.arrow = Object.assign(
                            {},
                            t.styles.arrow,
                            T(Object.assign({}, e, { offsets: t.modifiersData.arrow, position: 'absolute', adaptive: !1, roundOffsets: n }))
                        )),
                    (t.attributes.popper = Object.assign({}, t.attributes.popper, { 'data-popper-placement': t.placement }));
            },
            data: {},
        },
        Q = {
            name: 'applyStyles',
            enabled: !0,
            phase: 'write',
            fn: function (e) {
                var t = e.state;
                Object.keys(t.elements).forEach(function (e) {
                    var n = t.styles[e] || {},
                        o = t.attributes[e] || {},
                        r = t.elements[e];
                    i(r) &&
                        s(r) &&
                        (Object.assign(r.style, n),
                        Object.keys(o).forEach(function (e) {
                            var t = o[e];
                            !1 === t ? r.removeAttribute(e) : r.setAttribute(e, !0 === t ? '' : t);
                        }));
                });
            },
            effect: function (e) {
                var t = e.state,
                    n = { popper: { position: t.options.strategy, left: '0', top: '0', margin: '0' }, arrow: { position: 'absolute' }, reference: {} };
                return (
                    Object.assign(t.elements.popper.style, n.popper),
                    (t.styles = n),
                    t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow),
                    function () {
                        Object.keys(t.elements).forEach(function (e) {
                            var o = t.elements[e],
                                r = t.attributes[e] || {};
                            (e = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : n[e]).reduce(function (e, t) {
                                return (e[t] = ''), e;
                            }, {})),
                                i(o) &&
                                    s(o) &&
                                    (Object.assign(o.style, e),
                                    Object.keys(r).forEach(function (e) {
                                        o.removeAttribute(e);
                                    }));
                        });
                    }
                );
            },
            requires: ['computeStyles'],
        },
        Z = {
            name: 'offset',
            enabled: !0,
            phase: 'main',
            requires: ['popperOffsets'],
            fn: function (e) {
                var t = e.state,
                    n = e.name,
                    o = void 0 === (e = e.options.offset) ? [0, 0] : e,
                    r = (e = V.reduce(function (e, n) {
                        var r = t.rects,
                            i = x(n),
                            a = 0 <= ['left', 'top'].indexOf(i) ? -1 : 1,
                            s = 'function' == typeof o ? o(Object.assign({}, r, { placement: n })) : o;
                        return (r = (r = s[0]) || 0), (s = ((s = s[1]) || 0) * a), (i = 0 <= ['left', 'right'].indexOf(i) ? { x: s, y: r } : { x: r, y: s }), (e[n] = i), e;
                    }, {}))[t.placement],
                    i = r.x;
                (r = r.y), null != t.modifiersData.popperOffsets && ((t.modifiersData.popperOffsets.x += i), (t.modifiersData.popperOffsets.y += r)), (t.modifiersData[n] = e);
            },
        },
        $ = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' },
        ee = { start: 'end', end: 'start' },
        te = {
            name: 'flip',
            enabled: !0,
            phase: 'main',
            fn: function (e) {
                var t = e.state,
                    n = e.options;
                if (((e = e.name), !t.modifiersData[e]._skip)) {
                    var o = n.mainAxis;
                    o = void 0 === o || o;
                    var r = n.altAxis;
                    r = void 0 === r || r;
                    var i = n.fallbackPlacements,
                        a = n.padding,
                        s = n.boundary,
                        f = n.rootBoundary,
                        p = n.altBoundary,
                        c = n.flipVariations,
                        l = void 0 === c || c,
                        u = n.allowedAutoPlacements;
                    (c = x((n = t.options.placement))),
                        (i =
                            i ||
                            (c !== n && l
                                ? (function (e) {
                                      if ('auto' === x(e)) return [];
                                      var t = H(e);
                                      return [R(e), t, R(t)];
                                  })(n)
                                : [H(n)]));
                    var d = [n].concat(i).reduce(function (e, n) {
                        return e.concat(
                            'auto' === x(n)
                                ? (function (e, t) {
                                      void 0 === t && (t = {});
                                      var n = t.boundary,
                                          o = t.rootBoundary,
                                          r = t.padding,
                                          i = t.flipVariations,
                                          a = t.allowedAutoPlacements,
                                          s = void 0 === a ? V : a,
                                          f = t.placement.split('-')[1];
                                      0 ===
                                          (i = (t = f
                                              ? i
                                                  ? N
                                                  : N.filter(function (e) {
                                                        return e.split('-')[1] === f;
                                                    })
                                              : C).filter(function (e) {
                                              return 0 <= s.indexOf(e);
                                          })).length && (i = t);
                                      var p = i.reduce(function (t, i) {
                                          return (t[i] = W(e, { placement: i, boundary: n, rootBoundary: o, padding: r })[x(i)]), t;
                                      }, {});
                                      return Object.keys(p).sort(function (e, t) {
                                          return p[e] - p[t];
                                      });
                                  })(t, { placement: n, boundary: s, rootBoundary: f, padding: a, flipVariations: l, allowedAutoPlacements: u })
                                : n
                        );
                    }, []);
                    (n = t.rects.reference), (i = t.rects.popper);
                    var m = new Map();
                    c = !0;
                    for (var h = d[0], v = 0; v < d.length; v++) {
                        var g = d[v],
                            y = x(g),
                            b = 'start' === g.split('-')[1],
                            w = 0 <= ['top', 'bottom'].indexOf(y),
                            O = w ? 'width' : 'height',
                            j = W(t, { placement: g, boundary: s, rootBoundary: f, altBoundary: p, padding: a });
                        if (
                            ((b = w ? (b ? 'right' : 'left') : b ? 'bottom' : 'top'),
                            n[O] > i[O] && (b = H(b)),
                            (O = H(b)),
                            (w = []),
                            o && w.push(0 >= j[y]),
                            r && w.push(0 >= j[b], 0 >= j[O]),
                            w.every(function (e) {
                                return e;
                            }))
                        ) {
                            (h = g), (c = !1);
                            break;
                        }
                        m.set(g, w);
                    }
                    if (c)
                        for (
                            o = function (e) {
                                var t = d.find(function (t) {
                                    if ((t = m.get(t)))
                                        return t.slice(0, e).every(function (e) {
                                            return e;
                                        });
                                });
                                if (t) return (h = t), 'break';
                            },
                                r = l ? 3 : 1;
                            0 < r && 'break' !== o(r);
                            r--
                        );
                    t.placement !== h && ((t.modifiersData[e]._skip = !0), (t.placement = h), (t.reset = !0));
                }
            },
            requiresIfExists: ['offset'],
            data: { _skip: !1 },
        },
        ne = {
            name: 'preventOverflow',
            enabled: !0,
            phase: 'main',
            fn: function (e) {
                var t = e.state,
                    n = e.options;
                e = e.name;
                var o = n.mainAxis,
                    r = void 0 === o || o,
                    i = void 0 !== (o = n.altAxis) && o;
                o = void 0 === (o = n.tether) || o;
                var a = n.tetherOffset,
                    s = void 0 === a ? 0 : a,
                    f = W(t, { boundary: n.boundary, rootBoundary: n.rootBoundary, padding: n.padding, altBoundary: n.altBoundary });
                n = x(t.placement);
                var p = t.placement.split('-')[1],
                    c = !p,
                    l = L(n);
                (n = 'x' === l ? 'y' : 'x'), (a = t.modifiersData.popperOffsets);
                var u = t.rects.reference,
                    m = t.rects.popper,
                    h = 'function' == typeof s ? s(Object.assign({}, t.rects, { placement: t.placement })) : s;
                if (((s = { x: 0, y: 0 }), a)) {
                    if (r || i) {
                        var v = 'y' === l ? 'top' : 'left',
                            g = 'y' === l ? 'bottom' : 'right',
                            b = 'y' === l ? 'height' : 'width',
                            w = a[l],
                            O = a[l] + f[v],
                            j = a[l] - f[g],
                            E = o ? -m[b] / 2 : 0,
                            D = 'start' === p ? u[b] : m[b];
                        (p = 'start' === p ? -m[b] : -u[b]), (m = t.elements.arrow), (m = o && m ? d(m) : { width: 0, height: 0 });
                        var P = t.modifiersData['arrow#persistent'] ? t.modifiersData['arrow#persistent'].padding : { top: 0, right: 0, bottom: 0, left: 0 };
                        (v = P[v]),
                            (g = P[g]),
                            (m = _(0, U(u[b], m[b]))),
                            (D = c ? u[b] / 2 - E - m - v - h : D - m - v - h),
                            (u = c ? -u[b] / 2 + E + m + g + h : p + m + g + h),
                            (c = t.elements.arrow && y(t.elements.arrow)),
                            (h = t.modifiersData.offset ? t.modifiersData.offset[t.placement][l] : 0),
                            (c = a[l] + D - h - (c ? ('y' === l ? c.clientTop || 0 : c.clientLeft || 0) : 0)),
                            (u = a[l] + u - h),
                            r && ((r = o ? U(O, c) : O), (j = o ? _(j, u) : j), (r = _(r, U(w, j))), (a[l] = r), (s[l] = r - w)),
                            i &&
                                ((r = (i = a[n]) + f['x' === l ? 'top' : 'left']),
                                (f = i - f['x' === l ? 'bottom' : 'right']),
                                (r = o ? U(r, c) : r),
                                (o = o ? _(f, u) : f),
                                (o = _(r, U(i, o))),
                                (a[n] = o),
                                (s[n] = o - i));
                    }
                    t.modifiersData[e] = s;
                }
            },
            requiresIfExists: ['offset'],
        },
        oe = {
            name: 'arrow',
            enabled: !0,
            phase: 'main',
            fn: function (e) {
                var t,
                    n = e.state,
                    o = e.name,
                    r = e.options,
                    i = n.elements.arrow,
                    a = n.modifiersData.popperOffsets,
                    s = x(n.placement);
                if (((e = L(s)), (s = 0 <= ['left', 'right'].indexOf(s) ? 'height' : 'width'), i && a)) {
                    r = M('number' != typeof (r = 'function' == typeof (r = r.padding) ? r(Object.assign({}, n.rects, { placement: n.placement })) : r) ? r : k(r, C));
                    var f = d(i),
                        p = 'y' === e ? 'top' : 'left',
                        c = 'y' === e ? 'bottom' : 'right',
                        l = n.rects.reference[s] + n.rects.reference[e] - a[e] - n.rects.popper[s];
                    (a = a[e] - n.rects.reference[e]),
                        (a = (i = (i = y(i)) ? ('y' === e ? i.clientHeight || 0 : i.clientWidth || 0) : 0) / 2 - f[s] / 2 + (l / 2 - a / 2)),
                        (s = _(r[p], U(a, i - f[s] - r[c]))),
                        (n.modifiersData[o] = (((t = {})[e] = s), (t.centerOffset = s - a), t));
                }
            },
            effect: function (e) {
                var t = e.state;
                if (null != (e = void 0 === (e = e.options.element) ? '[data-popper-arrow]' : e)) {
                    if ('string' == typeof e && !(e = t.elements.popper.querySelector(e))) return;
                    O(t.elements.popper, e) && (t.elements.arrow = e);
                }
            },
            requires: ['popperOffsets'],
            requiresIfExists: ['preventOverflow'],
        },
        re = {
            name: 'hide',
            enabled: !0,
            phase: 'main',
            requiresIfExists: ['preventOverflow'],
            fn: function (e) {
                var t = e.state;
                e = e.name;
                var n = t.rects.reference,
                    o = t.rects.popper,
                    r = t.modifiersData.preventOverflow,
                    i = W(t, { elementContext: 'reference' }),
                    a = W(t, { altBoundary: !0 });
                (n = S(i, n)),
                    (o = S(a, o, r)),
                    (r = q(n)),
                    (a = q(o)),
                    (t.modifiersData[e] = { referenceClippingOffsets: n, popperEscapeOffsets: o, isReferenceHidden: r, hasPopperEscaped: a }),
                    (t.attributes.popper = Object.assign({}, t.attributes.popper, { 'data-popper-reference-hidden': r, 'data-popper-escaped': a }));
            },
        },
        ie = B({ defaultModifiers: [Y, G, K, Q] }),
        ae = [Y, G, K, Q, Z, te, ne, oe, re],
        se = B({ defaultModifiers: ae });
    (e.applyStyles = Q),
        (e.arrow = oe),
        (e.computeStyles = K),
        (e.createPopper = se),
        (e.createPopperLite = ie),
        (e.defaultModifiers = ae),
        (e.detectOverflow = W),
        (e.eventListeners = Y),
        (e.flip = te),
        (e.hide = re),
        (e.offset = Z),
        (e.popperGenerator = B),
        (e.popperOffsets = G),
        (e.preventOverflow = ne),
        Object.defineProperty(e, '__esModule', { value: !0 });
});
//# sourceMappingURL=popper.min.js.map

// Polyfill object.assign
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
if (typeof Object.assign !== 'function') {
    // Must be writable: true, enumerable: false, configurable: true
    Object.defineProperty(Object, 'assign', {
        value: function assign(target, varArgs) {
            // .length of function is 2
            'use strict';
            if (target === null || target === undefined) {
                throw new TypeError('Cannot convert undefined or null to object');
            }

            var to = Object(target);

            for (var index = 1; index < arguments.length; index++) {
                var nextSource = arguments[index];

                if (nextSource !== null && nextSource !== undefined) {
                    for (var nextKey in nextSource) {
                        // Avoid bugs when hasOwnProperty is shadowed
                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
            }
            return to;
        },
        writable: true,
        configurable: true,
    });
}

/**!
 * tippy.js v6.3.1
 * (c) 2017-2021 atomiks
 * MIT License
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined'
        ? (module.exports = factory(require('@popperjs/core')))
        : typeof define === 'function' && define.amd
        ? define(['@popperjs/core'], factory)
        : ((global = global || self), (global.tippy = factory(global.Popper)));
})(this, function (core) {
    'use strict';

    var css =
        '.tippy-box[data-animation=fade][data-state=hidden]{opacity:0}[data-tippy-root]{max-width:calc(100vw - 10px)}.tippy-box{position:relative;background-color:#333;color:#fff;border-radius:4px;font-size:14px;line-height:1.4;outline:0;transition-property:transform,visibility,opacity}.tippy-box[data-placement^=top]>.tippy-arrow{bottom:0}.tippy-box[data-placement^=top]>.tippy-arrow:before{bottom:-7px;left:0;border-width:8px 8px 0;border-top-color:initial;transform-origin:center top}.tippy-box[data-placement^=bottom]>.tippy-arrow{top:0}.tippy-box[data-placement^=bottom]>.tippy-arrow:before{top:-7px;left:0;border-width:0 8px 8px;border-bottom-color:initial;transform-origin:center bottom}.tippy-box[data-placement^=left]>.tippy-arrow{right:0}.tippy-box[data-placement^=left]>.tippy-arrow:before{border-width:8px 0 8px 8px;border-left-color:initial;right:-7px;transform-origin:center left}.tippy-box[data-placement^=right]>.tippy-arrow{left:0}.tippy-box[data-placement^=right]>.tippy-arrow:before{left:-7px;border-width:8px 8px 8px 0;border-right-color:initial;transform-origin:center right}.tippy-box[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-arrow{width:16px;height:16px;color:#333}.tippy-arrow:before{content:"";position:absolute;border-color:transparent;border-style:solid}.tippy-content{position:relative;padding:5px 9px;z-index:1}';

    function injectCSS(css) {
        var style = document.createElement('style');
        style.textContent = css;
        style.setAttribute('data-tippy-stylesheet', '');
        var head = document.head;
        var firstStyleOrLinkTag = document.querySelector('head>style,head>link');

        if (firstStyleOrLinkTag) {
            head.insertBefore(style, firstStyleOrLinkTag);
        } else {
            head.appendChild(style);
        }
    }

    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
    var ua = isBrowser ? navigator.userAgent : '';
    var isIE = /MSIE |Trident\//.test(ua);

    var ROUND_ARROW =
        '<svg width="16" height="6" xmlns="http://www.w3.org/2000/svg"><path d="M0 6s1.796-.013 4.67-3.615C5.851.9 6.93.006 8 0c1.07-.006 2.148.887 3.343 2.385C14.233 6.005 16 6 16 6H0z"></svg>';
    var BOX_CLASS = 'tippy-box';
    var CONTENT_CLASS = 'tippy-content';
    var BACKDROP_CLASS = 'tippy-backdrop';
    var ARROW_CLASS = 'tippy-arrow';
    var SVG_ARROW_CLASS = 'tippy-svg-arrow';
    var TOUCH_OPTIONS = {
        passive: true,
        capture: true,
    };

    function hasOwnProperty(obj, key) {
        return {}.hasOwnProperty.call(obj, key);
    }
    function getValueAtIndexOrReturn(value, index, defaultValue) {
        if (Array.isArray(value)) {
            var v = value[index];
            return v == null ? (Array.isArray(defaultValue) ? defaultValue[index] : defaultValue) : v;
        }

        return value;
    }
    function isType(value, type) {
        var str = {}.toString.call(value);
        return str.indexOf('[object') === 0 && str.indexOf(type + ']') > -1;
    }
    function invokeWithArgsOrReturn(value, args) {
        return typeof value === 'function' ? value.apply(void 0, args) : value;
    }
    function debounce(fn, ms) {
        // Avoid wrapping in `setTimeout` if ms is 0 anyway
        if (ms === 0) {
            return fn;
        }

        var timeout;
        return function (arg) {
            clearTimeout(timeout);
            timeout = setTimeout(function () {
                fn(arg);
            }, ms);
        };
    }
    function removeProperties(obj, keys) {
        var clone = Object.assign({}, obj);
        keys.forEach(function (key) {
            delete clone[key];
        });
        return clone;
    }
    function splitBySpaces(value) {
        return value.split(/\s+/).filter(Boolean);
    }
    function normalizeToArray(value) {
        return [].concat(value);
    }
    function pushIfUnique(arr, value) {
        if (arr.indexOf(value) === -1) {
            arr.push(value);
        }
    }
    function unique(arr) {
        return arr.filter(function (item, index) {
            return arr.indexOf(item) === index;
        });
    }
    function getBasePlacement(placement) {
        return placement.split('-')[0];
    }
    function arrayFrom(value) {
        return [].slice.call(value);
    }
    function removeUndefinedProps(obj) {
        return Object.keys(obj).reduce(function (acc, key) {
            if (obj[key] !== undefined) {
                acc[key] = obj[key];
            }

            return acc;
        }, {});
    }

    function div() {
        return document.createElement('div');
    }
    function isElement(value) {
        return ['Element', 'Fragment'].some(function (type) {
            return isType(value, type);
        });
    }
    function isNodeList(value) {
        return isType(value, 'NodeList');
    }
    function isMouseEvent(value) {
        return isType(value, 'MouseEvent');
    }
    function isReferenceElement(value) {
        return !!(value && value._tippy && value._tippy.reference === value);
    }
    function getArrayOfElements(value) {
        if (isElement(value)) {
            return [value];
        }

        if (isNodeList(value)) {
            return arrayFrom(value);
        }

        if (Array.isArray(value)) {
            return value;
        }

        return arrayFrom(document.querySelectorAll(value));
    }
    function setTransitionDuration(els, value) {
        els.forEach(function (el) {
            if (el) {
                el.style.transitionDuration = value + 'ms';
            }
        });
    }
    function setVisibilityState(els, state) {
        els.forEach(function (el) {
            if (el) {
                el.setAttribute('data-state', state);
            }
        });
    }
    function getOwnerDocument(elementOrElements) {
        var _element$ownerDocumen;

        var _normalizeToArray = normalizeToArray(elementOrElements),
            element = _normalizeToArray[0]; // Elements created via a <template> have an ownerDocument with no reference to the body

        return (element == null ? void 0 : (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body) ? element.ownerDocument : document;
    }
    function isCursorOutsideInteractiveBorder(popperTreeData, event) {
        var clientX = event.clientX,
            clientY = event.clientY;
        return popperTreeData.every(function (_ref) {
            var popperRect = _ref.popperRect,
                popperState = _ref.popperState,
                props = _ref.props;
            var interactiveBorder = props.interactiveBorder;
            var basePlacement = getBasePlacement(popperState.placement);
            var offsetData = popperState.modifiersData.offset;

            if (!offsetData) {
                return true;
            }

            var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;
            var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;
            var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;
            var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;
            var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
            var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
            var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
            var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
            return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
        });
    }
    function updateTransitionEndListener(box, action, listener) {
        var method = action + 'EventListener'; // some browsers apparently support `transition` (unprefixed) but only fire
        // `webkitTransitionEnd`...

        ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
            box[method](event, listener);
        });
    }

    var currentInput = {
        isTouch: false,
    };
    var lastMouseMoveTime = 0;
    /**
     * When a `touchstart` event is fired, it's assumed the user is using touch
     * input. We'll bind a `mousemove` event listener to listen for mouse input in
     * the future. This way, the `isTouch` property is fully dynamic and will handle
     * hybrid devices that use a mix of touch + mouse input.
     */

    function onDocumentTouchStart() {
        if (currentInput.isTouch) {
            return;
        }

        currentInput.isTouch = true;

        if (window.performance) {
            document.addEventListener('mousemove', onDocumentMouseMove);
        }
    }
    /**
     * When two `mousemove` event are fired consecutively within 20ms, it's assumed
     * the user is using mouse input again. `mousemove` can fire on touch devices as
     * well, but very rarely that quickly.
     */

    function onDocumentMouseMove() {
        var now = performance.now();

        if (now - lastMouseMoveTime < 20) {
            currentInput.isTouch = false;
            document.removeEventListener('mousemove', onDocumentMouseMove);
        }

        lastMouseMoveTime = now;
    }
    /**
     * When an element is in focus and has a tippy, leaving the tab/window and
     * returning causes it to show again. For mouse users this is unexpected, but
     * for keyboard use it makes sense.
     * TODO: find a better technique to solve this problem
     */

    function onWindowBlur() {
        var activeElement = document.activeElement;

        if (isReferenceElement(activeElement)) {
            var instance = activeElement._tippy;

            if (activeElement.blur && !instance.state.isVisible) {
                activeElement.blur();
            }
        }
    }
    function bindGlobalEventListeners() {
        document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);
        window.addEventListener('blur', onWindowBlur);
    }

    function createMemoryLeakWarning(method) {
        var txt = method === 'destroy' ? 'n already-' : ' ';
        return [method + '() was called on a' + txt + 'destroyed instance. This is a no-op but', 'indicates a potential memory leak.'].join(' ');
    }
    function clean(value) {
        var spacesAndTabs = /[ \t]{2,}/g;
        var lineStartWithSpaces = /^[ \t]*/gm;
        return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();
    }

    function getDevMessage(message) {
        return clean('\n  %ctippy.js\n\n  %c' + clean(message) + '\n\n  %c\uD83D\uDC77\u200D This is a development-only message. It will be removed in production.\n  ');
    }

    function getFormattedMessage(message) {
        return [
            getDevMessage(message), // title
            'color: #00C584; font-size: 1.3em; font-weight: bold;', // message
            'line-height: 1.5', // footer
            'color: #a6a095;',
        ];
    } // Assume warnings and errors never have the same message

    var visitedMessages;

    {
        resetVisitedMessages();
    }

    function resetVisitedMessages() {
        visitedMessages = new Set();
    }
    function warnWhen(condition, message) {
        if (condition && !visitedMessages.has(message)) {
            var _console;

            visitedMessages.add(message);

            (_console = console).warn.apply(_console, getFormattedMessage(message));
        }
    }
    function errorWhen(condition, message) {
        if (condition && !visitedMessages.has(message)) {
            var _console2;

            visitedMessages.add(message);

            (_console2 = console).error.apply(_console2, getFormattedMessage(message));
        }
    }
    function validateTargets(targets) {
        var didPassFalsyValue = !targets;
        var didPassPlainObject = Object.prototype.toString.call(targets) === '[object Object]' && !targets.addEventListener;
        errorWhen(
            didPassFalsyValue,
            ['tippy() was passed', '`' + String(targets) + '`', 'as its targets (first) argument. Valid types are: String, Element,', 'Element[], or NodeList.'].join(' ')
        );
        errorWhen(
            didPassPlainObject,
            ['tippy() was passed a plain object which is not supported as an argument', 'for virtual positioning. Use props.getReferenceClientRect instead.'].join(' ')
        );
    }

    var pluginProps = {
        animateFill: false,
        followCursor: false,
        inlinePositioning: false,
        sticky: false,
    };
    var renderProps = {
        allowHTML: false,
        animation: 'fade',
        arrow: true,
        content: '',
        inertia: false,
        maxWidth: 350,
        role: 'tooltip',
        theme: '',
        zIndex: 9999,
    };
    var defaultProps = Object.assign(
        {
            appendTo: function appendTo() {
                return document.body;
            },
            aria: {
                content: 'auto',
                expanded: 'auto',
            },
            delay: 0,
            duration: [300, 250],
            getReferenceClientRect: null,
            hideOnClick: true,
            ignoreAttributes: false,
            interactive: false,
            interactiveBorder: 2,
            interactiveDebounce: 0,
            moveTransition: '',
            offset: [0, 10],
            onAfterUpdate: function onAfterUpdate() {},
            onBeforeUpdate: function onBeforeUpdate() {},
            onCreate: function onCreate() {},
            onDestroy: function onDestroy() {},
            onHidden: function onHidden() {},
            onHide: function onHide() {},
            onMount: function onMount() {},
            onShow: function onShow() {},
            onShown: function onShown() {},
            onTrigger: function onTrigger() {},
            onUntrigger: function onUntrigger() {},
            onClickOutside: function onClickOutside() {},
            placement: 'top',
            plugins: [],
            popperOptions: {},
            render: null,
            showOnCreate: false,
            touch: true,
            trigger: 'mouseenter focus',
            triggerTarget: null,
        },
        pluginProps,
        {},
        renderProps
    );
    var defaultKeys = Object.keys(defaultProps);
    var setDefaultProps = function setDefaultProps(partialProps) {
        /* istanbul ignore else */
        {
            validateProps(partialProps, []);
        }

        var keys = Object.keys(partialProps);
        keys.forEach(function (key) {
            defaultProps[key] = partialProps[key];
        });
    };
    function getExtendedPassedProps(passedProps) {
        var plugins = passedProps.plugins || [];
        var pluginProps = plugins.reduce(function (acc, plugin) {
            var name = plugin.name,
                defaultValue = plugin.defaultValue;

            if (name) {
                acc[name] = passedProps[name] !== undefined ? passedProps[name] : defaultValue;
            }

            return acc;
        }, {});
        return Object.assign({}, passedProps, {}, pluginProps);
    }
    function getDataAttributeProps(reference, plugins) {
        var propKeys = plugins
            ? Object.keys(
                  getExtendedPassedProps(
                      Object.assign({}, defaultProps, {
                          plugins: plugins,
                      })
                  )
              )
            : defaultKeys;
        var props = propKeys.reduce(function (acc, key) {
            var valueAsString = (reference.getAttribute('data-tippy-' + key) || '').trim();

            if (!valueAsString) {
                return acc;
            }

            if (key === 'content') {
                acc[key] = valueAsString;
            } else {
                try {
                    acc[key] = JSON.parse(valueAsString);
                } catch (e) {
                    acc[key] = valueAsString;
                }
            }

            return acc;
        }, {});
        return props;
    }
    function evaluateProps(reference, props) {
        var out = Object.assign(
            {},
            props,
            {
                content: invokeWithArgsOrReturn(props.content, [reference]),
            },
            props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins)
        );
        out.aria = Object.assign({}, defaultProps.aria, {}, out.aria);
        out.aria = {
            expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,
            content: out.aria.content === 'auto' ? (props.interactive ? null : 'describedby') : out.aria.content,
        };
        return out;
    }
    function validateProps(partialProps, plugins) {
        if (partialProps === void 0) {
            partialProps = {};
        }

        if (plugins === void 0) {
            plugins = [];
        }

        var keys = Object.keys(partialProps);
        keys.forEach(function (prop) {
            var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
            var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop); // Check if the prop exists in `plugins`

            if (didPassUnknownProp) {
                didPassUnknownProp =
                    plugins.filter(function (plugin) {
                        return plugin.name === prop;
                    }).length === 0;
            }

            warnWhen(
                didPassUnknownProp,
                [
                    '`' + prop + '`',
                    "is not a valid prop. You may have spelled it incorrectly, or if it's",
                    'a plugin, forgot to pass it in an array as props.plugins.',
                    '\n\n',
                    'All props: https://atomiks.github.io/tippyjs/v6/all-props/\n',
                    'Plugins: https://atomiks.github.io/tippyjs/v6/plugins/',
                ].join(' ')
            );
        });
    }

    var innerHTML = function innerHTML() {
        return 'innerHTML';
    };

    function dangerouslySetInnerHTML(element, html) {
        element[innerHTML()] = html;
    }

    function createArrowElement(value) {
        var arrow = div();

        if (value === true) {
            arrow.className = ARROW_CLASS;
        } else {
            arrow.className = SVG_ARROW_CLASS;

            if (isElement(value)) {
                arrow.appendChild(value);
            } else {
                dangerouslySetInnerHTML(arrow, value);
            }
        }

        return arrow;
    }

    function setContent(content, props) {
        if (isElement(props.content)) {
            dangerouslySetInnerHTML(content, '');
            content.appendChild(props.content);
        } else if (typeof props.content !== 'function') {
            if (props.allowHTML) {
                dangerouslySetInnerHTML(content, props.content);
            } else {
                content.textContent = props.content;
            }
        }
    }
    function getChildren(popper) {
        var box = popper.firstElementChild;
        var boxChildren = arrayFrom(box.children);
        return {
            box: box,
            content: boxChildren.find(function (node) {
                return node.classList.contains(CONTENT_CLASS);
            }),
            arrow: boxChildren.find(function (node) {
                return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
            }),
            backdrop: boxChildren.find(function (node) {
                return node.classList.contains(BACKDROP_CLASS);
            }),
        };
    }
    function render(instance) {
        var popper = div();
        var box = div();
        box.className = BOX_CLASS;
        box.setAttribute('data-state', 'hidden');
        box.setAttribute('tabindex', '-1');
        var content = div();
        content.className = CONTENT_CLASS;
        content.setAttribute('data-state', 'hidden');
        setContent(content, instance.props);
        popper.appendChild(box);
        box.appendChild(content);
        onUpdate(instance.props, instance.props);

        function onUpdate(prevProps, nextProps) {
            var _getChildren = getChildren(popper),
                box = _getChildren.box,
                content = _getChildren.content,
                arrow = _getChildren.arrow;

            if (nextProps.theme) {
                box.setAttribute('data-theme', nextProps.theme);
            } else {
                box.removeAttribute('data-theme');
            }

            if (typeof nextProps.animation === 'string') {
                box.setAttribute('data-animation', nextProps.animation);
            } else {
                box.removeAttribute('data-animation');
            }

            if (nextProps.inertia) {
                box.setAttribute('data-inertia', '');
            } else {
                box.removeAttribute('data-inertia');
            }

            box.style.maxWidth = typeof nextProps.maxWidth === 'number' ? nextProps.maxWidth + 'px' : nextProps.maxWidth;

            if (nextProps.role) {
                box.setAttribute('role', nextProps.role);
            } else {
                box.removeAttribute('role');
            }

            if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
                setContent(content, instance.props);
            }

            if (nextProps.arrow) {
                if (!arrow) {
                    box.appendChild(createArrowElement(nextProps.arrow));
                } else if (prevProps.arrow !== nextProps.arrow) {
                    box.removeChild(arrow);
                    box.appendChild(createArrowElement(nextProps.arrow));
                }
            } else if (arrow) {
                box.removeChild(arrow);
            }
        }

        return {
            popper: popper,
            onUpdate: onUpdate,
        };
    } // Runtime check to identify if the render function is the default one; this
    // way we can apply default CSS transitions logic and it can be tree-shaken away

    render.$$tippy = true;

    var idCounter = 1;
    var mouseMoveListeners = []; // Used by `hideAll()`

    var mountedInstances = [];
    function createTippy(reference, passedProps) {
        var props = evaluateProps(reference, Object.assign({}, defaultProps, {}, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================
        //  Private members
        // ===========================================================================

        var showTimeout;
        var hideTimeout;
        var scheduleHideAnimationFrame;
        var isVisibleFromClick = false;
        var didHideDueToDocumentMouseDown = false;
        var didTouchMove = false;
        var ignoreOnFirstUpdate = false;
        var lastTriggerEvent;
        var currentTransitionEndListener;
        var onFirstUpdate;
        var listeners = [];
        var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
        var currentTarget; // ===========================================================================
        //  Public members
        // ===========================================================================

        var id = idCounter++;
        var popperInstance = null;
        var plugins = unique(props.plugins);
        var state = {
            // Is the instance currently enabled?
            isEnabled: true,
            // Is the tippy currently showing and not transitioning out?
            isVisible: false,
            // Has the instance been destroyed?
            isDestroyed: false,
            // Is the tippy currently mounted to the DOM?
            isMounted: false,
            // Has the tippy finished transitioning in?
            isShown: false,
        };
        var instance = {
            // properties
            id: id,
            reference: reference,
            popper: div(),
            popperInstance: popperInstance,
            props: props,
            state: state,
            plugins: plugins,
            // methods
            clearDelayTimeouts: clearDelayTimeouts,
            setProps: setProps,
            setContent: setContent,
            show: show,
            hide: hide,
            hideWithInteractivity: hideWithInteractivity,
            enable: enable,
            disable: disable,
            unmount: unmount,
            destroy: destroy,
        }; // TODO: Investigate why this early return causes a TDZ error in the tests 
        // it doesn't seem to happen in the browser

        /* istanbul ignore if */

        if (!props.render) {
            {
                errorWhen(true, 'render() function has not been supplied.');
            }

            return instance;
        } // ===========================================================================
        // Initial mutations
        // ===========================================================================

        var _props$render = props.render(instance),
            popper = _props$render.popper,
            onUpdate = _props$render.onUpdate;

        popper.setAttribute('data-tippy-root', '');
        popper.id = 'tippy-' + instance.id;
        instance.popper = popper;
        reference._tippy = instance;
        popper._tippy = instance;
        var pluginsHooks = plugins.map(function (plugin) {
            return plugin.fn(instance);
        });
        var hasAriaExpanded = reference.hasAttribute('aria-expanded');
        addListeners();
        handleAriaExpandedAttribute();
        handleStyles();
        invokeHook('onCreate', [instance]);

        if (props.showOnCreate) {
            scheduleShow();
        } // Prevent a tippy with a delay from hiding if the cursor left then returned
        // before it started hiding

        popper.addEventListener('mouseenter', function () {
            if (instance.props.interactive && instance.state.isVisible) {
                instance.clearDelayTimeouts();
            }
        });
        popper.addEventListener('mouseleave', function (event) {
            if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {
                getDocument().addEventListener('mousemove', debouncedOnMouseMove);
                debouncedOnMouseMove(event);
            }
        });
        return instance; // ===========================================================================
        //  Private methods
        // ===========================================================================

        function getNormalizedTouchSettings() {
            var touch = instance.props.touch;
            return Array.isArray(touch) ? touch : [touch, 0];
        }

        function getIsCustomTouchBehavior() {
            return getNormalizedTouchSettings()[0] === 'hold';
        }

        function getIsDefaultRenderFn() {
            var _instance$props$rende;

            // @ts-ignore
            return !!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy);
        }

        function getCurrentTarget() {
            return currentTarget || reference;
        }

        function getDocument() {
            var parent = getCurrentTarget().parentNode;
            return parent ? getOwnerDocument(parent) : document;
        }

        function getDefaultTemplateChildren() {
            return getChildren(popper);
        }

        function getDelay(isShow) {
            // For touch or keyboard input, force `0` delay for UX reasons
            // Also if the instance is mounted but not visible (transitioning out),
            // ignore delay
            if ((instance.state.isMounted && !instance.state.isVisible) || currentInput.isTouch || (lastTriggerEvent && lastTriggerEvent.type === 'focus')) {
                return 0;
            }

            return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
        }

        function handleStyles() {
            popper.style.pointerEvents = instance.props.interactive && instance.state.isVisible ? '' : 'none';
            popper.style.zIndex = '' + instance.props.zIndex;
        }

        function invokeHook(hook, args, shouldInvokePropsHook) {
            if (shouldInvokePropsHook === void 0) {
                shouldInvokePropsHook = true;
            }

            pluginsHooks.forEach(function (pluginHooks) {
                if (pluginHooks[hook]) {
                    pluginHooks[hook].apply(void 0, args);
                }
            });

            if (shouldInvokePropsHook) {
                var _instance$props;

                (_instance$props = instance.props)[hook].apply(_instance$props, args);
            }
        }

        function handleAriaContentAttribute() {
            var aria = instance.props.aria;

            if (!aria.content) {
                return;
            }

            var attr = 'aria-' + aria.content;
            var id = popper.id;
            var nodes = normalizeToArray(instance.props.triggerTarget || reference);
            nodes.forEach(function (node) {
                var currentValue = node.getAttribute(attr);

                if (instance.state.isVisible) {
                    node.setAttribute(attr, currentValue ? currentValue + ' ' + id : id);
                } else {
                    var nextValue = currentValue && currentValue.replace(id, '').trim();

                    if (nextValue) {
                        node.setAttribute(attr, nextValue);
                    } else {
                        node.removeAttribute(attr);
                    }
                }
            });
        }

        function handleAriaExpandedAttribute() {
            if (hasAriaExpanded || !instance.props.aria.expanded) {
                return;
            }

            var nodes = normalizeToArray(instance.props.triggerTarget || reference);
            nodes.forEach(function (node) {
                if (instance.props.interactive) {
                    node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');
                } else {
                    node.removeAttribute('aria-expanded');
                }
            });
        }

        function cleanupInteractiveMouseListeners() {
            getDocument().removeEventListener('mousemove', debouncedOnMouseMove);
            mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
                return listener !== debouncedOnMouseMove;
            });
        }

        function onDocumentPress(event) {
            // Moved finger to scroll instead of an intentional tap outside
            if (currentInput.isTouch) {
                if (didTouchMove || event.type === 'mousedown') {
                    return;
                }
            } // Clicked on interactive popper

            if (instance.props.interactive && popper.contains(event.target)) {
                return;
            } // Clicked on the event listeners target

            if (getCurrentTarget().contains(event.target)) {
                if (currentInput.isTouch) {
                    return;
                }

                if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {
                    return;
                }
            } else {
                invokeHook('onClickOutside', [instance, event]);
            }

            if (instance.props.hideOnClick === true) {
                instance.clearDelayTimeouts();
                instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
                // currentTarget. This lets a tippy with `focus` trigger know that it
                // should not show

                didHideDueToDocumentMouseDown = true;
                setTimeout(function () {
                    didHideDueToDocumentMouseDown = false;
                }); // The listener gets added in `scheduleShow()`, but this may be hiding it
                // before it shows, and hide()'s early bail-out behavior can prevent it
                // from being cleaned up

                if (!instance.state.isMounted) {
                    removeDocumentPress();
                }
            }
        }

        function onTouchMove() {
            didTouchMove = true;
        }

        function onTouchStart() {
            didTouchMove = false;
        }

        function addDocumentPress() {
            var doc = getDocument();
            doc.addEventListener('mousedown', onDocumentPress, true);
            doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
            doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
            doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
        }

        function removeDocumentPress() {
            var doc = getDocument();
            doc.removeEventListener('mousedown', onDocumentPress, true);
            doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
            doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
            doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
        }

        function onTransitionedOut(duration, callback) {
            onTransitionEnd(duration, function () {
                if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
                    callback();
                }
            });
        }

        function onTransitionedIn(duration, callback) {
            onTransitionEnd(duration, callback);
        }

        function onTransitionEnd(duration, callback) {
            var box = getDefaultTemplateChildren().box;

            function listener(event) {
                if (event.target === box) {
                    updateTransitionEndListener(box, 'remove', listener);
                    callback();
                }
            } // Make callback synchronous if duration is 0
            // `transitionend` won't fire otherwise

            if (duration === 0) {
                return callback();
            }

            updateTransitionEndListener(box, 'remove', currentTransitionEndListener);
            updateTransitionEndListener(box, 'add', listener);
            currentTransitionEndListener = listener;
        }

        function on(eventType, handler, options) {
            if (options === void 0) {
                options = false;
            }

            var nodes = normalizeToArray(instance.props.triggerTarget || reference);
            nodes.forEach(function (node) {
                node.addEventListener(eventType, handler, options);
                listeners.push({
                    node: node,
                    eventType: eventType,
                    handler: handler,
                    options: options,
                });
            });
        }

        function addListeners() {
            if (getIsCustomTouchBehavior()) {
                on('touchstart', onTrigger, {
                    passive: true,
                });
                on('touchend', onMouseLeave, {
                    passive: true,
                });
            }

            splitBySpaces(instance.props.trigger).forEach(function (eventType) {
                if (eventType === 'manual') {
                    return;
                }

                on(eventType, onTrigger);

                switch (eventType) {
                    case 'mouseenter':
                        on('mouseleave', onMouseLeave);
                        break;

                    case 'focus':
                        on(isIE ? 'focusout' : 'blur', onBlurOrFocusOut);
                        break;

                    case 'focusin':
                        on('focusout', onBlurOrFocusOut);
                        break;
                }
            });
        }

        function removeListeners() {
            listeners.forEach(function (_ref) {
                var node = _ref.node,
                    eventType = _ref.eventType,
                    handler = _ref.handler,
                    options = _ref.options;
                node.removeEventListener(eventType, handler, options);
            });
            listeners = [];
        }

        function onTrigger(event) {
            var _lastTriggerEvent;

            var shouldScheduleClickHide = false;

            if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
                return;
            }

            var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';
            lastTriggerEvent = event;
            currentTarget = event.currentTarget;
            handleAriaExpandedAttribute();

            if (!instance.state.isVisible && isMouseEvent(event)) {
                // If scrolling, `mouseenter` events can be fired if the cursor lands
                // over a new target, but `mousemove` events don't get fired. This
                // causes interactive tooltips to get stuck open until the cursor is
                // moved
                mouseMoveListeners.forEach(function (listener) {
                    return listener(event);
                });
            } // Toggle show/hide when clicking click-triggered tooltips

            if (
                event.type === 'click' &&
                (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) &&
                instance.props.hideOnClick !== false &&
                instance.state.isVisible
            ) {
                shouldScheduleClickHide = true;
            } else {
                scheduleShow(event);
            }

            if (event.type === 'click') {
                isVisibleFromClick = !shouldScheduleClickHide;
            }

            if (shouldScheduleClickHide && !wasFocused) {
                scheduleHide(event);
            }
        }

        function onMouseMove(event) {
            var target = event.target;
            var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);

            if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {
                return;
            }

            var popperTreeData = getNestedPopperTree()
                .concat(popper)
                .map(function (popper) {
                    var _instance$popperInsta;

                    var instance = popper._tippy;
                    var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;

                    if (state) {
                        return {
                            popperRect: popper.getBoundingClientRect(),
                            popperState: state,
                            props: props,
                        };
                    }

                    return null;
                })
                .filter(Boolean);

            if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
                cleanupInteractiveMouseListeners();
                scheduleHide(event);
            }
        }

        function onMouseLeave(event) {
            var shouldBail = isEventListenerStopped(event) || (instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick);

            if (shouldBail) {
                return;
            }

            if (instance.props.interactive) {
                instance.hideWithInteractivity(event);
                return;
            }

            scheduleHide(event);
        }

        function onBlurOrFocusOut(event) {
            if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {
                return;
            } // If focus was moved to within the popper

            if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
                return;
            }

            scheduleHide(event);
        }

        function isEventListenerStopped(event) {
            return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;
        }

        function createPopperInstance() {
            destroyPopperInstance();
            var _instance$props2 = instance.props,
                popperOptions = _instance$props2.popperOptions,
                placement = _instance$props2.placement,
                offset = _instance$props2.offset,
                getReferenceClientRect = _instance$props2.getReferenceClientRect,
                moveTransition = _instance$props2.moveTransition;
            var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
            var computedReference = getReferenceClientRect
                ? {
                      getBoundingClientRect: getReferenceClientRect,
                      contextElement: getReferenceClientRect.contextElement || getCurrentTarget(),
                  }
                : reference;
            var tippyModifier = {
                name: '$$tippy',
                enabled: true,
                phase: 'beforeWrite',
                requires: ['computeStyles'],
                fn: function fn(_ref2) {
                    var state = _ref2.state;

                    if (getIsDefaultRenderFn()) {
                        var _getDefaultTemplateCh = getDefaultTemplateChildren(),
                            box = _getDefaultTemplateCh.box;

                        ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {
                            if (attr === 'placement') {
                                box.setAttribute('data-placement', state.placement);
                            } else {
                                if (state.attributes.popper['data-popper-' + attr]) {
                                    box.setAttribute('data-' + attr, '');
                                } else {
                                    box.removeAttribute('data-' + attr);
                                }
                            }
                        });
                        state.attributes.popper = {};
                    }
                },
            };
            var modifiers = [
                {
                    name: 'offset',
                    options: {
                        offset: offset,
                    },
                },
                {
                    name: 'preventOverflow',
                    options: {
                        padding: {
                            top: 2,
                            bottom: 2,
                            left: 5,
                            right: 5,
                        },
                    },
                },
                {
                    name: 'flip',
                    options: {
                        padding: 5,
                    },
                },
                {
                    name: 'computeStyles',
                    options: {
                        adaptive: !moveTransition,
                    },
                },
                tippyModifier,
            ];

            if (getIsDefaultRenderFn() && arrow) {
                modifiers.push({
                    name: 'arrow',
                    options: {
                        element: arrow,
                        padding: 3,
                    },
                });
            }

            modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
            instance.popperInstance = core.createPopper(
                computedReference,
                popper,
                Object.assign({}, popperOptions, {
                    placement: placement,
                    onFirstUpdate: onFirstUpdate,
                    modifiers: modifiers,
                })
            );
        }

        function destroyPopperInstance() {
            if (instance.popperInstance) {
                instance.popperInstance.destroy();
                instance.popperInstance = null;
            }
        }

        function mount() {
            var appendTo = instance.props.appendTo;
            var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
            // it's directly after the reference element so the elements inside the
            // tippy can be tabbed to
            // If there are clipping issues, the user can specify a different appendTo
            // and ensure focus management is handled correctly manually

            var node = getCurrentTarget();

            if ((instance.props.interactive && appendTo === defaultProps.appendTo) || appendTo === 'parent') {
                parentNode = node.parentNode;
            } else {
                parentNode = invokeWithArgsOrReturn(appendTo, [node]);
            } // The popper element needs to exist on the DOM before its position can be
            // updated as Popper needs to read its dimensions

            if (!parentNode.contains(popper)) {
                parentNode.appendChild(popper);
            }

            createPopperInstance();
            /* istanbul ignore else */

            {
                // Accessibility check
                warnWhen(
                    instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper,
                    [
                        'Interactive tippy element may not be accessible via keyboard',
                        'navigation because it is not directly after the reference element',
                        'in the DOM source order.',
                        '\n\n',
                        'Using a wrapper <div> or <span> tag around the reference element',
                        'solves this by creating a new parentNode context.',
                        '\n\n',
                        'Specifying `appendTo: document.body` silences this warning, but it',
                        'assumes you are using a focus management solution to handle',
                        'keyboard navigation.',
                        '\n\n',
                        'See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity',
                    ].join(' ')
                );
            }
        }

        function getNestedPopperTree() {
            return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));
        }

        function scheduleShow(event) {
            instance.clearDelayTimeouts();

            if (event) {
                invokeHook('onTrigger', [instance, event]);
            }

            addDocumentPress();
            var delay = getDelay(true);

            var _getNormalizedTouchSe = getNormalizedTouchSettings(),
                touchValue = _getNormalizedTouchSe[0],
                touchDelay = _getNormalizedTouchSe[1];

            if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {
                delay = touchDelay;
            }

            if (delay) {
                showTimeout = setTimeout(function () {
                    instance.show();
                }, delay);
            } else {
                instance.show();
            }
        }

        function scheduleHide(event) {
            instance.clearDelayTimeouts();
            invokeHook('onUntrigger', [instance, event]);

            if (!instance.state.isVisible) {
                removeDocumentPress();
                return;
            } // For interactive tippies, scheduleHide is added to a document.body handler
            // from onMouseLeave so must intercept scheduled hides from mousemove/leave
            // events when trigger contains mouseenter and click, and the tip is
            // currently shown as a result of a click.

            if (
                instance.props.trigger.indexOf('mouseenter') >= 0 &&
                instance.props.trigger.indexOf('click') >= 0 &&
                ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 &&
                isVisibleFromClick
            ) {
                return;
            }

            var delay = getDelay(false);

            if (delay) {
                hideTimeout = setTimeout(function () {
                    if (instance.state.isVisible) {
                        instance.hide();
                    }
                }, delay);
            } else {
                // Fixes a `transitionend` problem when it fires 1 frame too
                // late sometimes, we don't want hide() to be called.
                scheduleHideAnimationFrame = requestAnimationFrame(function () {
                    instance.hide();
                });
            }
        } // ===========================================================================
        //  Public methods
        // ===========================================================================

        function enable() {
            instance.state.isEnabled = true;
        }

        function disable() {
            // Disabling the instance should also hide it
            // https://github.com/atomiks/tippy.js-react/issues/106
            instance.hide();
            instance.state.isEnabled = false;
        }

        function clearDelayTimeouts() {
            clearTimeout(showTimeout);
            clearTimeout(hideTimeout);
            cancelAnimationFrame(scheduleHideAnimationFrame);
        }

        function setProps(partialProps) {
            /* istanbul ignore else */
            {
                warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('setProps'));
            }

            if (instance.state.isDestroyed) {
                return;
            }

            invokeHook('onBeforeUpdate', [instance, partialProps]);
            removeListeners();
            var prevProps = instance.props;
            var nextProps = evaluateProps(
                reference,
                Object.assign({}, instance.props, {}, partialProps, {
                    ignoreAttributes: true,
                })
            );
            instance.props = nextProps;
            addListeners();

            if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
                cleanupInteractiveMouseListeners();
                debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
            } // Ensure stale aria-expanded attributes are removed

            if (prevProps.triggerTarget && !nextProps.triggerTarget) {
                normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
                    node.removeAttribute('aria-expanded');
                });
            } else if (nextProps.triggerTarget) {
                reference.removeAttribute('aria-expanded');
            }

            handleAriaExpandedAttribute();
            handleStyles();

            if (onUpdate) {
                onUpdate(prevProps, nextProps);
            }

            if (instance.popperInstance) {
                createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,
                // and the nested ones get re-rendered first.
                // https://github.com/atomiks/tippyjs-react/issues/177
                // TODO: find a cleaner / more efficient solution(!)

                getNestedPopperTree().forEach(function (nestedPopper) {
                    // React (and other UI libs likely) requires a rAF wrapper as it flushes
                    // its work in one
                    requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
                });
            }

            invokeHook('onAfterUpdate', [instance, partialProps]);
        }

        function setContent(content) {
            instance.setProps({
                content: content,
            });
        }

        function show() {
            /* istanbul ignore else */
            {
                warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('show'));
            } // Early bail-out

            var isAlreadyVisible = instance.state.isVisible;
            var isDestroyed = instance.state.isDestroyed;
            var isDisabled = !instance.state.isEnabled;
            var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
            var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);

            if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
                return;
            } // Normalize `disabled` behavior across browsers.
            // Firefox allows events on disabled elements, but Chrome doesn't.
            // Using a wrapper element (i.e. <span>) is recommended.

            if (getCurrentTarget().hasAttribute('disabled')) {
                return;
            }

            invokeHook('onShow', [instance], false);

            if (instance.props.onShow(instance) === false) {
                return;
            }

            instance.state.isVisible = true;

            if (getIsDefaultRenderFn()) {
                popper.style.visibility = 'visible';
            }

            handleStyles();
            addDocumentPress();

            if (!instance.state.isMounted) {
                popper.style.transition = 'none';
            } // If flipping to the opposite side after hiding at least once, the
            // animation will use the wrong placement without resetting the duration

            if (getIsDefaultRenderFn()) {
                var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
                    box = _getDefaultTemplateCh2.box,
                    content = _getDefaultTemplateCh2.content;

                setTransitionDuration([box, content], 0);
            }

            onFirstUpdate = function onFirstUpdate() {
                var _instance$popperInsta2;

                if (!instance.state.isVisible || ignoreOnFirstUpdate) {
                    return;
                }

                ignoreOnFirstUpdate = true; // reflow

                void popper.offsetHeight;
                popper.style.transition = instance.props.moveTransition;

                if (getIsDefaultRenderFn() && instance.props.animation) {
                    var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
                        _box = _getDefaultTemplateCh3.box,
                        _content = _getDefaultTemplateCh3.content;

                    setTransitionDuration([_box, _content], duration);
                    setVisibilityState([_box, _content], 'visible');
                }

                handleAriaContentAttribute();
                handleAriaExpandedAttribute();
                pushIfUnique(mountedInstances, instance); // certain modifiers (e.g. `maxSize`) require a second update after the
                // popper has been positioned for the first time

                (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
                instance.state.isMounted = true;
                invokeHook('onMount', [instance]);

                if (instance.props.animation && getIsDefaultRenderFn()) {
                    onTransitionedIn(duration, function () {
                        instance.state.isShown = true;
                        invokeHook('onShown', [instance]);
                    });
                }
            };

            mount();
        }

        function hide() {
            /* istanbul ignore else */
            {
                warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hide'));
            } // Early bail-out

            var isAlreadyHidden = !instance.state.isVisible;
            var isDestroyed = instance.state.isDestroyed;
            var isDisabled = !instance.state.isEnabled;
            var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);

            if (isAlreadyHidden || isDestroyed || isDisabled) {
                return;
            }

            invokeHook('onHide', [instance], false);

            if (instance.props.onHide(instance) === false) {
                return;
            }

            instance.state.isVisible = false;
            instance.state.isShown = false;
            ignoreOnFirstUpdate = false;
            isVisibleFromClick = false;

            if (getIsDefaultRenderFn()) {
                popper.style.visibility = 'hidden';
            }

            cleanupInteractiveMouseListeners();
            removeDocumentPress();
            handleStyles();

            if (getIsDefaultRenderFn()) {
                var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
                    box = _getDefaultTemplateCh4.box,
                    content = _getDefaultTemplateCh4.content;

                if (instance.props.animation) {
                    setTransitionDuration([box, content], duration);
                    setVisibilityState([box, content], 'hidden');
                }
            }

            handleAriaContentAttribute();
            handleAriaExpandedAttribute();

            if (instance.props.animation) {
                if (getIsDefaultRenderFn()) {
                    onTransitionedOut(duration, instance.unmount);
                }
            } else {
                instance.unmount();
            }
        }

        function hideWithInteractivity(event) {
            /* istanbul ignore else */
            {
                warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hideWithInteractivity'));
            }

            getDocument().addEventListener('mousemove', debouncedOnMouseMove);
            pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
            debouncedOnMouseMove(event);
        }

        function unmount() {
            /* istanbul ignore else */
            {
                warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('unmount'));
            }

            if (instance.state.isVisible) {
                instance.hide();
            }

            if (!instance.state.isMounted) {
                return;
            }

            destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper
            // tree by default. This seems mainly for interactive tippies, but we should
            // find a workaround if possible

            getNestedPopperTree().forEach(function (nestedPopper) {
                nestedPopper._tippy.unmount();
            });

            if (popper.parentNode) {
                popper.parentNode.removeChild(popper);
            }

            mountedInstances = mountedInstances.filter(function (i) {
                return i !== instance;
            });
            instance.state.isMounted = false;
            invokeHook('onHidden', [instance]);
        }

        function destroy() {
            /* istanbul ignore else */
            {
                warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('destroy'));
            }

            if (instance.state.isDestroyed) {
                return;
            }

            instance.clearDelayTimeouts();
            instance.unmount();
            removeListeners();
            delete reference._tippy;
            instance.state.isDestroyed = true;
            invokeHook('onDestroy', [instance]);
        }
    }

    function tippy(targets, optionalProps) {
        if (optionalProps === void 0) {
            optionalProps = {};
        }

        var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
        /* istanbul ignore else */

        {
            validateTargets(targets);
            validateProps(optionalProps, plugins);
        }

        bindGlobalEventListeners();
        var passedProps = Object.assign({}, optionalProps, {
            plugins: plugins,
        });
        var elements = getArrayOfElements(targets);
        /* istanbul ignore else */

        {
            var isSingleContentElement = isElement(passedProps.content);
            var isMoreThanOneReferenceElement = elements.length > 1;
            warnWhen(
                isSingleContentElement && isMoreThanOneReferenceElement,
                [
                    'tippy() was passed an Element as the `content` prop, but more than',
                    'one tippy instance was created by this invocation. This means the',
                    'content element will only be appended to the last tippy instance.',
                    '\n\n',
                    'Instead, pass the .innerHTML of the element, or use a function that',
                    'returns a cloned version of the element instead.',
                    '\n\n',
                    '1) content: element.innerHTML\n',
                    '2) content: () => element.cloneNode(true)',
                ].join(' ')
            );
        }

        var instances = elements.reduce(function (acc, reference) {
            var instance = reference && createTippy(reference, passedProps);

            if (instance) {
                acc.push(instance);
            }

            return acc;
        }, []);
        return isElement(targets) ? instances[0] : instances;
    }

    tippy.defaultProps = defaultProps;
    tippy.setDefaultProps = setDefaultProps;
    tippy.currentInput = currentInput;
    var hideAll = function hideAll(_temp) {
        var _ref = _temp === void 0 ? {} : _temp,
            excludedReferenceOrInstance = _ref.exclude,
            duration = _ref.duration;

        mountedInstances.forEach(function (instance) {
            var isExcluded = false;

            if (excludedReferenceOrInstance) {
                isExcluded = isReferenceElement(excludedReferenceOrInstance)
                    ? instance.reference === excludedReferenceOrInstance
                    : instance.popper === excludedReferenceOrInstance.popper;
            }

            if (!isExcluded) {
                var originalDuration = instance.props.duration;
                instance.setProps({
                    duration: duration,
                });
                instance.hide();

                if (!instance.state.isDestroyed) {
                    instance.setProps({
                        duration: originalDuration,
                    });
                }
            }
        });
    };

    // every time the popper is destroyed (i.e. a new target), removing the styles
    // and causing transitions to break for singletons when the console is open, but
    // most notably for non-transform styles being used, `gpuAcceleration: false`.

    var applyStylesModifier = Object.assign({}, core.applyStyles, {
        effect: function effect(_ref) {
            var state = _ref.state;
            var initialStyles = {
                popper: {
                    position: state.options.strategy,
                    left: '0',
                    top: '0',
                    margin: '0',
                },
                arrow: {
                    position: 'absolute',
                },
                reference: {},
            };
            Object.assign(state.elements.popper.style, initialStyles.popper);
            state.styles = initialStyles;

            if (state.elements.arrow) {
                Object.assign(state.elements.arrow.style, initialStyles.arrow);
            } // intentionally return no cleanup function
            // return () => { ... }
        },
    });

    var createSingleton = function createSingleton(tippyInstances, optionalProps) {
        var _optionalProps$popper;

        if (optionalProps === void 0) {
            optionalProps = {};
        }

        /* istanbul ignore else */
        {
            errorWhen(
                !Array.isArray(tippyInstances),
                ['The first argument passed to createSingleton() must be an array of', 'tippy instances. The passed value was', String(tippyInstances)].join(' ')
            );
        }

        var individualInstances = tippyInstances;
        var references = [];
        var currentTarget;
        var overrides = optionalProps.overrides;
        var interceptSetPropsCleanups = [];
        var shownOnCreate = false;

        function setReferences() {
            references = individualInstances.map(function (instance) {
                return instance.reference;
            });
        }

        function enableInstances(isEnabled) {
            individualInstances.forEach(function (instance) {
                if (isEnabled) {
                    instance.enable();
                } else {
                    instance.disable();
                }
            });
        }

        function interceptSetProps(singleton) {
            return individualInstances.map(function (instance) {
                var originalSetProps = instance.setProps;

                instance.setProps = function (props) {
                    originalSetProps(props);

                    if (instance.reference === currentTarget) {
                        singleton.setProps(props);
                    }
                };

                return function () {
                    instance.setProps = originalSetProps;
                };
            });
        } // have to pass singleton, as it maybe undefined on first call

        function prepareInstance(singleton, target) {
            var index = references.indexOf(target); // bail-out

            if (target === currentTarget) {
                return;
            }

            currentTarget = target;
            var overrideProps = (overrides || []).concat('content').reduce(function (acc, prop) {
                acc[prop] = individualInstances[index].props[prop];
                return acc;
            }, {});
            singleton.setProps(
                Object.assign({}, overrideProps, {
                    getReferenceClientRect:
                        typeof overrideProps.getReferenceClientRect === 'function'
                            ? overrideProps.getReferenceClientRect
                            : function () {
                                  return target.getBoundingClientRect();
                              },
                })
            );
        }

        enableInstances(false);
        setReferences();
        var plugin = {
            fn: function fn() {
                return {
                    onDestroy: function onDestroy() {
                        enableInstances(true);
                    },
                    onHidden: function onHidden() {
                        currentTarget = null;
                    },
                    onClickOutside: function onClickOutside(instance) {
                        if (instance.props.showOnCreate && !shownOnCreate) {
                            shownOnCreate = true;
                            currentTarget = null;
                        }
                    },
                    onShow: function onShow(instance) {
                        if (instance.props.showOnCreate && !shownOnCreate) {
                            shownOnCreate = true;
                            prepareInstance(instance, references[0]);
                        }
                    },
                    onTrigger: function onTrigger(instance, event) {
                        prepareInstance(instance, event.currentTarget);
                    },
                };
            },
        };
        var singleton = tippy(
            div(),
            Object.assign({}, removeProperties(optionalProps, ['overrides']), {
                plugins: [plugin].concat(optionalProps.plugins || []),
                triggerTarget: references,
                popperOptions: Object.assign({}, optionalProps.popperOptions, {
                    modifiers: [].concat(((_optionalProps$popper = optionalProps.popperOptions) == null ? void 0 : _optionalProps$popper.modifiers) || [], [applyStylesModifier]),
                }),
            })
        );
        var originalShow = singleton.show;

        singleton.show = function (target) {
            originalShow(); // first time, showOnCreate or programmatic call with no params
            // default to showing first instance

            if (!currentTarget && target == null) {
                return prepareInstance(singleton, references[0]);
            } // triggered from event (do nothing as prepareInstance already called by onTrigger)
            // programmatic call with no params when already visible (do nothing again)

            if (currentTarget && target == null) {
                return;
            } // target is index of instance

            if (typeof target === 'number') {
                return references[target] && prepareInstance(singleton, references[target]);
            } // target is a child tippy instance

            if (individualInstances.includes(target)) {
                var ref = target.reference;
                return prepareInstance(singleton, ref);
            } // target is a ReferenceElement

            if (references.includes(target)) {
                return prepareInstance(singleton, target);
            }
        };

        singleton.showNext = function () {
            var first = references[0];

            if (!currentTarget) {
                return singleton.show(0);
            }

            var index = references.indexOf(currentTarget);
            singleton.show(references[index + 1] || first);
        };

        singleton.showPrevious = function () {
            var last = references[references.length - 1];

            if (!currentTarget) {
                return singleton.show(last);
            }

            var index = references.indexOf(currentTarget);
            var target = references[index - 1] || last;
            singleton.show(target);
        };

        var originalSetProps = singleton.setProps;

        singleton.setProps = function (props) {
            overrides = props.overrides || overrides;
            originalSetProps(props);
        };

        singleton.setInstances = function (nextInstances) {
            enableInstances(true);
            interceptSetPropsCleanups.forEach(function (fn) {
                return fn();
            });
            individualInstances = nextInstances;
            enableInstances(false);
            setReferences();
            interceptSetProps(singleton);
            singleton.setProps({
                triggerTarget: references,
            });
        };

        interceptSetPropsCleanups = interceptSetProps(singleton);
        return singleton;
    };

    var BUBBLING_EVENTS_MAP = {
        mouseover: 'mouseenter',
        focusin: 'focus',
        click: 'click',
    };
    /**
     * Creates a delegate instance that controls the creation of tippy instances
     * for child elements (`target` CSS selector).
     */

    function delegate(targets, props) {
        /* istanbul ignore else */
        {
            errorWhen(
                !(props && props.target),
                ['You must specity a `target` prop indicating a CSS selector string matching', 'the target elements that should receive a tippy.'].join(' ')
            );
        }

        var listeners = [];
        var childTippyInstances = [];
        var disabled = false;
        var target = props.target;
        var nativeProps = removeProperties(props, ['target']);
        var parentProps = Object.assign({}, nativeProps, {
            trigger: 'manual',
            touch: false,
        });
        var childProps = Object.assign({}, nativeProps, {
            showOnCreate: true,
        });
        var returnValue = tippy(targets, parentProps);
        var normalizedReturnValue = normalizeToArray(returnValue);

        function onTrigger(event) {
            if (!event.target || disabled) {
                return;
            }

            var targetNode = event.target.closest(target);

            if (!targetNode) {
                return;
            } // Get relevant trigger with fallbacks:
            // 1. Check `data-tippy-trigger` attribute on target node
            // 2. Fallback to `trigger` passed to `delegate()`
            // 3. Fallback to `defaultProps.trigger`

            var trigger = targetNode.getAttribute('data-tippy-trigger') || props.trigger || defaultProps.trigger; // @ts-ignore

            if (targetNode._tippy) {
                return;
            }

            if (event.type === 'touchstart' && typeof childProps.touch === 'boolean') {
                return;
            }

            if (event.type !== 'touchstart' && trigger.indexOf(BUBBLING_EVENTS_MAP[event.type]) < 0) {
                return;
            }

            var instance = tippy(targetNode, childProps);

            if (instance) {
                childTippyInstances = childTippyInstances.concat(instance);
            }
        }

        function on(node, eventType, handler, options) {
            if (options === void 0) {
                options = false;
            }

            node.addEventListener(eventType, handler, options);
            listeners.push({
                node: node,
                eventType: eventType,
                handler: handler,
                options: options,
            });
        }

        function addEventListeners(instance) {
            var reference = instance.reference;
            on(reference, 'touchstart', onTrigger, TOUCH_OPTIONS);
            on(reference, 'mouseover', onTrigger);
            on(reference, 'focusin', onTrigger);
            on(reference, 'click', onTrigger);
        }

        function removeEventListeners() {
            listeners.forEach(function (_ref) {
                var node = _ref.node,
                    eventType = _ref.eventType,
                    handler = _ref.handler,
                    options = _ref.options;
                node.removeEventListener(eventType, handler, options);
            });
            listeners = [];
        }

        function applyMutations(instance) {
            var originalDestroy = instance.destroy;
            var originalEnable = instance.enable;
            var originalDisable = instance.disable;

            instance.destroy = function (shouldDestroyChildInstances) {
                if (shouldDestroyChildInstances === void 0) {
                    shouldDestroyChildInstances = true;
                }

                if (shouldDestroyChildInstances) {
                    childTippyInstances.forEach(function (instance) {
                        instance.destroy();
                    });
                }

                childTippyInstances = [];
                removeEventListeners();
                originalDestroy();
            };

            instance.enable = function () {
                originalEnable();
                childTippyInstances.forEach(function (instance) {
                    return instance.enable();
                });
                disabled = false;
            };

            instance.disable = function () {
                originalDisable();
                childTippyInstances.forEach(function (instance) {
                    return instance.disable();
                });
                disabled = true;
            };

            addEventListeners(instance);
        }

        normalizedReturnValue.forEach(applyMutations);
        return returnValue;
    }

    var animateFill = {
        name: 'animateFill',
        defaultValue: false,
        fn: function fn(instance) {
            var _instance$props$rende;

            // @ts-ignore
            if (!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy)) {
                {
                    errorWhen(instance.props.animateFill, 'The `animateFill` plugin requires the default render function.');
                }

                return {};
            }

            var _getChildren = getChildren(instance.popper),
                box = _getChildren.box,
                content = _getChildren.content;

            var backdrop = instance.props.animateFill ? createBackdropElement() : null;
            return {
                onCreate: function onCreate() {
                    if (backdrop) {
                        box.insertBefore(backdrop, box.firstElementChild);
                        box.setAttribute('data-animatefill', '');
                        box.style.overflow = 'hidden';
                        instance.setProps({
                            arrow: false,
                            animation: 'shift-away',
                        });
                    }
                },
                onMount: function onMount() {
                    if (backdrop) {
                        var transitionDuration = box.style.transitionDuration;
                        var duration = Number(transitionDuration.replace('ms', '')); // The content should fade in after the backdrop has mostly filled the
                        // tooltip element. `clip-path` is the other alternative but is not
                        // well-supported and is buggy on some devices.

                        content.style.transitionDelay = Math.round(duration / 10) + 'ms';
                        backdrop.style.transitionDuration = transitionDuration;
                        setVisibilityState([backdrop], 'visible');
                    }
                },
                onShow: function onShow() {
                    if (backdrop) {
                        backdrop.style.transitionDuration = '0ms';
                    }
                },
                onHide: function onHide() {
                    if (backdrop) {
                        setVisibilityState([backdrop], 'hidden');
                    }
                },
            };
        },
    };

    function createBackdropElement() {
        var backdrop = div();
        backdrop.className = BACKDROP_CLASS;
        setVisibilityState([backdrop], 'hidden');
        return backdrop;
    }

    var mouseCoords = {
        clientX: 0,
        clientY: 0,
    };
    var activeInstances = [];

    function storeMouseCoords(_ref) {
        var clientX = _ref.clientX,
            clientY = _ref.clientY;
        mouseCoords = {
            clientX: clientX,
            clientY: clientY,
        };
    }

    function addMouseCoordsListener(doc) {
        doc.addEventListener('mousemove', storeMouseCoords);
    }

    function removeMouseCoordsListener(doc) {
        doc.removeEventListener('mousemove', storeMouseCoords);
    }

    var followCursor = {
        name: 'followCursor',
        defaultValue: false,
        fn: function fn(instance) {
            var reference = instance.reference;
            var doc = getOwnerDocument(instance.props.triggerTarget || reference);
            var isInternalUpdate = false;
            var wasFocusEvent = false;
            var isUnmounted = true;
            var prevProps = instance.props;

            function getIsInitialBehavior() {
                return instance.props.followCursor === 'initial' && instance.state.isVisible;
            }

            function addListener() {
                doc.addEventListener('mousemove', onMouseMove);
            }

            function removeListener() {
                doc.removeEventListener('mousemove', onMouseMove);
            }

            function unsetGetReferenceClientRect() {
                isInternalUpdate = true;
                instance.setProps({
                    getReferenceClientRect: null,
                });
                isInternalUpdate = false;
            }

            function onMouseMove(event) {
                // If the instance is interactive, avoid updating the position unless it's
                // over the reference element
                var isCursorOverReference = event.target ? reference.contains(event.target) : true;
                var followCursor = instance.props.followCursor;
                var clientX = event.clientX,
                    clientY = event.clientY;
                var rect = reference.getBoundingClientRect();
                var relativeX = clientX - rect.left;
                var relativeY = clientY - rect.top;

                if (isCursorOverReference || !instance.props.interactive) {
                    instance.setProps({
                        getReferenceClientRect: function getReferenceClientRect() {
                            var rect = reference.getBoundingClientRect();
                            var x = clientX;
                            var y = clientY;

                            if (followCursor === 'initial') {
                                x = rect.left + relativeX;
                                y = rect.top + relativeY;
                            }

                            var top = followCursor === 'horizontal' ? rect.top : y;
                            var right = followCursor === 'vertical' ? rect.right : x;
                            var bottom = followCursor === 'horizontal' ? rect.bottom : y;
                            var left = followCursor === 'vertical' ? rect.left : x;
                            return {
                                width: right - left,
                                height: bottom - top,
                                top: top,
                                right: right,
                                bottom: bottom,
                                left: left,
                            };
                        },
                    });
                }
            }

            function create() {
                if (instance.props.followCursor) {
                    activeInstances.push({
                        instance: instance,
                        doc: doc,
                    });
                    addMouseCoordsListener(doc);
                }
            }

            function destroy() {
                activeInstances = activeInstances.filter(function (data) {
                    return data.instance !== instance;
                });

                if (
                    activeInstances.filter(function (data) {
                        return data.doc === doc;
                    }).length === 0
                ) {
                    removeMouseCoordsListener(doc);
                }
            }

            return {
                onCreate: create,
                onDestroy: destroy,
                onBeforeUpdate: function onBeforeUpdate() {
                    prevProps = instance.props;
                },
                onAfterUpdate: function onAfterUpdate(_, _ref2) {
                    var followCursor = _ref2.followCursor;

                    if (isInternalUpdate) {
                        return;
                    }

                    if (followCursor !== undefined && prevProps.followCursor !== followCursor) {
                        destroy();

                        if (followCursor) {
                            create();

                            if (instance.state.isMounted && !wasFocusEvent && !getIsInitialBehavior()) {
                                addListener();
                            }
                        } else {
                            removeListener();
                            unsetGetReferenceClientRect();
                        }
                    }
                },
                onMount: function onMount() {
                    if (instance.props.followCursor && !wasFocusEvent) {
                        if (isUnmounted) {
                            onMouseMove(mouseCoords);
                            isUnmounted = false;
                        }

                        if (!getIsInitialBehavior()) {
                            addListener();
                        }
                    }
                },
                onTrigger: function onTrigger(_, event) {
                    if (isMouseEvent(event)) {
                        mouseCoords = {
                            clientX: event.clientX,
                            clientY: event.clientY,
                        };
                    }

                    wasFocusEvent = event.type === 'focus';
                },
                onHidden: function onHidden() {
                    if (instance.props.followCursor) {
                        unsetGetReferenceClientRect();
                        removeListener();
                        isUnmounted = true;
                    }
                },
            };
        },
    };

    function getProps(props, modifier) {
        var _props$popperOptions;

        return {
            popperOptions: Object.assign({}, props.popperOptions, {
                modifiers: [].concat(
                    (((_props$popperOptions = props.popperOptions) == null ? void 0 : _props$popperOptions.modifiers) || []).filter(function (_ref) {
                        var name = _ref.name;
                        return name !== modifier.name;
                    }),
                    [modifier]
                ),
            }),
        };
    }

    var inlinePositioning = {
        name: 'inlinePositioning',
        defaultValue: false,
        fn: function fn(instance) {
            var reference = instance.reference;

            function isEnabled() {
                return !!instance.props.inlinePositioning;
            }

            var placement;
            var cursorRectIndex = -1;
            var isInternalUpdate = false;
            var modifier = {
                name: 'tippyInlinePositioning',
                enabled: true,
                phase: 'afterWrite',
                fn: function fn(_ref2) {
                    var state = _ref2.state;

                    if (isEnabled()) {
                        if (placement !== state.placement) {
                            instance.setProps({
                                getReferenceClientRect: function getReferenceClientRect() {
                                    return _getReferenceClientRect(state.placement);
                                },
                            });
                        }

                        placement = state.placement;
                    }
                },
            };

            function _getReferenceClientRect(placement) {
                return getInlineBoundingClientRect(getBasePlacement(placement), reference.getBoundingClientRect(), arrayFrom(reference.getClientRects()), cursorRectIndex);
            }

            function setInternalProps(partialProps) {
                isInternalUpdate = true;
                instance.setProps(partialProps);
                isInternalUpdate = false;
            }

            function addModifier() {
                if (!isInternalUpdate) {
                    setInternalProps(getProps(instance.props, modifier));
                }
            }

            return {
                onCreate: addModifier,
                onAfterUpdate: addModifier,
                onTrigger: function onTrigger(_, event) {
                    if (isMouseEvent(event)) {
                        var rects = arrayFrom(instance.reference.getClientRects());
                        var cursorRect = rects.find(function (rect) {
                            return rect.left - 2 <= event.clientX && rect.right + 2 >= event.clientX && rect.top - 2 <= event.clientY && rect.bottom + 2 >= event.clientY;
                        });
                        cursorRectIndex = rects.indexOf(cursorRect);
                    }
                },
                onUntrigger: function onUntrigger() {
                    cursorRectIndex = -1;
                },
            };
        },
    };
    function getInlineBoundingClientRect(currentBasePlacement, boundingRect, clientRects, cursorRectIndex) {
        // Not an inline element, or placement is not yet known
        if (clientRects.length < 2 || currentBasePlacement === null) {
            return boundingRect;
        } // There are two rects and they are disjoined

        if (clientRects.length === 2 && cursorRectIndex >= 0 && clientRects[0].left > clientRects[1].right) {
            return clientRects[cursorRectIndex] || boundingRect;
        }

        switch (currentBasePlacement) {
            case 'top':
            case 'bottom': {
                var firstRect = clientRects[0];
                var lastRect = clientRects[clientRects.length - 1];
                var isTop = currentBasePlacement === 'top';
                var top = firstRect.top;
                var bottom = lastRect.bottom;
                var left = isTop ? firstRect.left : lastRect.left;
                var right = isTop ? firstRect.right : lastRect.right;
                var width = right - left;
                var height = bottom - top;
                return {
                    top: top,
                    bottom: bottom,
                    left: left,
                    right: right,
                    width: width,
                    height: height,
                };
            }

            case 'left':
            case 'right': {
                var minLeft = Math.min.apply(
                    Math,
                    clientRects.map(function (rects) {
                        return rects.left;
                    })
                );
                var maxRight = Math.max.apply(
                    Math,
                    clientRects.map(function (rects) {
                        return rects.right;
                    })
                );
                var measureRects = clientRects.filter(function (rect) {
                    return currentBasePlacement === 'left' ? rect.left === minLeft : rect.right === maxRight;
                });
                var _top = measureRects[0].top;
                var _bottom = measureRects[measureRects.length - 1].bottom;
                var _left = minLeft;
                var _right = maxRight;

                var _width = _right - _left;

                var _height = _bottom - _top;

                return {
                    top: _top,
                    bottom: _bottom,
                    left: _left,
                    right: _right,
                    width: _width,
                    height: _height,
                };
            }

            default: {
                return boundingRect;
            }
        }
    }

    var sticky = {
        name: 'sticky',
        defaultValue: false,
        fn: function fn(instance) {
            var reference = instance.reference,
                popper = instance.popper;

            function getReference() {
                return instance.popperInstance ? instance.popperInstance.state.elements.reference : reference;
            }

            function shouldCheck(value) {
                return instance.props.sticky === true || instance.props.sticky === value;
            }

            var prevRefRect = null;
            var prevPopRect = null;

            function updatePosition() {
                var currentRefRect = shouldCheck('reference') ? getReference().getBoundingClientRect() : null;
                var currentPopRect = shouldCheck('popper') ? popper.getBoundingClientRect() : null;

                if ((currentRefRect && areRectsDifferent(prevRefRect, currentRefRect)) || (currentPopRect && areRectsDifferent(prevPopRect, currentPopRect))) {
                    if (instance.popperInstance) {
                        instance.popperInstance.update();
                    }
                }

                prevRefRect = currentRefRect;
                prevPopRect = currentPopRect;

                if (instance.state.isMounted) {
                    requestAnimationFrame(updatePosition);
                }
            }

            return {
                onMount: function onMount() {
                    if (instance.props.sticky) {
                        updatePosition();
                    }
                },
            };
        },
    };

    function areRectsDifferent(rectA, rectB) {
        if (rectA && rectB) {
            return rectA.top !== rectB.top || rectA.right !== rectB.right || rectA.bottom !== rectB.bottom || rectA.left !== rectB.left;
        }

        return true;
    }

    if (isBrowser) {
        injectCSS(css);
    }

    tippy.setDefaultProps({
        plugins: [animateFill, followCursor, inlinePositioning, sticky],
        render: render,
    });
    tippy.createSingleton = createSingleton;
    tippy.delegate = delegate;
    tippy.hideAll = hideAll;
    tippy.roundArrow = ROUND_ARROW;

    return tippy;
});
//# sourceMappingURL=tippy-bundle.umd.js.map

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 *
 */
/* global CQURLInfo:false */
(function(window) {
    "use strict";

    window.Granite = window.Granite || {};
    window.Granite.HTTP = window.Granite.HTTP || {};

    var contextPath = null;

    function detectContextPath() {
        // eslint-disable-next-line max-len
        var SCRIPT_URL_REGEXP = /^(?:http|https):\/\/[^/]+(\/.*)\/(?:etc\.clientlibs|etc(\/.*)*\/clientlibs|libs(\/.*)*\/clientlibs|apps(\/.*)*\/clientlibs|etc\/designs).*\.js(\?.*)?$/;
        try {
            if (window.CQURLInfo) {
                contextPath = CQURLInfo.contextPath || "";
            } else {
                var scripts = document.getElementsByTagName("script");
                for (var i = 0; i < scripts.length; i++) {
                    var result = SCRIPT_URL_REGEXP.exec(scripts[i].src);
                    if (result) {
                        contextPath = result[1];
                        return;
                    }
                }
                contextPath = "";
            }
        } catch (e) {
            // ignored
        }
    }

    window.Granite.HTTP.externalize = window.Granite.HTTP.externalize || function(url) {
        if (contextPath === null) {
            detectContextPath();
        }

        try {
            if (url.indexOf("/") === 0 && contextPath && url.indexOf(contextPath + "/") !== 0) {
                url = contextPath + url;
            }
        } catch (e) {
            // ignored
        }

        return url;
    };
})(this);

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 *
 */
(function(factory) {
    "use strict";

    // GRANITE-22281 Check for multiple initialization
    if (window.Granite.csrf) {
        return;
    }

    window.Granite.csrf = factory(window.Granite.HTTP);
}(function(http) {
    "use strict";

    // AdobePatentID="P5296"

    function Promise() {
        this._handler = [];
    }

    Promise.prototype = {
        then: function(resolveFn, rejectFn) {
            this._handler.push({ resolve: resolveFn, reject: rejectFn });
        },
        resolve: function() {
            this._execute("resolve", arguments);
        },
        reject: function() {
            this._execute("reject", arguments);
        },
        _execute: function(result, args) {
            if (this._handler === null) {
                throw new Error("Promise already completed.");
            }

            for (var i = 0, ln = this._handler.length; i < ln; i++) {
                this._handler[i][result].apply(window, args);
            }

            this.then = function(resolveFn, rejectFn) {
                (result === "resolve" ? resolveFn : rejectFn).apply(window, args);
            };

            this._handler = null;
        }
    };

    function verifySameOrigin(url) {
        // url could be relative or scheme relative or absolute
        // host + port
        var host = document.location.host;
        var protocol = document.location.protocol;
        var relativeOrigin = "//" + host;
        var origin = protocol + relativeOrigin;

        // Allow absolute or scheme relative URLs to same origin
        return (url === origin || url.slice(0, origin.length + 1) === origin + "/") ||
                (url === relativeOrigin || url.slice(0, relativeOrigin.length + 1) === relativeOrigin + "/") ||
                // or any other URL that isn't scheme relative or absolute i.e relative.
                !(/^(\/\/|http:|https:).*/.test(url));
    }

    var FIELD_NAME = ":cq_csrf_token";
    var HEADER_NAME = "CSRF-Token";
    var TOKEN_SERVLET = http.externalize("/libs/granite/csrf/token.json");

    var promise;
    var globalToken;

    function logFailRequest(error) {
        if (window.console) {
            // eslint-disable-next-line no-console
            console.warn("CSRF data not available;" +
                    "The data may be unavailable by design, such as during non-authenticated requests: " + error);
        }
    }

    function getToken() {
        var localPromise = new Promise();
        promise = localPromise;

        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4) {
                try {
                    var data = JSON.parse(xhr.responseText);
                    globalToken = data.token;
                    localPromise.resolve(globalToken);
                } catch (ex) {
                    logFailRequest(ex);
                    localPromise.reject(xhr.responseText);
                }
            }
        };
        xhr.open("GET", TOKEN_SERVLET, true);
        xhr.send();

        return localPromise;
    }

    function getTokenSync() {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", TOKEN_SERVLET, false);
        xhr.send();

        try {
            return globalToken = JSON.parse(xhr.responseText).token;
        } catch (ex) {
            logFailRequest(ex);
        }
    }

    function clearToken() {
        globalToken = undefined;
        getToken();
    }

    function addField(form) {
        var action = form.getAttribute("action");
        if (form.method.toUpperCase() === "GET" || (action && !verifySameOrigin(action))) {
            return;
        }

        if (!globalToken) {
            getTokenSync();
        }

        if (!globalToken) {
            return;
        }

        var input = form.querySelector('input[name="' + FIELD_NAME + '"]');

        if (!input) {
            input = document.createElement("input");
            input.setAttribute("type", "hidden");
            input.setAttribute("name", FIELD_NAME);
            form.appendChild(input);
        }

        input.setAttribute("value", globalToken);
    }

    function handleForm(document) {
        var handler = function(ev) {
            var t = ev.target;

            if (t.nodeName === "FORM") {
                addField(t);
            }
        };

        if (document.addEventListener) {
            document.addEventListener("submit", handler, true);
        } else if (document.attachEvent) {
            document.attachEvent("submit", handler);
        }
    }

    handleForm(document);

    var open = XMLHttpRequest.prototype.open;

    XMLHttpRequest.prototype.open = function(method, url, async) {
        if (method.toLowerCase() !== "get" && verifySameOrigin(url)) {
            this._csrf = true;
            this._async = async;
        }

        return open.apply(this, arguments);
    };

    var send = XMLHttpRequest.prototype.send;

    XMLHttpRequest.prototype.send = function() {
        if (!this._csrf) {
            send.apply(this, arguments);
            return;
        }

        if (globalToken) {
            this.setRequestHeader(HEADER_NAME, globalToken);
            send.apply(this, arguments);
            return;
        }

        if (this._async === false) {
            getTokenSync();

            if (globalToken) {
                this.setRequestHeader(HEADER_NAME, globalToken);
            }

            send.apply(this, arguments);
            return;
        }

        var self = this;
        var args = Array.prototype.slice.call(arguments);

        promise.then(function(token) {
            self.setRequestHeader(HEADER_NAME, token);
            send.apply(self, args);
        }, function() {
            send.apply(self, args);
        });
    };

    var submit = HTMLFormElement.prototype.submit;

    HTMLFormElement.prototype.submit = function() {
        addField(this);
        return submit.apply(this, arguments);
    };

    if (window.Node) {
        var ac = Node.prototype.appendChild;

        Node.prototype.appendChild = function() {
            var result = ac.apply(this, arguments);

            if (result.nodeName === "IFRAME") {
                try {
                    if (result.contentWindow && !result._csrf) {
                        result._csrf = true;
                        handleForm(result.contentWindow.document);
                    }
                } catch (ex) {
                    if (result.src && result.src.length && verifySameOrigin(result.src)) {
                        if (window.console) {
                            // eslint-disable-next-line no-console
                            console.error("Unable to attach CSRF token to an iframe element on the same origin");
                        }
                    }

                    // Potential error: Access is Denied
                    // we can safely ignore CORS security errors here
                    // because we do not want to expose the csrf anyways to another domain
                }
            }

            return result;
        };
    }

    // refreshing csrf token periodically
    getToken();

    setInterval(function() {
        getToken();
    }, 300000);

    return {
        initialised: false,
        refreshToken: getToken,
        _clearToken: clearToken
    };
}));

function majToMin(str) {
    return str.toLowerCase();
}
function regexTransform(str, match, regex) {
    return str.replace(match, regex);
}
function trimStr(str) {
    return str.trim();
}
function forceSegments(str) {
    var seg = str.split('::');
    if (seg.length > 4) {
        str = seg.slice(0, 4).join('::') + '_' + seg.slice(4).join('_');
    }

    return str;
}

function isEmpty(str) {
    return !str || 0 === str.length;
}
function isBlank(str) {
    return !str || /^\s*$/.test(str);
}
String.prototype.isEmpty = function () {
    return this.length === 0 || !this.trim();
};

function isExternal(internal) {
    if (internal === 'true') {
        // a link that contains the current host
        return 'navigation';
    } else {
        // a link that does not contain the current host
        return 'exit';
    }
}
function isExternal2(url) {
    var comp = new RegExp(location.host);
    if (comp.test(url)) {
        // a link that contains the current host
        return 'navigation';
    } else {
        // a link that does not contain the current host
        return 'exit';
    }
}

function isMacintosh() {
    return navigator.platform.indexOf('Mac') > -1;
}

function isWindows() {
    return navigator.platform.indexOf('Win') > -1;
}

function ClickHandler(_url, _target, _event) {
    //force new tab if middle click or ctrl/cmd click
    if (_event.which == 2 || (_event.ctrlKey && isWindows()) || (_event.metaKey && isMacintosh())) {
        _target = '_blank';
    }

    if (_target === '_blank') {
        win = window.open(_url, _target);
        // win.focus();
        win.blur();
    } else if(_target === '_top'){
        setTimeout(function () {
            window.top.location = _url;
        }, 300);
    } else {
        setTimeout(function () {
            window.location = _url;
        }, 300);
    }
}

/*
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
var defaultDiacriticsRemovalMap = [
    {'base':'A', 'letters':'\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F'},
    {'base':'AA','letters':'\uA732'},
    {'base':'AE','letters':'\u00C6\u01FC\u01E2'},
    {'base':'AO','letters':'\uA734'},
    {'base':'AU','letters':'\uA736'},
    {'base':'AV','letters':'\uA738\uA73A'},
    {'base':'AY','letters':'\uA73C'},
    {'base':'B', 'letters':'\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181'},
    {'base':'C', 'letters':'\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E'},
    {'base':'D', 'letters':'\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779\u00D0'},
    {'base':'DZ','letters':'\u01F1\u01C4'},
    {'base':'Dz','letters':'\u01F2\u01C5'},
    {'base':'E', 'letters':'\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E'},
    {'base':'F', 'letters':'\u0046\u24BB\uFF26\u1E1E\u0191\uA77B'},
    {'base':'G', 'letters':'\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E'},
    {'base':'H', 'letters':'\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D'},
    {'base':'I', 'letters':'\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197'},
    {'base':'J', 'letters':'\u004A\u24BF\uFF2A\u0134\u0248'},
    {'base':'K', 'letters':'\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2'},
    {'base':'L', 'letters':'\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780'},
    {'base':'LJ','letters':'\u01C7'},
    {'base':'Lj','letters':'\u01C8'},
    {'base':'M', 'letters':'\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C'},
    {'base':'N', 'letters':'\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4'},
    {'base':'NJ','letters':'\u01CA'},
    {'base':'Nj','letters':'\u01CB'},
    {'base':'O', 'letters':'\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C'},
    {'base':'OI','letters':'\u01A2'},
    {'base':'OO','letters':'\uA74E'},
    {'base':'OU','letters':'\u0222'},
    {'base':'OE','letters':'\u008C\u0152'},
    {'base':'oe','letters':'\u009C\u0153'},
    {'base':'P', 'letters':'\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754'},
    {'base':'Q', 'letters':'\u0051\u24C6\uFF31\uA756\uA758\u024A'},
    {'base':'R', 'letters':'\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782'},
    {'base':'S', 'letters':'\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784'},
    {'base':'T', 'letters':'\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786'},
    {'base':'TZ','letters':'\uA728'},
    {'base':'U', 'letters':'\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244'},
    {'base':'V', 'letters':'\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245'},
    {'base':'VY','letters':'\uA760'},
    {'base':'W', 'letters':'\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72'},
    {'base':'X', 'letters':'\u0058\u24CD\uFF38\u1E8A\u1E8C'},
    {'base':'Y', 'letters':'\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE'},
    {'base':'Z', 'letters':'\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762'},
    {'base':'a', 'letters':'\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250'},
    {'base':'aa','letters':'\uA733'},
    {'base':'ae','letters':'\u00E6\u01FD\u01E3'},
    {'base':'ao','letters':'\uA735'},
    {'base':'au','letters':'\uA737'},
    {'base':'av','letters':'\uA739\uA73B'},
    {'base':'ay','letters':'\uA73D'},
    {'base':'b', 'letters':'\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253'},
    {'base':'c', 'letters':'\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184'},
    {'base':'d', 'letters':'\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A'},
    {'base':'dz','letters':'\u01F3\u01C6'},
    {'base':'e', 'letters':'\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD'},
    {'base':'f', 'letters':'\u0066\u24D5\uFF46\u1E1F\u0192\uA77C'},
    {'base':'g', 'letters':'\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F'},
    {'base':'h', 'letters':'\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265'},
    {'base':'hv','letters':'\u0195'},
    {'base':'i', 'letters':'\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131'},
    {'base':'j', 'letters':'\u006A\u24D9\uFF4A\u0135\u01F0\u0249'},
    {'base':'k', 'letters':'\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3'},
    {'base':'l', 'letters':'\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747'},
    {'base':'lj','letters':'\u01C9'},
    {'base':'m', 'letters':'\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F'},
    {'base':'n', 'letters':'\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5'},
    {'base':'nj','letters':'\u01CC'},
    {'base':'o', 'letters':'\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275'},
    {'base':'oi','letters':'\u01A3'},
    {'base':'ou','letters':'\u0223'},
    {'base':'oo','letters':'\uA74F'},
    {'base':'p','letters':'\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755'},
    {'base':'q','letters':'\u0071\u24E0\uFF51\u024B\uA757\uA759'},
    {'base':'r','letters':'\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783'},
    {'base':'s','letters':'\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B'},
    {'base':'t','letters':'\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787'},
    {'base':'tz','letters':'\uA729'},
    {'base':'u','letters': '\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289'},
    {'base':'v','letters':'\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C'},
    {'base':'vy','letters':'\uA761'},
    {'base':'w','letters':'\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73'},
    {'base':'x','letters':'\u0078\u24E7\uFF58\u1E8B\u1E8D'},
    {'base':'y','letters':'\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF'},
    {'base':'z','letters':'\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763'}
];

var diacriticsMap = {};
for (var i=0; i < defaultDiacriticsRemovalMap .length; i++){
    var letters = defaultDiacriticsRemovalMap [i].letters;
    for (var j=0; j < letters.length ; j++){
        diacriticsMap[letters[j]] = defaultDiacriticsRemovalMap [i].base;
    }
}

// "what?" version ... http://jsperf.com/diacritics/12
function normalizeString(str) {
    return str.replace(/[^\u0000-\u007E]/g, function(a){
       return diacriticsMap[a] || a;
    });
}

$.fn.TaggingStringCheck = function () {
    var txt;
    if (arguments[0] && !isEmpty(arguments[0])) {
        txt = arguments[0];
    } else {
        txt = !isEmpty(this.text()) && !isBlank(this.text()) ? this.text() : this.attr('title');
    }

    if (txt !== undefined) {
        var majTominRgx = /\b[A-Z]{2,}\b/g;
        var spaceRgx = /[\s-]+/g;
        var underscoreRgx = '_';
        var specialChars = /[^(\w\-)\s]/gi;

        txt = normalizeString(txt);
        txt = regexTransform(txt, /&amp|&gt|&lt|&nbsp/g, '');
        txt = regexTransform(txt, specialChars, '');
        txt = trimStr(txt);
        txt = majToMin(txt);
        txt = regexTransform(txt, spaceRgx, underscoreRgx);
    }
    return txt;
};

function setXtn2(url, urlwithdomain) {
    var tld = document.location.hostname.split('.')[document.location.hostname.split('.').length - 1];
    if (tld === "fr") {
        /*Ajout de xiti_xtn2 16 comptes en ligne*/
        if (urlwithdomain.indexOf("voscomptesenligne-ti.sf.intra.laposte.fr") > -1 || urlwithdomain.indexOf("voscomptesenligne-rf.sf.intra.laposte.fr") > -1 || urlwithdomain.indexOf("voscomptesenligne.labanquepostale.fr") > -1) {
            return 16;
        }

        /*Ajout de xiti_xtn2 34 comptes en ligne*/
        if (urlwithdomain.indexOf("banqueenligneti.sf.intra.laposte.fr") > -1 || urlwithdomain.indexOf("banqueenlignerf.sf.intra.laposte.fr") > -1 || urlwithdomain.indexOf("banqueenligne.entreprises.labanquepostale.fr") > -1) {
            return 34;
        }

        if ((url === "/" && (urlwithdomain.indexOf("www.labanquepostale.fr") > -1 || urlwithdomain.indexOf("www.rit.labanquepostale.fr") > -1)) || url.indexOf("/portail") === 0 || urlwithdomain.indexOf("www.rf.labanquepostale.fr")) {
            /*ajout du domaine rf.labanquepostale.fr*/
            return 21;
        }

        if (url === "/transversal/popups/groupe/cv_de_remy_weber.html" || url === "/transversal/popups/groupe/Philippe_Wahl.html" || url.indexOf("/transversal/opcvm") === 0) {
            return 2;
        }

        if (urlwithdomain.indexOf(".harvest.fr") > -1 || urlwithdomain.indexOf("simulateurs.labanquepostale.fr") > -1) {
            return 6;
        }

        // Cas particuliers  ajouter ici pour s2 = 6

        if (url === "/transversal/popups/credits.html" || url === "/transversal/popups/mentions_legales.html") {
            return 8;
        }

        if (urlwithdomain.indexOf("transverse.labanquepostale.fr") > -1 ||
            urlwithdomain.indexOf("formulaire-tpe.labanquepostale.fr") > -1) {
            return 11;
        }
        if (urlwithdomain.indexOf("formulairepmo.labanquepostale.fr?id=") !== -1) {
            if (urlwithdomain.indexOf("?id=10") !== 1) {
                return 140;
            }
            if (urlwithdomain.indexOf("?id=11") !== 1) {
                return 170;
            }
        }
        // Cas particuliers  ajouter ici pour s2 = 11

        if (url === "/transversal/popups/particuliers/module_pieces_justificatives/popup_piecesJustificatives_intro.html" || url === "/transversal/popups/particuliers/module_pieces_justificatives/popup_piecesJustificatives_step1.html") {
            return 12;
        }

        if (url.indexOf("/particuliers/") === 0) {
            return 16;
        }

        if (urlwithdomain.indexOf("sadselfservicedeficom.labanquepostale.fr") > -1 ||
            url.indexOf("/particulier/") === 0 || url.indexOf("/particulier.html") === 0 ||
            url.indexOf("/content/particulier/") === 0 ||
            url.indexOf("/content/particulier.html") === 0 ||
            url.indexOf("/content/portail.html") === 0 ||
            url.indexOf("/particulier/formulaires/") === 0 ||
            url.indexOf("/particulier/Outils/simulateurs/diagnostic_retraite.diagretraite.html") === 0 ||
            url.indexOf("/guideimmo/") === 0 ||
            url.indexOf("/guideimmo.sommaire.html") === 0 ||
            urlwithdomain.indexOf("ouvriruncompte.labanquepostale.fr") !== -1) {
            return 21;
        }

        if (url.indexOf("/legroupe") === 0) {
            return 25;
        }

        if (url.indexOf("/transversal/popups/argent_au_quotidien/e_carte_bleue/") === 0) {
            return 32;
        }

        if (url.indexOf("/associations-gestionnaires") === 0) {
            return 100;
        }
        if (url === "/associations.html" || url.indexOf("/associations") === 0) {
            return 100;
        }

        if (url.indexOf("/bailleurs-sociaux") === 0) {
            return 120;
        }

        if (url.indexOf("/collectivites") === 0) {
            return 130;
        }


        if (url.indexOf("/grandes-entreprises") === 0) {
            return 170;
        }

        if (url.indexOf("/grands-institutionnels") === 0) {
            return 150;
        }

        if (url.indexOf("/acteurs-economiques") === 0) {
            return 190;
        }
        if (url.indexOf("/institutionnels") === 0) {
            return 170;
        }

        if (url.indexOf("/hopitaux") === 0) {
            return 155;
        }

        if (url.indexOf("/mutuelles") === 0) {
            return 160;
        }

        if (url.indexOf("/entreprises") === 0) {
            if (url.indexOf("entreprises-territoires") === 0) {
                return 190;
            } else {
                return 170;
            }
        }

        if (url.indexOf("/professionnels") === 0 || url === "/transversal/ident/pmo_ouvrir_compte.html" || document.location.hostname.indexOf("ouvriruncomptepro.") > -1 || urlwithdomain.indexOf("ecreditpro.labanquepostale.fr") > -1) {
            return 180;
        }

        if (url === "/page_indispo-F5-AEM.html") {
            return 21;
        }
    }

    if (tld === "com") {
        if (urlwithdomain.indexOf("labanquepostaleselfservicev2.mm-dev2.com") > -1) {
            return 21;
        } else if (url.indexOf("/corporate_eng.html") > -1) {
            return 24;
        } else if (urlwithdomain.indexOf("www.labanquepostale.com/en") > -1) {
            return 252;
        } else if (urlwithdomain.indexOf("www.labanquepostale.com") > -1) {
            return 25;
        }

        return 21;

    }

    if (tld === "net") {
        if (urlwithdomain.indexOf("re7.labanquepostale.ekeynox.net") > -1) {
            return 180;
        }
    }
}

tc_vars.xiti_xtn2 = setXtn2(document.location.pathname, location.href);
function LBPTagging(options) {
    this.trigger = options.trigger;
    this.args = options.args;
    this.event = options.event;
}
LBPTagging.prototype.init = function() {
    this.bindEvents();
};
LBPTagging.prototype.bindEvents = function() {
    var _this = this;
    console.log('tc_events_global(' + this.trigger + ', ' + this.event + ', ' + JSON.stringify(this.args) + ')');
    tc_events_global(this.trigger, this.event, this.args);
};
document.addEventListener('DOMContentLoaded', function() {
    $.fn.Tagging = function(options) {
        var settings = $.extend(
            {
                'trigger': this,
                'event': 'CLICK',
                'args': {},
            },
            options
        );

        var load = function() {
            var LBPTag = new LBPTagging({
                trigger: settings.trigger,
                event: settings.event,
                args: settings.args,
            });
            LBPTag.init();
        };
        return load();
    };
});

(function ($) {
    $(document).on('click', '.u-btn[js-btn-tracking]', function (e) {
        e.preventDefault();
        var $this = $(this);
        var _libelleEvent = '',
            _url = $this.attr('href'),
            _internal = $this.attr('data-internal'),
            _target = $this.attr('target');

        if ($(this).closest('.m-header__submenu__push').length) {
            //exit function if  decisiontree link/actions
            return;
        }

        if ($(this).is('.o-footer .u-btn')) {
            //Footer
            return;
        } else if ($(this).is('.o-herobanner__homepage .u-btn')) {
            //Herobanner Homepage
            _libelleEvent = 'bouton_hero_banner::' + $this.TaggingStringCheck() + '::' + tc_vars.xiti_xtpage;
        } else {
            //Default
            var id_composant_attr = $this.closest('[data-component-id]').attr('data-component-id');
            var id_composant = id_composant_attr.substring(id_composant_attr.lastIndexOf('/') + 1, id_composant_attr.length);

            _libelleEvent = tc_vars.xiti_xtpage + '::' + id_composant + '::' + $this.TaggingStringCheck();
        }
        
        // If no idCampaign set on illsutrated container trigger classic tracking
        var idCampaign = $this.parents('.js-illustratedcontainer').attr('data-idcampaign');

        console.log("ic campaing ", idCampaign);

        if(idCampaign === undefined) {
            try {
                $(this).Tagging({
                    trigger: this,
                    event: 'CLICK',
                    args: {
                        libelle_event: forceSegments(_libelleEvent),
                        page_clicked: tc_vars.xiti_xtpage,
                        click_type: isExternal(_internal),
                        xiti_xtn2: tc_vars.xiti_xtn2,
                    },
                });
            } catch (err) {
                console.error(err);
            }
            ClickHandler(_url, _target, e);
        }
    });
})(window.jQuery);

(function ($) {
    $(document).on('click', '.a-text a[href]', function (e) {
        var $this = $(this),
            _url = $this.attr('href'),
            _target = $this.attr('target'),
            _fullUrl;

        // Stop if is text inside warnbanner component
        if ($(this).closest('.o-warnbanner').length ||$(this).closest('.o-opc-selector').length) {
            return;
        } else {
            e.preventDefault();
        }

        if (_url.startsWith('http') || _url.startsWith('www')) {
            _fullUrl = _url;
        } else {
            _fullUrl = location.host + _url;
        }

        var id_composant_attr = $this.closest('[data-component-id]').attr('data-component-id');
        var id_composant = id_composant_attr.substring(id_composant_attr.lastIndexOf('/') + 1, id_composant_attr.length);

        try {
            $(this).Tagging({
                trigger: this,
                event: 'CLICK',
                args: {
                    libelle_event: forceSegments(tc_vars.xiti_xtpage + '::' + id_composant + '::' + $this.TaggingStringCheck()),
                    page_clicked: tc_vars.xiti_xtpage,
                    click_type: isExternal2(_fullUrl),
                    xiti_xtn2: tc_vars.xiti_xtn2,
                },
            });
        } catch (err) {
            console.error(err);
        }

        ClickHandler(_url, _target, e);
    });
})(window.jQuery);

(function ($) {
    //action tagging on button/link on result Page (card pmo)
    $(document).on('click', '.m-product__link a[href]', function (e) {
        e.preventDefault();
        var $this = $(this);
        var _url = $this.attr('href'),
            _target = $this.attr('target');
        _labelId = $this.closest('[data-tree-product-id]').data('tree-product-id');
        _labelCard = $('[data-tree-product-id="' + _labelId + '"]')
            .first()
            .find('.m-product__title')
            .text();

        var nom_formulaire = $('body').attr('data-title');
        nom_formulaire = $(this).TaggingStringCheck(nom_formulaire);

        try {
            $(this).Tagging({
                trigger: this,
                event: 'pageview',
                args: {
                    xiti_xtsite: tc_vars.xiti_xtsite,
                    xiti_xtn2: tc_vars.xiti_xtn2,
                    'pageName': 'outil_aide_decision::' + nom_formulaire + '::resultats::bouton_' + $(this).TaggingStringCheck() + '_' + $(this).TaggingStringCheck(_labelCard),
                },
            });
        } catch (err) {
            console.error(err);
        }

        ClickHandler(_url, _target, e);
    });

    //action tagging on button/link on result Page (talent booster)
    $(document).on('click', '#talent-booster a[href]', function (e) {
        e.preventDefault();
        var $this = $(this);
        var _url = $this.attr('href'),
            _target = $this.attr('target');
            $container =  $this.parents('.m-container');
            _labelCard = $container.find('h3').text();

        var nom_formulaire = $('body').attr('data-title');
        nom_formulaire = $(this).TaggingStringCheck(nom_formulaire);

        try {
            $(this).Tagging({
                trigger: this,
                event: 'pageview',
                args: {
                    xiti_xtsite: tc_vars.xiti_xtsite,
                    xiti_xtn2: tc_vars.xiti_xtn2,
                    'pageName': 'outil_aide_decision::' + nom_formulaire + '::resultats::bouton_' + $(this).TaggingStringCheck(_labelCard),
                },
            });
        } catch (err) {
            console.error(err);
        }

        ClickHandler(_url, _target, e);
    });

    //action tagging on Modifier mes rponses
    $(document).on('click', '[data-groups-step]', function (e) {
        e.preventDefault();
        var $this = $(this);
        var _url = $this.attr('href'),
            _target = $this.attr('target');

        var nom_formulaire = $('body').attr('data-title');
        nom_formulaire = $(this).TaggingStringCheck(nom_formulaire);

        try {
            $(this).Tagging({
                trigger: this,
                event: 'pageview',
                args: {
                    xiti_xtsite: tc_vars.xiti_xtsite,
                    xiti_xtn2: tc_vars.xiti_xtn2,
                    'pageName': 'outil_aide_decision::' + nom_formulaire + '::resultats::bouton_' + $(this).TaggingStringCheck(),
                },
            });
        } catch (err) {
            console.error(err);
        }

        ClickHandler(_url, _target, e);
    });

    //action tagging on Button container conditionel
    $(document).on('click', '.o-container--isDecisiontree .u-btn, .o-container--isDecisiontree a[href]', function (e) {
        e.preventDefault();
        var $this = $(this);
        var _url = $this.attr('href'),
            _target = $this.attr('target');

        var nom_formulaire = $('body').attr('data-title');
        nom_formulaire = $(this).TaggingStringCheck(nom_formulaire);

        try {
            $(this).Tagging({
                trigger: this,
                event: 'CLICK',
                args: {
                    xiti_xtsite: tc_vars.xiti_xtsite,
                    xiti_xtn2: tc_vars.xiti_xtn2,
                    'clic_label': 'outil_aide_decision::' + nom_formulaire + '::resultats::bouton_complement_' + $(this).TaggingStringCheck(),
                },
            });
        } catch (err) {
            console.error(err);
        }

        ClickHandler(_url, _target, e);
    });
})(window.jQuery);

(function ($) {
    $(document).on('click', '.o-video__thumbnail, .o-video__iframe', function (e) {
        e.preventDefault();
        var $this = $(this),
            $title = $this.parent().next('.o-video__title');

        try {
            $(this).Tagging({
                trigger: this,
                event: 'CLICK',
                args: {
                    libelle_event: forceSegments(tc_vars.xiti_xtpage + '::video::' + $title.TaggingStringCheck()),
                    page_clicked: tc_vars.xiti_xtpage,
                    click_type: 'navigation',
                    xiti_xtn2: tc_vars.xiti_xtn2,
                },
            });
        } catch (err) {
            console.error(err);
        }
    });
})(window.jQuery);

(function ($) {
    $(document).on('click', '.m-image a[href]', function (e) {
        e.preventDefault();
        var $this = $(this);

        var _url = $this.attr('href'),
            _assetTitle = $this.parent().attr('data-asset-title'),
            _target = $this.attr('target'),
            _internal = $this.attr('data-internal'),
            _alt = $this.find('img').attr('alt');

        if (_alt === ' ' || _alt === undefined) {
            _alt = _assetTitle;
        }

        try {
            $(this).Tagging({
                trigger: this,
                event: 'CLICK',
                args: {
                    libelle_event: forceSegments(tc_vars.xiti_xtpage + '::' + 'image' + '::' + $this.TaggingStringCheck(_alt)),
                    page_clicked: tc_vars.xiti_xtpage,
                    click_type: isExternal(_internal),
                    xiti_xtn2: tc_vars.xiti_xtn2,
                },
            });
        } catch (err) {
            console.error(err);
        }

        ClickHandler(_url, _target, e);
    });
})(window.jQuery);

(function ($) {
    $(document).on('click', '#newsletterPushButton', function (e) {
        var $this = $(this);
        try {
            $(this).Tagging({
                trigger: this,
                event: 'CLICK',
                args: {
                    libelle_event: forceSegments(tc_vars.xiti_xtpage + '::button::inscription_newsletter'),
                    page_clicked: tc_vars.xiti_xtpage,
                    click_type: isExternal(true),
                    xiti_xtn2: tc_vars.xiti_xtn2,
                },
            });
        } catch (err) {
            console.error(err);
        }
    });
})(window.jQuery);

(function ($) {
    $(document).on('click', '#currencyconverterButton', function (e) {
        var $this = $(this);
        try {
            $(this).Tagging({
                trigger: this,
                event: 'CLICK',
                args: {
                    libelle_event: forceSegments(tc_vars.xiti_xtpage + '::button::' + $this.TaggingStringCheck()),
                    page_clicked: tc_vars.xiti_xtpage,
                    click_type: 'navigation',
                    xiti_xtn2: tc_vars.xiti_xtn2,
                },
            });
        } catch (err) {
            console.error(err);
        }
    });
})(window.jQuery);

(function ($) {
    $(document).on('click', '.o-warnbanner a', function (e) {
        e.preventDefault();
        var $this = $(this);

        var _url = $this.attr('href'),
            _internal = $this.attr('data-internal'),
            _target = $this.attr('target'),
            _fullUrl;

        if (_url.startsWith('http') || _url.startsWith('www')) {
            _fullUrl = _url;
        } else {
            _fullUrl = location.host + _url;
        }

        try {
            $(this).Tagging({
                trigger: this,
                event: 'CLICK',
                args: {
                    libelle_event: forceSegments('message_alerte::' + $this.TaggingStringCheck()),
                    page_clicked: tc_vars.xiti_xtpage,
                    click_type: isExternal2(_fullUrl),
                    xiti_xtn2: tc_vars.xiti_xtn2,
                },
            });
        } catch (err) {
            console.error(err);
        }

        ClickHandler(_url, _target, e);
    });
})(window.jQuery);

(function ($) {
    $(document).on('mousedown keydown', '.relatedsolutions .o-containerlist a[href]', function (e) {
        var isEvent,
            $this = $(this),
            _url = $this.attr('href'),
            _internal = $this.attr('data-internal'),
            _target = $this.attr('target');

        if (e.type == 'mousedown') {
            isEvent = function () {
                return e.which == 1 || e.which == 2;
            };
        } else if (e.which == 13) {
            isEvent = function () {
                return e.which == 13;
            };
        } else {
            //touchstart
            isEvent = function () {
                return e.which == 0;
            };
        }
        var adClick = $this.parents('.js-pushteaser').attr('data-idcampaign');
        if(adClick === undefined) {
            if (isEvent()) {
                e.preventDefault();
                var dataTaggingSectionTitle = $this.TaggingStringCheck($this.closest('[data-tagging-push]').find('.m-title').text());
                var dataTaggingTitle = $this.TaggingStringCheck($this.text());
                try {
                    $(this).Tagging({
                        trigger: this,
                        event: 'CLICK',
                        args: {
                            libelle_event: forceSegments(tc_vars.xiti_xtpage + '::' + dataTaggingSectionTitle + '_' + dataTaggingTitle),
                            page_clicked: tc_vars.xiti_xtpage,
                            click_type: isExternal(_internal),
                            xiti_xtn2: tc_vars.xiti_xtn2,
                        },
                    });
                } catch (err) {
                    console.error(err);
                }
                ClickHandler(_url, _target, e);
            }
        }
    });
})(window.jQuery);

(function ($) {
    $(document).on('click', '.o-footer   a', function (e) {
        e.preventDefault();
        var $this = $(this);

        var _libelleEvent = '',
            _url = $this.attr('href'),
            _internal = $this.attr('data-internal'),
            _target = $this.attr('target');

        if ($(this).is('.o-footer  .a-text a[href]')) {
            //paragraphe
            return;
        } else if ($(this).is('.o-footer .u-btn')) {
            //Button component
            _libelleEvent = 'footer::bouton_' + $this.TaggingStringCheck() + '::' + tc_vars.xiti_xtpage;
        } else if ($(this).is('.o-footer  .m-tiles__item a')) {
            //Tuiles
            _libelleEvent = 'footer::tuile_' + $this.TaggingStringCheck() + '::' + tc_vars.xiti_xtpage;
        } else if ($(this).is('.o-footer  .m-newsletterlink a')) {
            //newsletterlink
            _libelleEvent = 'footer::abonnement_newsletter::' + tc_vars.xiti_xtpage;
        } else if ($(this).is('.o-footer  .m-socialmedialist a')) {
            //social links sharing
            _libelleEvent = 'footer::partage_' + $this.TaggingStringCheck() + '::' + tc_vars.xiti_xtpage;
        } else if ($(this).is('.o-footer  .m-legalpagelink a')) {
            //legal links
            _libelleEvent = 'footer::mentions_' + $this.TaggingStringCheck() + '::' + tc_vars.xiti_xtpage;
        }

        try {
            $(this).Tagging({
                trigger: this,
                event: 'CLICK',
                args: {
                    libelle_event: forceSegments(_libelleEvent),
                    page_clicked: tc_vars.xiti_xtpage,
                    click_type: isExternal(_internal),
                    xiti_xtn2: tc_vars.xiti_xtn2,
                },
            });
        } catch (err) {
            console.error(err);
        }

        ClickHandler(_url, _target, e);
    });
})(window.jQuery);

(function ($) {
    $(document).on('click', '.o-header button.m-searchbar__opener', function (e) {
        e.preventDefault();
        var $this = $(this);

        try {
            $(this).Tagging({
                trigger: this,
                event: 'CLICK',
                args: {
                    libelle_event: forceSegments('header::recherche::' + tc_vars.xiti_xtpage),
                    page_clicked: tc_vars.xiti_xtpage,
                    click_type: 'navigation',
                    xiti_xtn2: tc_vars.xiti_xtn2,
                },
            });
        } catch (err) {
            console.error(err);
        }
    });
})(window.jQuery);

function HeaderTracking() {
    this.header = $('header');
    this.logo = this.header.find('.js-logo-type');
    this.metanav = this.header.find('.m-metanavigation__box__link ');
    this.headerlinks = this.header.find('.m-header__links__item').not('.m-header__lang__btn,.m-header__lang__link');
    this.connect = this.header.find('.m-header__links__item__connect');
    this.search = this.header.find('.m-searchbar__opener');
    this.menuItems = this.header.find('.js-tracking-item');
    this.lang = this.header.find('.m-header__lang > a');
    this.cardhelp = this.header.find('.m-header__submenu__card');
    this.pushLink = this.header.find('.m-header__submenu__push a');
}

HeaderTracking.prototype = {
    init: function () {
        this.events();
    },
    events: function () {
        this.logo.on('click', function (e) {
            e.preventDefault();

            var $this = $(this);
            (_url = $this.attr('href')), (_target = $this.attr('target')), (isLink = $(this).is('a'));

            if (isLink) {
                try {
                    $(this).Tagging({
                        trigger: this,
                        event: 'CLICK',
                        args: {
                            libelle_event: forceSegments('header::logo_lbp' + '::' + tc_vars.xiti_xtpage),
                            page_clicked: tc_vars.xiti_xtpage,
                            click_type: 'navigation',
                            xiti_xtn2: tc_vars.xiti_xtn2,
                        },
                    });
                } catch (err) {
                    console.error(err);
                }
                ClickHandler(_url, _target, e);
            }
        });
        this.metanav.on('click', function (e) {
            e.preventDefault();
            var $this = $(this);
            (label = $this.text()), (_url = $this.attr('href')), (_target = $this.attr('target'));

            try {
                $(this).Tagging({
                    trigger: this,
                    event: 'CLICK',
                    args: {
                        libelle_event: forceSegments('header::metanav::' + $this.TaggingStringCheck(label) + '::' + tc_vars.xiti_xtpage),
                        page_clicked: tc_vars.xiti_xtpage,
                        click_type: 'navigation',
                        xiti_xtn2: tc_vars.xiti_xtn2,
                    },
                });
            } catch (err) {
                console.error(err);
            }
            ClickHandler(_url, _target, e);
        });
        this.headerlinks.on('click', function (e) {
            e.preventDefault();

            var $this = $(this),
                label = $this.children('span').text(),
                _url = $this.attr('href'),
                _internal = $this.attr('data-internal'),
                _target = $this.attr('target');

            try {
                $(this).Tagging({
                    trigger: this,
                    event: 'CLICK',
                    args: {
                        libelle_event: forceSegments('header::lien_rapide::' + $this.TaggingStringCheck(label) + '::' + tc_vars.xiti_xtpage),
                        page_clicked: tc_vars.xiti_xtpage,
                        click_type: isExternal(_internal),
                        xiti_xtn2: tc_vars.xiti_xtn2,
                    },
                });
            } catch (err) {
                console.error(err);
            }
            ClickHandler(_url, _target, e);
        });
        this.connect.on('click', function (e) {
            e.preventDefault();
            var $this = $(this);
            (label = $this.find('span')), (_url = $this.attr('href')), (_target = $this.attr('target'));

            try {
                $(this).Tagging({
                    trigger: this,
                    event: 'CLICK',
                    args: {
                        libelle_event: forceSegments('header::se_connecter' + $this.TaggingStringCheck(label) + +'::' + tc_vars.xiti_xtpage),
                        page_clicked: tc_vars.xiti_xtpage,
                        click_type: 'navigation',
                        xiti_xtn2: tc_vars.xiti_xtn2,
                    },
                });
            } catch (err) {
                console.error(err);
            }
            ClickHandler(_url, _target, e);
        });
        this.search.on('click', function (e) {
            e.preventDefault();

            try {
                $(this).Tagging({
                    trigger: this,
                    event: 'CLICK',
                    args: {
                        libelle_event: forceSegments('header::recherche' + '::' + tc_vars.xiti_xtpage),
                        page_clicked: tc_vars.xiti_xtpage,
                        click_type: 'navigation',
                        xiti_xtn2: tc_vars.xiti_xtn2,
                    },
                });
            } catch (err) {
                console.error(err);
            }
        });
        this.menuItems.on('click', function (e) {
            e.preventDefault();

            var $this = $(this),
                levelEl = $this.closest('[data-level]'),
                label = $this.text(),
                level = levelEl.attr('data-level'),
                labels = [label];

            var isLink = $this.is('a');

            if (isLink) {
                var _url = $this.attr('href'),
                    _target = $this.attr('target');
            }

            for (var i = parseInt(level); i > 0; i--) {
                levelEl = levelEl.parent().closest('[data-level]');

                if (levelEl.length > 0) {
                    labels.unshift(levelEl.find('.js-tracking-item').first().text());
                }
            }
            if (labels.length > 1) {
                txtlabels = labels.join('_');
            } else {
                txtlabels = label;
            }
            try {
                $(this).Tagging({
                    trigger: this,
                    event: 'CLICK',
                    args: {
                        libelle_event: forceSegments('header::menu' + '::' + $this.TaggingStringCheck(txtlabels) + '::' + tc_vars.xiti_xtpage),
                        page_clicked: tc_vars.xiti_xtpage,
                        click_type: 'navigation',
                        xiti_xtn2: tc_vars.xiti_xtn2,
                    },
                });
                labels = [];
            } catch (err) {
                console.error(err);
            }
            if (isLink) {
                ClickHandler(_url, _target, e);
            }
        });
        this.lang.on('click', function (e) {
            e.preventDefault();

            var $this = $(this),
                label = $this.children().text(),
                _url = $this.attr('href'),
                _target = $this.attr('target');

            try {
                $(this).Tagging({
                    trigger: this,
                    event: 'CLICK',
                    args: {
                        libelle_event: forceSegments('header::multilingue' + '::' + $this.TaggingStringCheck(label)),
                        page_clicked: tc_vars.xiti_xtpage,
                        click_type: 'navigation',
                        xiti_xtn2: '25',
                    },
                });
            } catch (err) {
                console.error(err);
            }
            ClickHandler(_url, _target, e);
        });
        this.cardhelp.on('click', function (e) {
            e.preventDefault();

            var $this = $(this),
                label = $this.closest('.a-navigation__menu__item').children().first().text(),
                _url = $this.attr('href'),
                _target = $this.attr('target');

            try {
                $(this).Tagging({
                    trigger: this,
                    event: 'CLICK',
                    args: {
                        libelle_event: forceSegments('header::menu' + '::' + $this.TaggingStringCheck(label) + '::push_arbre_decision::' + tc_vars.xiti_xtpage),
                        page_clicked: tc_vars.xiti_xtpage,
                        click_type: 'navigation',
                        xiti_xtn2: tc_vars.xiti_xtn2,
                    },
                });
            } catch (err) {
                console.error(err);
            }
            ClickHandler(_url, _target, e);
        });
        this.pushLink.on('click', function (e) {
            e.preventDefault();

            var $this = $(this),
                label = $this.closest('.a-navigation__menu__item').children().first().text(),
                _url = $this.attr('href'),
                _internal = $this.attr('data-internal'),
                _target = $this.attr('target');

            try {
                $(this).Tagging({
                    trigger: this,
                    event: 'CLICK',
                    args: {
                        libelle_event: forceSegments('header::menu' + '::' + $this.TaggingStringCheck(label) + '_push_en_ce_moment::' + tc_vars.xiti_xtpage),
                        page_clicked: tc_vars.xiti_xtpage,
                        click_type: isExternal(_internal),
                        xiti_xtn2: tc_vars.xiti_xtn2,
                    },
                });
            } catch (err) {
                console.error(err);
            }
            ClickHandler(_url, _target, e);
        });
    },
};

/**
 * init Header tracking componant
 */
(function ($) {
    var headertracking = new HeaderTracking();
    headertracking.init();
})(window.jQuery);

(function ($) {
    $(document).on('mousedown click', '.relatednews .o-containerlist  a[href]', function (e) {
        e.preventDefault();
        var isEvent,
            $this = $(this),
            _url = $this.attr('href'),
            _internal = $this.attr('data-internal'),
            _target = $this.attr('target');

        if (e.type == 'mousedown') {
            isEvent = function () {
                return e.which == 1 || e.which == 2;
            };
        } else if (e.which == 13) {
            isEvent = function () {
                return e.which == 13;
            };
        } else {
            //touchstart
            isEvent = function () {
                return e.which == 0;
            };
        }
        if (e.type == 'click' && $(window).width() >= 992) {
            isEvent = function () {
                return true;
            };
        }
        if (isEvent()) {
            var dataTaggingSectionTitle = $this.TaggingStringCheck($this.closest('[data-tagging-push]').find('.m-title').first().text());
            var dataTaggingTitle = $this.TaggingStringCheck($this.text());

            try {
                $(this).Tagging({
                    trigger: this,
                    event: 'CLICK',
                    args: {
                        libelle_event: forceSegments(tc_vars.xiti_xtpage + '::' + dataTaggingSectionTitle + '_' + dataTaggingTitle),
                        page_clicked: tc_vars.xiti_xtpage,
                        click_type: isExternal(_internal),
                        xiti_xtn2: tc_vars.xiti_xtn2,
                    },
                });
            } catch (err) {
                console.error(err);
            }
            ClickHandler(_url, _target, e);
        }
    });
})(window.jQuery);

(function ($) {
    $(document).on('click', '.o-herobanner__homepage .m-tiles__item a', function (e) {
        e.preventDefault();
        var $this = $(this);

        var _libelleEvent = '',
            _url = $this.attr('href'),
            _internal = $this.attr('data-internal'),
            _target = $this.attr('target');

        _libelleEvent = tc_vars.xiti_xtpage + '::tuile' + '::' + $this.TaggingStringCheck();

        try {
            $(this).Tagging({
                trigger: this,
                event: 'CLICK',
                args: {
                    libelle_event: forceSegments(_libelleEvent),
                    page_clicked: tc_vars.xiti_xtpage,
                    click_type: isExternal(_internal),
                    xiti_xtn2: tc_vars.xiti_xtn2,
                },
            });
        } catch (err) {
            console.error(err);
        }

        ClickHandler(_url, _target, e);
    });
})(window.jQuery);

(function ($) {
    $(document).on('mousedown', '#newslist a[href]', function (e) {
        e.preventDefault();
        var isEvent,
            $this = $(this),
            _url = $this.attr('href'),
            _target = $this.attr('target');

        if (e.type == 'mousedown') {
            isEvent = function () {
                return e.which == 1 || e.which == 2;
            };
        } else if (e.which == 13) {
            isEvent = function () {
                return e.which == 13;
            };
        } else {
            //touchstart
            isEvent = function () {
                return e.which == 0;
            };
        }
        if (isEvent()) {
            var dataTaggingTitle = $this.TaggingStringCheck($this.find('p').text());
            var typeLabelAttr = $this.prev('.m-container__subtitle').attr('data-type');
            var typeLabel = $this.TaggingStringCheck(typeLabelAttr);
            var libelle_event;

            if (typeLabelAttr !== undefined && typeLabel) {
                libelle_event = tc_vars.xiti_xtpage + '::' + typeLabel + '::' + dataTaggingTitle;
            } else {
                libelle_event = tc_vars.xiti_xtpage + '::' + dataTaggingTitle;
            }

            try {
                $(this).Tagging({
                    trigger: this,
                    event: 'CLICK',
                    args: {
                        libelle_event: forceSegments(libelle_event),
                        page_clicked: tc_vars.xiti_xtpage,
                        click_type: 'navigation',
                        xiti_xtn2: tc_vars.xiti_xtn2,
                    },
                });
            } catch (err) {
                console.error(err);
            }
            ClickHandler(_url, _target, e);
        }
    });
    $(document).on('click', '.o-containerlist a[href]', function (e) {
        //e.preventDefault();
    });
})(window.jQuery);

(function ($) {
    var illustratedContainer = $('.js-illustratedcontainer');
    var relatedSolutions = $('.row.relatedsolutions');

    //list each illustratedcontainer
    illustratedContainer.each(function () {
        var _campaignId = $(this).attr('data-idcampaign');

        if (_campaignId !== undefined) {
            //list buttons
            $(this)
                .find('.m-button')
                .each(function (index) {
                    var $this = $(this),
                        _crea = $this.TaggingStringCheck(),
                        _link = $this.find('a').attr('href');
                    (_target = $this.find('a').attr('target')), (_index = index + 1);
                    
                    $this.on('click', function (e) {
                        try {
                            tc_events_global(this, 'ad_click', {impression:[{
                                campaignId: '[' + _campaignId + ']',
                                creation: '[' + _crea + ']',
                                variant: '[' + tc_vars.xiti_xtpage + ']',
                                format: '[conteneur_illustre]',
                                advertiserId: '[' + _index + ']',
                                url: '[' + _link + ']',
                            }]});
                        } catch (err) {
                            console.error(err);
                        }
                        ClickHandler(_link, _target, e);
                    });
                });
        }
    });

    relatedSolutions.each(function (i) {
        var push = $(this).find('.js-pushteaser');

        if (push.length > 0) {
            $(push).each(function (index) {
                var _campaignId = $(this).attr('data-idcampaign');
                var $this = $(this);

                if (_campaignId !== undefined) {
                    var _crea = $this.find('h3').TaggingStringCheck(),
                        _link = $this.find('a').attr('href'),
                        _sectionTitle = $this.TaggingStringCheck($this.closest('[data-tagging-push]').find('.m-title').text()),
                        _target = $this.attr('target'),
                        _index = index + 1;

                    $this.on('click', function (e) {
                        try {
                            tc_events_global(this, 'ad_click', {impression:[{
                                campaignId: '[' + _campaignId + ']',
                                creation: '[' + _crea + ']',
                                variant: '[' + tc_vars.xiti_xtpage + ']',
                                format: '[solution_associees]',
                                advertiserId: '[' + _index + ']',
                                url: '[' + _link + ']',
                            }]});
                        } catch (err) {
                            console.error(err);
                        }
                        ClickHandler(_link, _target, e);
                    });
                }
            });
        }
    });

    var visibleOnScreen = function (el) {
        var $window = $(window),
            windowHeight = $window.height(),
            docViewTop = $window.scrollTop() + windowHeight * 0.07,
            docViewBottom = $window.scrollTop() + windowHeight * 0.7,
            elemTop = el.offset().top;

        return elemTop > docViewTop && elemTop < docViewBottom;
    };

    /*
     * Trigger tracking print on first scroll in page
     */
    $(document).on('mousewheel scroll DOMMouseScroll touchmove keydown', function () {
        var trackingprint = $('head').attr('data-tracking');

        relatedSolutions.each(function (i) {
            var $this = $(this);
            var _tag = {};
            var push = $this.find('.js-pushteaser');
            var _format = $this.TaggingStringCheck($this.find('[data-tagging-push]').find('.m-title').text());

            if (push.length > 0) {
                _tag.impression = [];
                var isPrinted = $(this).attr('is-printed');
                if (trackingprint !== undefined && visibleOnScreen($(this)) && isPrinted === undefined) {
                    $(this).attr('is-printed', 'true');
                    push.each(function (index) {
                        var $this = $(this);
                        var _creation = $this.find('h3').TaggingStringCheck();
                        var _url = $this.find('a').attr('href');
                        var _campaignId = $this.attr('data-idcampaign');
                        var _index = index + 1;

                        if (_campaignId !== undefined && _url !== undefined && _format !== undefined && _creation !== undefined) {
                            try {
                                tc_events_global(this,"ad_impression",
                                    {impression:[{
                                        format: '[solution_associees]',
                                        variant: '[' + tc_vars.xiti_xtpage + ']',
                                        creation: '[' + _creation + ']',
                                        campaignId: '[' + _campaignId + ']',
                                        advertiserId: '[' + _index + ']',
                                        url: '[' + _url + ']',
                                    }]}
                                );
                            } catch (err) {
                                console.error(err);
                            }
                        }
                    });
                }
            }
        });

        illustratedContainer.each(function (index) {
            var _campaignId = $(this).attr('data-idcampaign');
            var buttons = $(this).find('.button');
            var isPrinted = $(this).attr('is-printed');
            var _tag = {};

            if (buttons.length > 0 && trackingprint !== undefined && visibleOnScreen($(this)) && isPrinted === undefined) {
                $(this).attr('is-printed', 'true');
                _tag.impression = [];

                $(this)
                    .find('.button')
                    .each(function (index) {
                        var $this = $(this);
                        var _creation = $this.TaggingStringCheck();
                        var _url = $this.find('a').attr('href');
                        var _index = index + 1;

                        if (_campaignId !== undefined && _url !== undefined && _creation !== undefined) {
                            try {
                                tc_events_global(this,"ad_impression",
                                    {impression:[{
                                        format: '[conteneur_illustre]',
                                        variant: '[' + tc_vars.xiti_xtpage + ']',
                                        creation: '[' + _creation + ']',
                                        campaignId: '[' + _campaignId + ']',
                                        advertiserId: '[' + _index + ']',
                                        url: '[' + _url + ']',
                                    }]}
                                );
                            } catch (err) {
                                console.error(err);
                            }
                        }
                    });
            }
        });
    });
})(window.jQuery);

(function ($) {
    $(document).on('mousedown', '.o-featurearticle a[href]', function (e) {
        e.preventDefault();
        var isEvent,
            $this = $(this),
            _url = $this.attr('href'),
            _target = $this.attr('target');

        if (e.type == 'mousedown') {
            isEvent = function () {
                return e.which == 1 || e.which == 2;
            };
        } else if (e.which == 13) {
            isEvent = function () {
                return e.which == 13;
            };
        } else {
            //touchstart
            isEvent = function () {
                return e.which == 0;
            };
        }
        if (isEvent()) {
            var dataTaggingTitle = $this.TaggingStringCheck($this.find('h3').text());
            var typeLabelAttr = $this.prev('.m-container__subtitle').text();
            var typeLabel = $this.TaggingStringCheck(typeLabelAttr);
            var libelle_event;

            console.log("type : ", typeLabelAttr);

            if (typeLabelAttr !== undefined && typeLabel) {
                libelle_event = tc_vars.xiti_xtpage + '::a_la_une::' + typeLabel + '_' + dataTaggingTitle;
            } else {
                libelle_event = tc_vars.xiti_xtpage + '::a_la_une::' + dataTaggingTitle;
            }

            try {
                $(this).Tagging({
                    trigger: this,
                    event: 'CLICK',
                    args: {
                        libelle_event: forceSegments(libelle_event),
                        page_clicked: tc_vars.xiti_xtpage,
                        click_type: 'navigation',
                        xiti_xtn2: tc_vars.xiti_xtn2,
                    },
                });
            } catch (err) {
                console.error(err);
            }
            ClickHandler(_url, _target, e);
        }
    });
    $(document).on('click', '.o-containerlist a[href]:not(.no-tracking)', function (e) {
        e.preventDefault();
    });
})(window.jQuery);

(function ($) {
    $(document).on('click', '.m-clicktocall__number', function (e) {
        var $this = $(this);
        
        try {
            $this.Tagging({
                trigger: this,
                event: 'CLICK',
                args: {
                    libelle_event: tc_vars.xiti_xtpage + '::button::click_to_call',
                    page_clicked: tc_vars.xiti_xtpage,
                    click_type: 'exit',
                    xiti_xtn2: tc_vars.xiti_xtn2,
                },
            });
        } catch (err) {
            console.error(err);
        }
    });
})(window.jQuery);

(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var isObject = require('../internals/is-object');

module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  } return it;
};

},{"../internals/is-object":25}],2:[function(require,module,exports){
var toIndexedObject = require('../internals/to-indexed-object');
var toLength = require('../internals/to-length');
var toAbsoluteIndex = require('../internals/to-absolute-index');

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};

},{"../internals/to-absolute-index":45,"../internals/to-indexed-object":46,"../internals/to-length":48}],3:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],4:[function(require,module,exports){
var has = require('../internals/has');
var ownKeys = require('../internals/own-keys');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var definePropertyModule = require('../internals/object-define-property');

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};

},{"../internals/has":18,"../internals/object-define-property":31,"../internals/object-get-own-property-descriptor":32,"../internals/own-keys":37}],5:[function(require,module,exports){
var wellKnownSymbol = require('../internals/well-known-symbol');

var MATCH = wellKnownSymbol('match');

module.exports = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (error2) { /* empty */ }
  } return false;
};

},{"../internals/well-known-symbol":52}],6:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var definePropertyModule = require('../internals/object-define-property');
var createPropertyDescriptor = require('../internals/create-property-descriptor');

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"../internals/create-property-descriptor":7,"../internals/descriptors":8,"../internals/object-define-property":31}],7:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],8:[function(require,module,exports){
var fails = require('../internals/fails');

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});

},{"../internals/fails":15}],9:[function(require,module,exports){
var global = require('../internals/global');
var isObject = require('../internals/is-object');

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};

},{"../internals/global":17,"../internals/is-object":25}],10:[function(require,module,exports){
var classof = require('../internals/classof-raw');
var global = require('../internals/global');

module.exports = classof(global.process) == 'process';

},{"../internals/classof-raw":3,"../internals/global":17}],11:[function(require,module,exports){
var getBuiltIn = require('../internals/get-built-in');

module.exports = getBuiltIn('navigator', 'userAgent') || '';

},{"../internals/get-built-in":16}],12:[function(require,module,exports){
var global = require('../internals/global');
var userAgent = require('../internals/engine-user-agent');

var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

module.exports = version && +version;

},{"../internals/engine-user-agent":11,"../internals/global":17}],13:[function(require,module,exports){
// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];

},{}],14:[function(require,module,exports){
var global = require('../internals/global');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefine = require('../internals/redefine');
var setGlobal = require('../internals/set-global');
var copyConstructorProperties = require('../internals/copy-constructor-properties');
var isForced = require('../internals/is-forced');

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};

},{"../internals/copy-constructor-properties":4,"../internals/create-non-enumerable-property":6,"../internals/global":17,"../internals/is-forced":24,"../internals/object-get-own-property-descriptor":32,"../internals/redefine":39,"../internals/set-global":41}],15:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

},{}],16:[function(require,module,exports){
var path = require('../internals/path');
var global = require('../internals/global');

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};

},{"../internals/global":17,"../internals/path":38}],17:[function(require,module,exports){
(function (global){(function (){
var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof global == 'object' && global) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],18:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],19:[function(require,module,exports){
module.exports = {};

},{}],20:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var fails = require('../internals/fails');
var createElement = require('../internals/document-create-element');

// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- requied for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});

},{"../internals/descriptors":8,"../internals/document-create-element":9,"../internals/fails":15}],21:[function(require,module,exports){
var fails = require('../internals/fails');
var classof = require('../internals/classof-raw');

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;

},{"../internals/classof-raw":3,"../internals/fails":15}],22:[function(require,module,exports){
var store = require('../internals/shared-store');

var functionToString = Function.toString;

// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof store.inspectSource != 'function') {
  store.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

module.exports = store.inspectSource;

},{"../internals/shared-store":43}],23:[function(require,module,exports){
var NATIVE_WEAK_MAP = require('../internals/native-weak-map');
var global = require('../internals/global');
var isObject = require('../internals/is-object');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var objectHas = require('../internals/has');
var shared = require('../internals/shared-store');
var sharedKey = require('../internals/shared-key');
var hiddenKeys = require('../internals/hidden-keys');

var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    metadata.facade = it;
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};

},{"../internals/create-non-enumerable-property":6,"../internals/global":17,"../internals/has":18,"../internals/hidden-keys":19,"../internals/is-object":25,"../internals/native-weak-map":29,"../internals/shared-key":42,"../internals/shared-store":43}],24:[function(require,module,exports){
var fails = require('../internals/fails');

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : typeof detection == 'function' ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;

},{"../internals/fails":15}],25:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],26:[function(require,module,exports){
module.exports = false;

},{}],27:[function(require,module,exports){
var isObject = require('../internals/is-object');
var classof = require('../internals/classof-raw');
var wellKnownSymbol = require('../internals/well-known-symbol');

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};

},{"../internals/classof-raw":3,"../internals/is-object":25,"../internals/well-known-symbol":52}],28:[function(require,module,exports){
var IS_NODE = require('../internals/engine-is-node');
var V8_VERSION = require('../internals/engine-v8-version');
var fails = require('../internals/fails');

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  // eslint-disable-next-line es/no-symbol -- required for testing
  return !Symbol.sham &&
    // Chrome 38 Symbol has incorrect toString conversion
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    (IS_NODE ? V8_VERSION === 38 : V8_VERSION > 37 && V8_VERSION < 41);
});

},{"../internals/engine-is-node":10,"../internals/engine-v8-version":12,"../internals/fails":15}],29:[function(require,module,exports){
var global = require('../internals/global');
var inspectSource = require('../internals/inspect-source');

var WeakMap = global.WeakMap;

module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));

},{"../internals/global":17,"../internals/inspect-source":22}],30:[function(require,module,exports){
var isRegExp = require('../internals/is-regexp');

module.exports = function (it) {
  if (isRegExp(it)) {
    throw TypeError("The method doesn't accept regular expressions");
  } return it;
};

},{"../internals/is-regexp":27}],31:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var IE8_DOM_DEFINE = require('../internals/ie8-dom-define');
var anObject = require('../internals/an-object');
var toPrimitive = require('../internals/to-primitive');

// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"../internals/an-object":1,"../internals/descriptors":8,"../internals/ie8-dom-define":20,"../internals/to-primitive":49}],32:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var toIndexedObject = require('../internals/to-indexed-object');
var toPrimitive = require('../internals/to-primitive');
var has = require('../internals/has');
var IE8_DOM_DEFINE = require('../internals/ie8-dom-define');

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};

},{"../internals/create-property-descriptor":7,"../internals/descriptors":8,"../internals/has":18,"../internals/ie8-dom-define":20,"../internals/object-property-is-enumerable":36,"../internals/to-indexed-object":46,"../internals/to-primitive":49}],33:[function(require,module,exports){
var internalObjectKeys = require('../internals/object-keys-internal');
var enumBugKeys = require('../internals/enum-bug-keys');

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};

},{"../internals/enum-bug-keys":13,"../internals/object-keys-internal":35}],34:[function(require,module,exports){
// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;

},{}],35:[function(require,module,exports){
var has = require('../internals/has');
var toIndexedObject = require('../internals/to-indexed-object');
var indexOf = require('../internals/array-includes').indexOf;
var hiddenKeys = require('../internals/hidden-keys');

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};

},{"../internals/array-includes":2,"../internals/has":18,"../internals/hidden-keys":19,"../internals/to-indexed-object":46}],36:[function(require,module,exports){
'use strict';
var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;

},{}],37:[function(require,module,exports){
var getBuiltIn = require('../internals/get-built-in');
var getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');
var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
var anObject = require('../internals/an-object');

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};

},{"../internals/an-object":1,"../internals/get-built-in":16,"../internals/object-get-own-property-names":33,"../internals/object-get-own-property-symbols":34}],38:[function(require,module,exports){
var global = require('../internals/global');

module.exports = global;

},{"../internals/global":17}],39:[function(require,module,exports){
var global = require('../internals/global');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var has = require('../internals/has');
var setGlobal = require('../internals/set-global');
var inspectSource = require('../internals/inspect-source');
var InternalStateModule = require('../internals/internal-state');

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  var state;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) {
      createNonEnumerableProperty(value, 'name', key);
    }
    state = enforceInternalState(value);
    if (!state.source) {
      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});

},{"../internals/create-non-enumerable-property":6,"../internals/global":17,"../internals/has":18,"../internals/inspect-source":22,"../internals/internal-state":23,"../internals/set-global":41}],40:[function(require,module,exports){
// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};

},{}],41:[function(require,module,exports){
var global = require('../internals/global');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');

module.exports = function (key, value) {
  try {
    createNonEnumerableProperty(global, key, value);
  } catch (error) {
    global[key] = value;
  } return value;
};

},{"../internals/create-non-enumerable-property":6,"../internals/global":17}],42:[function(require,module,exports){
var shared = require('../internals/shared');
var uid = require('../internals/uid');

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};

},{"../internals/shared":44,"../internals/uid":50}],43:[function(require,module,exports){
var global = require('../internals/global');
var setGlobal = require('../internals/set-global');

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;

},{"../internals/global":17,"../internals/set-global":41}],44:[function(require,module,exports){
var IS_PURE = require('../internals/is-pure');
var store = require('../internals/shared-store');

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.10.0',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: ' 2021 Denis Pushkarev (zloirock.ru)'
});

},{"../internals/is-pure":26,"../internals/shared-store":43}],45:[function(require,module,exports){
var toInteger = require('../internals/to-integer');

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};

},{"../internals/to-integer":47}],46:[function(require,module,exports){
// toObject with fallback for non-array-like ES3 strings
var IndexedObject = require('../internals/indexed-object');
var requireObjectCoercible = require('../internals/require-object-coercible');

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};

},{"../internals/indexed-object":21,"../internals/require-object-coercible":40}],47:[function(require,module,exports){
var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.es/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};

},{}],48:[function(require,module,exports){
var toInteger = require('../internals/to-integer');

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

},{"../internals/to-integer":47}],49:[function(require,module,exports){
var isObject = require('../internals/is-object');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"../internals/is-object":25}],50:[function(require,module,exports){
var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};

},{}],51:[function(require,module,exports){
/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = require('../internals/native-symbol');

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';

},{"../internals/native-symbol":28}],52:[function(require,module,exports){
var global = require('../internals/global');
var shared = require('../internals/shared');
var has = require('../internals/has');
var uid = require('../internals/uid');
var NATIVE_SYMBOL = require('../internals/native-symbol');
var USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    if (NATIVE_SYMBOL && has(Symbol, name)) {
      WellKnownSymbolsStore[name] = Symbol[name];
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
    }
  } return WellKnownSymbolsStore[name];
};

},{"../internals/global":17,"../internals/has":18,"../internals/native-symbol":28,"../internals/shared":44,"../internals/uid":50,"../internals/use-symbol-as-uid":51}],53:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var toLength = require('../internals/to-length');
var notARegExp = require('../internals/not-a-regexp');
var requireObjectCoercible = require('../internals/require-object-coercible');
var correctIsRegExpLogic = require('../internals/correct-is-regexp-logic');
var IS_PURE = require('../internals/is-pure');

// eslint-disable-next-line es/no-string-prototype-startswith -- safe
var $startsWith = ''.startsWith;
var min = Math.min;

var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('startsWith');
// https://github.com/zloirock/core-js/pull/702
var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {
  var descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith');
  return descriptor && !descriptor.writable;
}();

// `String.prototype.startsWith` method
// https://tc39.es/ecma262/#sec-string.prototype.startswith
$({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = String(requireObjectCoercible(this));
    notARegExp(searchString);
    var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});

},{"../internals/correct-is-regexp-logic":5,"../internals/export":14,"../internals/is-pure":26,"../internals/not-a-regexp":30,"../internals/object-get-own-property-descriptor":32,"../internals/require-object-coercible":40,"../internals/to-length":48}],54:[function(require,module,exports){
var utils = require('../librairies/utils.js');

function Carousel() {}

Carousel.prototype = {
    selectors: {
        slider: $('.owl-carousel').not('.owl-carousel-opc'),
        sliderOpc: $('.owl-carousel-opc'),
        slidersummary: $('[data-summary-carousel]'),
        window: $(window),
        firstActiveSlide: undefined,
    },

    toggleClick: function (elem) {
        $(elem).find('.js-has-link a').toggleClass('disableClick');
    },

    initCarousel: function () {
        var that = this;
        this.selectors.slider.each(function () {
            var isSummary = $(this).attr('data-summary-carousel') !== undefined;
            $(this).owlCarousel({
                loop: false,
                nav: true,
                dots: true,
                dotsClass: 'a-dots',
                dotClass: 'a-dots__item',
                mergeFit: false,
                merge: isSummary ? true : false,
                rewind: false,
                navText: [
                    '<span class="sr-only"></span><svg viewBox="0 0 24 24" class="a-icon--s u-svg-color--blue" aria-hidden="true" focusable="false"><use xlink:href="/etc.clientlibs/labanquepostale/commons/clientlibs/base/resources/svg-icons.svg#ic-interface-arrow-left"></use></svg>',
                    '<span class="sr-only"></span><svg viewBox="0 0 24 24" class="a-icon--s u-svg-color--blue" aria-hidden="true" focusable="false"><use xlink:href="/etc.clientlibs/labanquepostale/commons/clientlibs/base/resources/svg-icons.svg#ic-interface-arrow-right"></use></svg>',
                ],
                navContainerClass: isSummary ? 'm-carousel__nav--summary' : 'm-carousel__nav',
                navClass: ['m-carousel__nav__prev', 'm-carousel__nav__next'],
                responsive: {
                    0: {
                        items: isSummary ? 2 : 1,
                        dotsEach: false,
                    },
                    580: {
                        items: 2,
                        dotsEach: true,
                    },
                    768: {
                        items: isSummary ? 3 : 2,
                        dotsEach: true,
                    },
                },
                onInitialized: function (slider) {
                    var nav = slider.currentTarget.children[1];
                    var dots = slider.currentTarget.children[2];

                    var drag = false;
                    that.initAccessibility(slider, drag);

                    $(nav).append(dots);
                },
                onDrag: function (slider) {
                    that.toggleClick(slider.currentTarget);
                    if (slider.item.index === slider.item.count) {
                        that.selectors.slider.owlCarousel({
                            loop: false,
                        });
                    }
                },
                onDragged: function (slider) {
                    that.toggleClick(slider.currentTarget);
                    var drag = true;
                    that.accessibility(slider, drag, null);
                },

                onTranslated: function (slider) {
                    var drag = true;
                    var prevIndex = $(slider.currentTarget).data('lbp-transalte-index'),
                        direction = prevIndex > slider.page.index ? 'left' : 'right';

                    that.accessibility(slider, drag, direction);
                    that.selectors.firstActiveSlide = $(slider.currentTarget).find('.owl-item.active').first();
                },
            });
            $(this).on('change.owl.carousel', function (event) {
                //set current index before change so slide direction can be calculated
                $(this).data('lbp-transalte-index', event.page.index);
            });
        });
    },
    initOpcCarousel: function () {
        var that = this;
        this.selectors.sliderOpc.each(function () {
            $(this).owlCarousel({
                stagePadding: 60,
                loop: false,
                nav: false,
                dots: false,
                autoWidth: true,
                mergeFit: true,
                rewind: false,
                startPosition: 0,
            });
        });
    },
    /** 
    /* Set accessibility attribute on dots navigation nodes
    /* @param {Slider} Object carousel
    /* @param {drag} boolean
    */
    initAccessibility: function (slider, drag) {
        var arrows = $(slider.currentTarget.children[1]).children('button');
        var dots = $(slider.currentTarget).find('.a-dots__item');
        var title = $(slider.currentTarget).closest('.row').find('h2').text();
        var labelBtnPrev = 'Panneau prcdent - '.concat(title);
        var labelBtnNext = 'Panneau suivant - '.concat(title);

        arrows.first().children('span').text(labelBtnPrev);
        arrows.last().children('span').text(labelBtnNext);

        $(dots).each(function () {
            var index = $(this).index() + 1;
            var isActive = $(this).hasClass('active') === true;

            $(this).append('<span class="sr-only"> Panneau ' + index + ' - ' + title + '</span>');

            if (!isActive) {
                $(this).removeAttr('aria-current');
            } else {
                $(this).attr('aria-current', 'true');
            }
        });
        this.setPanelsAccessibilityAttr(slider.relatedTarget._items, arrows, drag, null);
    },
    /** 
    /* Set accessibility attribute on dots navigation nodes
    /* @param {Slider} Object carousel
    /* @param {drag} boolean
    /* @param {direction} string 'left' or 'right'
    */
    accessibility: function (slider, drag, direction) {
        var arrows = $(slider.currentTarget.children[1]).children('button');
        var dots = $(slider.currentTarget).find('.a-dots__item');

        $(dots).each(function () {
            var isActive = $(this).hasClass('active') === true;

            if (!isActive) {
                $(this).removeAttr('aria-current');
            } else {
                $(this).attr('aria-current', 'true');
            }
        });
        this.setPanelsAccessibilityAttr(slider.relatedTarget._items, arrows, drag, direction);
    },
    setPanelsAccessibilityAttr(items, arrows, drag, direction) {
        var actives = [];

        $(items).each(function () {
            var isActive = $(this).hasClass('active') === true;

            $(this).attr({
                'tabindex': '-1',
                'aria-hidden': isActive ? 'false' : 'true',
            });
            if (!isActive) {
                $(this).attr('tabindex', '-1');
                $(this).find('a').attr('tabindex', '-1');
                $(this).find('button').attr('tabindex', '-1');
            } else {
                actives.push($(this));
                $(this).removeAttr('tabindex');
                $(this).find('a').removeAttr('tabindex');
                $(this).find('button').removeAttr('tabindex');
            }
            // On drag
            if (drag === true && isActive) {
                arrows.each(function () {
                    $(this).removeClass('is--focused');
                });
            } else {
                arrows.each(function () {
                    $(this).removeAttr('role');
                });
            }
        });
        var index = 0;
        if (actives.length > 0 && direction === 'right') {
            index = actives.length - 1;
        }

        actives[index].find('a').focus();
        actives[index].find('a').addClass('is--focused');
    },
    checkResponsiveWidth: function () {
        var that = this;
        var dataWidth = that.selectors.slider.attr('data-carousel-ipad');
        var minwidth = dataWidth !== undefined ? 992 : 768;

        if (that.selectors.window.width() >= minwidth) {
            that.selectors.slider.owlCarousel('destroy');
        } else {
            this.initCarousel();
        }
    },
    event: function () {
        var that = this;

        that.selectors.window.resize(function () {
            utils.waitForFinalEvent(
                function () {
                    that.checkResponsiveWidth();
                },
                500,
                'resizeCarousels'
            );
        });
    },
    init: function () {
        this.checkResponsiveWidth();
        this.event();
    },
};
/**
 * init Carousel
 */
(function ($) {
    if ($('.owl-carousel').length) {
        var carousel = new Carousel();
        window.addEventListener('load', function (event) {
            carousel.init();
        });
    }
})(window.jQuery);
module.exports = Carousel;

},{"../librairies/utils.js":67}],55:[function(require,module,exports){
function Currencyconverter() {}

Currencyconverter.prototype = {
    url: $('.o-currencyconverter').attr('data-path'),
    errorMsg: {
        errorEmpty: 'Veuillez complter ce champ',
        errorInput: 'Veuillez saisir un montant valide',
        errorCurrency: 'Veuillez saisir une devise valide',
    },
    selectors: {
        converter: '.o-currencyconverter',
        inputValue: '#converterAmount',
        filterCurrencyFrom: '#converterCurrencyFromFilter',
        filterCurrencyTo: '#converterCurrencyToFilter',
        inputCurrencyTo: '#converterCurrencyTo',
        inputCurrencyFrom: '#converterCurrencyFrom',
        invertCurrencyTrigger: '#invertCurrencyTrigger',
        currencyconverterButton: '#currencyconverterButton',
        inputFilters: '.o-currencyconverter .m-filter',
        errorField: '.o-currencyconverter__content__input__error',
        invert: '.o-currencyconverter__content__toggle',
        resultBloc: '.o-currencyconverter__result',
        result: {
            sourceAmount: '[data-currencyconverter-result-sourceAmount]',
            destinationAmount: '[data-currencyconverter-result-destinationAmount]',
            conversionRate: '[data-currencyconverter-result-conversionRate]',
            markUpRateApplied: '[data-currencyconverter-result-markUpRateApplied]',
            visa: '[data-currencyconverter-result-visa]',
            date: '[data-currencyconverter-result-date]',
        },
        errorBloc: '.o-currencyconverter__invalide',
        errorFilter: '.m-filter__error',
    },
    filterInput: null,

    init: function () {
        var _that = this;
        _that.errorMsg = {
            errorEmpty: $(this.selectors.converter).data('error-empty'),
            errorInput: $(this.selectors.converter).data('error-input'),
            errorCurrency: $(this.selectors.converter).data('error-currency'),
        };
        this.events();
        var FilterInput = require('../components/filter.js');

        this.filterInput = new FilterInput('.o-currencyconverter .m-filter');
        this.filterInput.init();

        //reset error callback of filter to change it's text message // _self is the input of the filter
        this.filterInput.onInvalidCallback = function (_self) {
            //in this context, this refer to the m-filter element.
            var errorEl = _self.parent().find(_that.selectors.errorFilter + ' p');

            if (_self.val().length === 0 || _self.val() === '') {
                errorEl.text(_that.errorMsg.errorEmpty);
            } else {
                errorEl.text(_that.errorMsg.errorCurrency);
            }
        };
    },
    events: function () {
        var _that = this;

        $(document).on('click', _that.selectors.invert, function (e) {
            //e.preventDefault();
            _that.invertCurrency();
        });

        // get result button
        $(document).on('click', _that.selectors.currencyconverterButton, function (e) {
            _that.getResult(e);
        });

        //check selected value on blur from input
        $(document).on('blur keyup', _that.selectors.inputValue, function () {
            if (!_that.isPriceInputValid($(this))) {
                return;
            }
        });
    },
    /**
     * getResult :
     */
    getResult: function (e) {
        e.preventDefault();
        this.hideResult();
        this.hideErrorResult();

        var _that = this,
            valueToConvertInput = $(_that.selectors.inputValue);

        var valueToConvert = valueToConvertInput.val();
        var deviseFrom = $(_that.selectors.filterCurrencyFrom + ' select').val();
        var deviseTo = $(_that.selectors.filterCurrencyTo + ' select').val();

        var _param = {
            'fromAmount': valueToConvert,
            'fromCurrency': deviseFrom,
            'toCurrency': deviseTo,
        };
        if ($(_that.selectors.inputValue).val().length === 0) {
            _that.showInputError(this.errorMsg.errorInput);
        }
        if ($(_that.selectors.converter).find('div[class*="error"]:visible').length > 0) {
            _that.setErrorFocus();
        }
        if ($(_that.selectors.converter).find('div[class*="error"]:visible').length === 0 && $(_that.selectors.inputValue).val().length > 0) {
            $.ajax({
                type: 'POST',
                url: _that.url,
                data: JSON.stringify(_param),
                contentType: 'application/json; charset=utf-8',
                success: function (data) {
                    $(_that.selectors.result.sourceAmount).text(data.fromAmount);
                    $(_that.selectors.result.destinationAmount).text(data.toAmountWithVisaRate);
                    $(_that.selectors.result.conversionRate).text(data.fxRateVisa);
                    $(_that.selectors.result.markUpRateApplied).text(data.benchmarkFxRate);
                    $(_that.selectors.result.visa).text(data.markupWithoutAdditionalFee);
                    $(_that.selectors.result.date).text(data.date);
                    _that.showResult();
                },
                error: function () {
                    _that.showError();
                },
            });
        }
    },
    /**
     * isPriceInputValid :
     *  return true if input content is valid
     */
    isPriceInputValid: function (_element) {
        var _isValid = true;

        if (_element.val().length === 0) {
            _isValid = false;
            this.showInputError(this.errorMsg.errorEmpty);
        } else {
            $('.o-currencyconverter__content__input__error').hide();
            this.hideInputError();
        }
        return _isValid;
    },
    showInputError: function (ErrorMsg) {
        var errorMessageElement = $('<p class="a-text--small">' + ErrorMsg + '</p>');

        if ($(this.selectors.errorField).children('p').length === 0) {
            $(this.selectors.errorField).append(errorMessageElement);
        }
        $(this.selectors.errorField).addClass('js-error').css('display', 'flex');
        $(this.selectors.errorField).siblings('input').attr('aria-describedby', $(this.selectors.errorField).attr('id')).attr('aria-invalid', 'true');
    },
    hideInputError: function () {
        $(this.selectors.errorField).children('p').remove();
        $(this.selectors.errorField).removeClass('js-error').hide();
        $(this.selectors.errorField).siblings('input').attr('aria-describedby', $(this.selectors.errorField).siblings('label').attr('id')).removeAttr('aria-invalid', 'true');
    },
    setErrorFocus: function () {
        var firstError = $(this.selectors.converter).find('.js-error').first();
        firstError.attr('aria-live', 'off');
        firstError.siblings('input').focus();
    },
    showResult: function (_data) {
        for (var prop in _data) {
            if (_data.hasOwnProperty(prop)) {
                $('[data-currencyconverter-result-' + prop + ']').text(_data[prop]);
            }
        }
        $(this.selectors.resultBloc).addClass('o-currencyconverter__result--visible');
        $(this.selectors.resultBloc).attr('aria-hidden', 'false');
    },
    hideResult: function () {
        $(this.selectors.resultBloc).removeClass('o-currencyconverter__invalide--visible');
        $(this.selectors.resultBloc).attr('aria-hidden', 'true');
    },
    showError: function () {
        $(this.selectors.resultBloc).removeClass('o-currencyconverter__result--visible');
        $(this.selectors.errorBloc).addClass('o-currencyconverter__invalide--visible');
        $(this.selectors.errorBloc).attr('aria-hidden', 'false');
    },
    hideErrorResult: function () {
        $(this.selectors.errorBloc).removeClass('o-currencyconverter__invalide--visible');
        $(this.selectors.errorBloc).attr('aria-hidden', 'true');
    },

    /**
     * invertCurrency : invert devices value in currency fields
     */
    invertCurrency: function () {
        var fromValue = $('#converterCurrencyFromSelect').val(),
            toValue = $('#converterCurrencyToSelect').val();

        $('#converterCurrencyToSelect').val(fromValue).change();
        $('#converterCurrencyFromSelect').val(toValue).change();
    },
};

/**
 * init Currencyconverter
 */
(function ($) {
    if ($('.o-currencyconverter').length) {
        var currencyconverter = new Currencyconverter();
        currencyconverter.init();
    }
})(window.jQuery);

},{"../components/filter.js":57}],56:[function(require,module,exports){
var utils = require('../librairies/utils.js');

function FilterNewslist() {}

FilterNewslist.prototype = {
    isCorp: false,
    selectors: {
        filter: $('[data-filters]'),
        years: $('#filterSelectYears'),
        themes: $('#filterSelectTheme'),
        tags: $('#filterSelectTags'),
        typologies: $('#filterSelectTypologies'),
        sort: $('[data-filter-sort]'),
        page: '',
        firstPage: false,
        featureArticle: $('.o-featurearticle'),
        pageTitle: $('[data-page-title]'),
        pagination: $('.o-pagination'),
    },
    waitTiming: 600,
    data: {},
    state: { year: '', theme: '', tags: [], typologies: [], sort: '' },
    targetUrl: {
        url: '',
        param: '',
    },

    init: function () {
        this.data = this.selectors.filter.data('filters');

        if ($('[data-corp]').length) {
            this.isCorp = true;
        }
        this.data.thematics = this.data.thematics.map(function (theme) {
            theme.id = theme.id.replace('%3A', ':');

            for (var key in theme.tags) {
                Object.defineProperty(theme.tags, key.replace('%3A', ':'), Object.getOwnPropertyDescriptor(theme.tags, key));
                delete theme.tags[key];
            }
            return theme;
        });

        this.populateSelectYears();
        this.populateSelectThemes();
        this.populateSelectTypos();
        this.parseUrl();
        this.setAccessibilityTitle();
        this.events();

        var inputTags = this.selectors.tags.children().length;
        if (this.isCorp && this.data.thematics[0].id !== undefined && inputTags === 0) {
            this.state.theme = this.data.thematics[0].id;
            this.setTheme();
        }
    },
    parseUrl: function () {
        var url = window.location.pathname,
            that = this;
        var filters = {
            year: url.match(/\.year-(.)\d*\./g),
            theme: url.match(/\.cat-[^.]*\./g),
            tags: url.match(/\.tags-[^.]*\./g),
            typologies: url.match(/\.typo-[^.]*\./g),
            sort: url.match(/\.sort-[^.]*\./g),
            page: url.match(/\.p-(.)\d*/g),
        };
        if (filters.year) {
            this.state.year = filters.year[0].substring(1, filters.year[0].length - 1).replace('year-', '');
            this.setYear();
        }
        if (filters.theme) {
            this.state.theme = filters.theme[0].substring(1, filters.theme[0].length - 1).replace('cat-', '');
            this.setTheme();
        }
        if (filters.page) {
            var pageNotFirst = filters.page.toString() === '.p-1.';
            if (!pageNotFirst) {
                this.selectors.page = filters.page;
            } else {
                this.selectors.firstPage = true;
            }
        }
        if (filters.typologies) {
            //parse typologies selectors
            this.state.typologies = filters.typologies[0]
                .substring(1, filters.typologies[0].length - 1)
                .replace('typo-', '')
                .split(',');
            this.setTypologies();
            this.setUrl();
        }
        if (filters.tags) {
            //parse tags selectors
            this.state.tags = filters.tags[0]
                .substring(1, filters.tags[0].length - 1)
                .replace('tags-', '')
                .split(',');

            //get theme matching the first tag
            var theme = this.data.thematics.filter(function (cat) {
                var hasTag = Object.keys(cat.tags).find(function (tag) {
                    if (tag === that.state.tags[0]) {
                        return tag;
                    }
                });
                if (hasTag !== undefined && hasTag.length > 0) {
                    return cat;
                }
            });

            if (theme[0] !== undefined && theme.length > 0) {
                //set matching  theme
                this.state.theme = theme[0].id;
                this.setTheme();
            }

            //reset tagslist as setTheme empty the state tags
            this.setTags();
            this.setUrl();
        }
        if (filters.sort) {
            this.state.sort = filters.sort[0].substring(1, filters.sort[0].length - 1).replace('sort-', '');
            this.setSort();
        }
    },

    setUrl: function (page) {
        var that = this;

        that.targetUrl = {
            url: $('[data-filter-target]').data('filter-target'),
            param: '',
        };

        if (that.selectors.years.val()) {
            that.targetUrl.param = that.targetUrl.param + '.year-' + that.selectors.years.val();
        }
        if (that.selectors.themes.val() && !this.isCorp) {
            that.targetUrl.param = that.targetUrl.param + '.cat-' + that.selectors.themes.val();
        }
        if (that.selectors.sort.is(':checked')) {
            var sort = 'desc';
            if ($('input[data-filter-sort]:checked').length) {
                sort = 'asc';
            }
            that.targetUrl.param = that.targetUrl.param + '.sort-' + sort;
        }

        var tags = $('[data-filter-tag-value]:checked');
        if (tags.length > 0) {
            that.targetUrl.param = that.targetUrl.param + '.tags-';

            tags.each(function (index) {
                var separator = ',';
                if (index === tags.length - 1) {
                    separator = '';
                }
                that.targetUrl.param = that.targetUrl.param + $(this).data('filter-tag-value') + separator;
            });
        }

        var typologies = $('[data-filter-typology-value]:checked');
        if (typologies.length > 0) {
            that.targetUrl.param = that.targetUrl.param + '.typo-';

            typologies.each(function (index) {
                var separator = ',';
                if (index === typologies.length - 1) {
                    separator = '';
                }
                that.targetUrl.param = that.targetUrl.param + $(this).data('filter-typology-value') + separator;
            });
        }
        if (that.selectors.page && page !== false && that.selectors.firstPage === false) {
            that.targetUrl.param = that.targetUrl.param + that.selectors.page;
        }
    },

    //Setters
    setYear: function () {
        this.selectors.years.val(this.state.year).trigger('change');
        this.setFiltersBadge();
    },
    setTheme: function () {
        this.selectors.themes.val(this.state.theme).trigger('change');

        this.selectors.themes
            .siblings('m-dropdown__label')
            .find('.a-radio__item[data-value="' + this.state.theme + '"]')
            .addClass('a-radio__item--is-active')
            .attr('aria-selected', 'true');
        this.populateSelectTags(this.state.theme);
    },
    setTags: function () {
        this.state.tags.forEach(function (tag) {
            var check = $('input[data-filter-tag-value="' + tag + '"]');

            if (check) {
                check.prop('checked', true);
            }
        });
        this.setTagsBadge();
        this.setFiltersBadge();
    },
    setTypologies: function () {
        this.state.typologies.forEach(function (typo) {
            var check = $('input[data-filter-typology-value="' + typo + '"]');
            if (check) {
                check.prop('checked', true);
            }
        });
        this.setTypologiesBadge();
        this.setFiltersBadge();
    },
    setSort: function () {
        if (this.state.sort === 'asc') {
            this.selectors.sort.prop('checked', true);
        } else {
            this.selectors.sort.prop('checked', false);
        }
    },
    resetFiltersBadge: function () {
        $('[data-badge-filter-number]').removeClass('a-badge--is-visible');
    },
    resetTagsBadge: function () {
        $('[data-filter-tag-number]').removeClass('a-badge--is-visible');
    },
    resetTypologiesBadge: function () {
        $('[data-filter-typology-number]').removeClass('a-badge--is-visible');
    },
    setFiltersBadge: function () {
        var value = 0;

        if (this.state.year) {
            value++;
        }
        if (this.state.tags.length > 0) {
            value = value + this.state.tags.length;
        }
        if (this.state.typologies.length > 0) {
            value = value + this.state.typologies.length;
        }
        $('[data-badge-filter-number]').html(value);

        if (value > 0) {
            $('[data-badge-filter-number]').addClass('a-badge--is-visible');
        } else {
            this.resetFiltersBadge();
        }
    },
    setTagsBadge: function () {
        $('[data-filter-tag-number]').html(this.state.tags.length);

        if (this.state.tags.length > 0) {
            $('[data-filter-tag-number]').parent().addClass('a-input__panel--active');
            $('[data-filter-tag-number]').addClass('a-badge--is-visible');
        } else {
            this.resetTagsBadge();
            $('[data-filter-tag-number]').parent().removeClass('a-input__panel--active');
        }
    },
    setTypologiesBadge: function () {
        $('[data-filter-typology-number]').html(this.state.typologies.length);

        if (this.state.typologies.length > 0) {
            $('[data-filter-typology-number]').parent().addClass('a-input__panel--active');
            $('[data-filter-typology-number]').addClass('a-badge--is-visible');
        } else {
            this.resetTypologiesBadge();
            $('[data-filter-typology-number]').removeClass('a-badge--is-visible');
        }
    },
    populateSelectYears: function () {
        var firstYear = this.data.year.firstYear;
        var now = this.data.year.now;

        for (var index = now; index >= firstYear; index--) {
            this.selectors.years.append('<option value="' + index + '" data-index="' + index + '" tabindex="-1">' + index + '</option>');
            this.selectors.years
                .siblings('.m-dropdown__label')
                .find('ul')
                .append('<li class="a-radio__item" data-index="' + index + '" tabindex="-1" data-value="' + index + '" role="option">' + index + '</li>');
        }
    },
    populateSelectThemes: function () {
        for (var index = 0; index < this.data.thematics.length; index++) {
            var item = this.data.thematics[index];

            this.selectors.themes.append('<option value="' + item.id + '" data-index="' + index + '" tabindex="-1">' + item.title + '</option>');
            this.selectors.themes
                .siblings('.m-dropdown__label')
                .find('ul')
                .append('<li class="a-radio__item" data-index="' + index + '" tabindex="-1" data-value="' + item.id + '" role="option">' + item.title + '</li>');
        }
    },
    populateSelectTypos: function () {
        var index = 0;
        var _that = this;

        if (this.data.typologies !== null && this.data.typologies !== undefined) {
            Object.entries(this.data.typologies).forEach(function (item) {
                var key = item[0],
                    value = item[1];
                index++;

                _that.selectors.typologies.append(
                    '<li class="m-overlay__item" data-index="' +
                        index +
                        '" data-value="' +
                        key +
                        '">' +
                        '<label class="a-checkbox" for="' +
                        key +
                        '">' +
                        '<input data-filter-typology-value="' +
                        key +
                        '" id="' +
                        key +
                        '" type="checkbox">' +
                        '<span class="a-checkbox__checkmark"></span>' +
                        '<span class="a-checkbox__label">' +
                        value +
                        '</span>' +
                        '</label>'
                );
            });
        }
    },
    /**
     * @param {String} themeId Thematics radio item value
     */
    populateSelectTags: function (themeId) {
        this.selectors.tags.empty();

        var theme = this.data.thematics.filter(function (item) {
            return item.id === themeId;
        });

        if (theme !== undefined && theme.length !== 0) {
            var listTags = theme[0].tags;

            for (var prop in listTags) {
                this.selectors.tags.append(
                    '<li class="m-overlay__item">' +
                        '<label class="a-checkbox" for="' +
                        prop +
                        '">' +
                        '  <input data-filter-tag-value="' +
                        prop +
                        '" ' +
                        'id="' +
                        prop +
                        '"' +
                        'type="checkbox">' +
                        '  <span class="a-checkbox__checkmark"></span>' +
                        '  <span class="a-checkbox__label">' +
                        listTags[prop] +
                        '  </span>' +
                        '</label>' +
                        '</li>'
                );
            }
        } else {
            this.selectors.tags.empty();
        }
    },
    /**
     * @param {Boolean} Page
     */
    getData: function (page, timer) {
        var that = this;
        var debounceInterval = timer === undefined ? that.waitTiming : timer;
        that.setUrl(page);

        utils.waitForFinalEvent(
            function () {
                var nodepPath = $('#newslist').attr('data-nodepath');
                var url = nodepPath + that.targetUrl.param + '.html';

                //set loading annimation
                var loader = $('#loading');
                var loadMessage = loader.attr('data-i18n');
                loader.removeClass('sr-only').addClass('a-loader--visible');
                loader.append('<p class="a-loader__message">' + loadMessage + '</p>');

                $.ajax({
                    url: url,
                    success: function (result) {
                        //Set new pushs
                        var pushs = $('.o-containerlist', result);
                        var featureArticle = $('.o-featurearticle', result);

                        //append new content
                        $('.o-containerlist').empty().append(pushs.html());

                        if ($('.o-featurearticle').length === 0) {
                            $(featureArticle).insertBefore('.o-filter');
                        }

                        //Set new paginations
                        var nav = $('[data-filter-nav]', result);
                        $('[data-filter-nav]').empty().append(nav.html());

                        var nbPrefix = $('[data-filter-result-prefix]', result);
                        $('[data-filter-result-prefix]').each(function () {
                            $(this).text(nbPrefix.html() + ' ');
                        });

                        //Set new result number paginations
                        var nb = $('[data-filter-result-number]', result);
                        $('[data-filter-result-number]').each(function () {
                            $(this).text(nb.html() + ' ');
                        });

                        var nbSuffix = $('[data-filter-result-suffix]', result);
                        $('[data-filter-result-suffix]').each(function () {
                            $(this).text(nbSuffix.html() + ' ');
                        });

                        history.pushState({}, null, that.targetUrl.url + that.targetUrl.param + '.html');

                        //hide loading animation
                        $('#loading').addClass('sr-only').removeClass('a-loader--visible');
                        $('#loading').children('p').remove();

                        var Newslist = require('../components/newslist.js');
                        var newslistLayout = new Newslist();
                        if ($(window).width() >= 768) {
                            var layout = sessionStorage.getItem('lbp.listeactu.layout') || 'o-containerlist--horizontal';
                            newslistLayout.setLayout(layout);
                        }
                        newslistLayout.showFeatured(that.targetUrl.param);
                        $(document).trigger('reclamp');
                        that.setAccessibilityTitle();

                        that.setScrollPosition();
                    },
                });
            },
            debounceInterval,
            'getDataFilterActu'
        );
    },
    resetFilter: function () {
        var that = this;
        var page = false;

        if ($('[data-corp]').length) {
            that.state.theme = this.data.thematics[0].id;
            that.setTheme();
        } else {
            that.targetUrl.param = '';
            that.populateSelectTags(null);
        }
        that.resetTagsBadge();
        that.resetTypologiesBadge();
        that.resetFiltersBadge();

        that.selectors.filter.find('.u-checkbox__trigger').prop('checked', false);

        //reset year and theme
        var listSelect = [that.selectors.years, that.selectors.themes];
        listSelect.forEach(function (selector) {
            selector.find('option:first-child').prop('selected', true);
            selector.closest('.m-dropdown').find('.a-radio__item').removeClass('a-radio__item--is-active');
            selector.closest('.m-dropdown').find('.js-input__trigger__item__active').hide();
        });

        //reset typology
        $('[data-filter-typology-value]').prop('checked', false);

        that.getData(page);
        history.pushState({}, null, that.targetUrl.url);
    },

    iconDisplay: function (el) {
        el.siblings('svg').children('use').attr('xlink:href', '/etc.clientlibs/labanquepostale/commons/clientlibs/base/resources/svg-icons.svg#ic-interface-chevron-down');
    },
    setAccessibilityTitle: function () {
        var pageAccessTitle = this.selectors.pageTitle.children('title');

        if ($('.o-pagination').length > 0) {
            var currentPage = this.selectors.pagination.find('.js-pagination__number > .current').text();
            var lastPage = this.selectors.pagination.find('.js-pagination__number').last().children().text();

            if (pageAccessTitle.length === 0) {
                this.selectors.pageTitle.append('<title> Page ' + currentPage + ' sur' + lastPage + ' - La Banque Postale</title>');
            } else {
                pageAccessTitle.text('Page ' + currentPage + ' sur' + lastPage + ' - La Banque Postale');
            }
        } else {
            this.selectors.pageTitle.children().remove();
        }
    },
    /**
     * Set scroll position to top of newslist
     */
    setScrollPosition: function () {
        var _offsetHeader = 0;
        if (!$('.o-header').is('.o-header--sticky, .o-header--moved')) {
            _offsetHeader = 120;
        }

        $([document.documentElement, document.body]).animate(
            {
                scrollTop: $('.row.newslist').first().offset().top - _offsetHeader - 70,
            },
            200
        );
    },
    setAriaCheckboxLabel: function (el, type) {
        var trigger = el.closest('.m-dropdown').find('label').first();

        if (type.length > 0) {
            var labelEnd = trigger.attr('data-i18n-suffix');
            trigger.children('[data-suffix-label]').text(labelEnd);
        } else {
            trigger.children('[data-suffix-label]').text('');
        }
    },
    events: function () {
        var that = this;

        $(document).ready(function () {
            that.parseUrl();
            that.setUrl();
            history.pushState({}, null, that.targetUrl.url + that.targetUrl.param + '.html');
        });

        $('body').on('click', '[data-filter-show]', function (e) {
            e.preventDefault();
            that.getData();

            $('#o-filter-button').prop('checked', false);
        });

        //reset Filter
        $('body').on('click', '[data-filter-reset]', function (e) {
            e.preventDefault();
            that.resetFilter();
        });

        //update Tag number
        $('body').on('change', '[data-filter-tag-value]', function () {
            that.state.tags = [];
            var page = false;

            $('[data-filter-tag-value]').removeAttr('aria-selected');
            $('[data-filter-tag-value]:checked').each(function () {
                that.state.tags.push($(this).data('filter-tag-value'));
                $(this).attr('aria-selected', 'true');
            });

            that.setTagsBadge();
            that.setFiltersBadge();
            that.getData(page, 2000);
            that.setAriaCheckboxLabel($(this), that.state.tags);
        });
        //update Typology number
        $('body').on('change', '[data-filter-typology-value]', function () {
            that.state.typologies = [];
            var page = false;

            $('[data-filter-typology-value]').removeAttr('aria-selected');
            $('[data-filter-typology-value]:checked').each(function () {
                that.state.typologies.push($(this).data('filter-typology-value'));
                $(this).attr('aria-selected', 'true');
            });
            that.setTypologiesBadge();
            that.setFiltersBadge();
            that.getData(page, 2000);

            that.setAriaCheckboxLabel($(this), that.state.typologies);
        });
        //update Filter number (on filter mobile button)
        $('body').on('change', '#filterSelectYears', function () {
            that.state.year = $('#filterSelectYears').val();
            var page = false;

            if (that.selectors.years.val() !== '') {
                $('#filterSelectYears').addClass('m-dropdown__select--active');
            } else {
                $('#filterSelectYears').removeClass('m-dropdown__select--active');
            }
            that.setFiltersBadge();
            that.state.year = that.selectors.years.val();
            that.getData(page);
            that.iconDisplay($(this));
        });
        // on change theme
        $('body').on('change', '#filterSelectTheme', function () {
            that.state.tags = [];
            var page = false;

            if (!$('[data-corp]').length) {
                that.populateSelectTags(this.value);

                if (that.selectors.themes.val() !== '') {
                    $('#filterSelectTheme').addClass('m-dropdown__select--active');
                } else {
                    $('#filterSelectTheme').removeClass('m-dropdown__select--active');
                }
                that.setTagsBadge();
                that.setFiltersBadge();
                that.state.theme = that.selectors.themes.val();
                that.getData(page);
                that.iconDisplay($(this));
            }
        });
        // on change  sort
        $('body').on('change', '[data-filter-sort]', function () {
            var state = $(this).prop('checked');
            that.selectors.sort.each(function () {
                $(this).prop('checked', state);
            });
            that.getData();
        });

        //select all tag
        $('body').on('click', '[data-filter-tag-all]', function (e) {
            e.preventDefault();
            var page = false;
            that.state.tags = [];
            $('[data-filter-tag-value]').each(function () {
                $(this).prop('checked', true);
                $(this).attr('aria-selected', 'true');
                that.state.tags.push($(this).data('filter-tag-value'));
            });
            that.setTagsBadge();
            that.setFiltersBadge();
            that.getData(page);

            that.setAriaCheckboxLabel($(this), that.state.tags);
        });

        $('body').on('keydown', '[data-filter-tag-all]', function (e) {
            //Esc
            if (e.which === 27) {
                $(this).closest('.m-dropdown').find('.u-checkbox__trigger').prop('checked', false);
                $('.m-dropdown .a-radio__item').attr('tabindex', '-1');
                $(this).closest('.m-dropdown').find('.a-input__panel').focus();
            }
        });
        $('body').on('keydown', '[data-filter-tag-none]', function (e) {
            //Esc
            if (e.which === 27) {
                $(this).closest('.m-dropdown').find('.u-checkbox__trigger').prop('checked', false);
                $('.m-dropdown .a-radio__item').attr('tabindex', '-1');
                $(this).closest('.m-dropdown').find('.a-input__panel').focus();
            }
        });
        $('body').on('keypress', '[data-filter-tag-none]', function (e) {
            if (e.which === 13 || e.which === 32) {
                $('.a-input__panel').trigger('click');

                setTimeout(function () {
                    $('[data-filter-reset]').closest('.m-button').focus();
                }, 2000);
            }
        });
        //select all typologies
        $('body').on('click', '[data-filter-typology-all]', function (e) {
            e.preventDefault();
            var page = false;
            that.state.typologies = [];
            $('[data-filter-typology-value]').each(function () {
                $(this).prop('checked', true);
                $(this).attr('a-input__panel', 'true');
                that.state.typologies.push($(this).data('filter-typology-value'));
            });
            that.setTypologiesBadge();
            that.setFiltersBadge();
            that.getData(page);

            that.setAriaCheckboxLabel($(this), that.state.typologies);
        });
        //unselect all typologies
        $('body').on('click', '[data-filter-typology-none]', function (e) {
            e.preventDefault();
            var page = false;
            that.state.typologies = [];
            $('[data-filter-typology-value]:checked').each(function () {
                $(this).prop('checked', false);
                $(this).removeAttr('aria-selected');
            });
            that.setTypologiesBadge();
            that.setFiltersBadge();
            that.getData(page);

            that.setAriaCheckboxLabel($(this), that.state.typologies);
        });
        //select all typologies
        $('body').on('keydown', '[data-filter-typology-all]', function (e) {
            //Esc
            if (e.which === 27) {
                $(this).closest('.m-dropdown').find('.u-checkbox__trigger').prop('checked', false);
                $('.m-dropdown .a-radio__item').attr('tabindex', '-1');
                $(this).closest('.m-dropdown').find('.a-input__panel').focus();
            }
        });
        //unselect all typologies
        $('body').on('keydown', '[data-filter-typology-none]', function (e) {
            //Esc
            if (e.which === 27) {
                $(this).closest('.m-dropdown').find('.u-checkbox__trigger').prop('checked', false);
                $('.m-dropdown .a-radio__item').attr('tabindex', '-1');
                $(this).closest('.m-dropdown').find('.a-input__panel').focus();
            }
        });
    },
};

module.exports = FilterNewslist;

},{"../components/newslist.js":60,"../librairies/utils.js":67}],57:[function(require,module,exports){
/**
 * * FilterInput
 *
 * Use as :
 *
 *    var filterInput = new FilterInput('.o-currencyconverter .m-filter');
 *    filterInput.init();
 *
 * * overwrite onInvalidCallback or onvalidCallback like this:
 *      filterInput.onInvalidCallback = function (_self) {
 *             //in this context, this refer to the m-filter element.
 *             var errorEl = _self.parent().find(this.selectors.error + ' p');
 *             if (_self.val().length === 0) {
 *                 errorEl.text(_that.errorMsg.errorEmpty);
 *             } else {
 *                 errorEl.text(_that.errorMsg.errorCurrency);
 *             }
 *         };
 */

/**
 * FilterInput :
 * @param {String} _target , selector of filter. if undefined '.m-filter'
 */
function FilterInput(_target) {
    //set Target of selectors
    if (_target === undefined) {
        this.selectors.filter = '.m-filter';
    } else {
        this.selectors.filter = _target;
    }
}

FilterInput.prototype = {
    selectors: {
        filter: null,
        delete: '.m-filter__icon-delete',
        error: '.m-filter__error',
        valueAttr: 'data-filter-value',
    },
    stateOpen: false,
    istab: false,
    isDown: false,
    isUp: false,
    isEscap: false,
    shifTab: false,
    currentItemIndex: 0,

    onInvalidCallback: function (_self) {},
    onvalidCallback: function (_self) {},

    event: function () {
        var _that = this;

        //on click on input select text OR focus
        $(document).on('click', _that.selectors.filter + ' input', function () {
            $(this).val('');
            _that.filterFunction($(this));
            _that.showDropdown($(this));
            _that.hideError($(this));

            //reset isEscap
            _that.isEscap = false;
            _that.currentItemIndex = 0;
        });

        //check selected value on blur from input
        $(document).on('blur', _that.selectors.filter + ' input', function (e) {
            // if blur isn't from key tab
            if (!_that.istab && !_that.isDown && !_that.isUp) {
                _that.checkValue($(this));
                _that.hideDropdown($(this), true);
            }
        });

        //check selected value on blur from dropdown item
        $(document).on('blur', _that.selectors.filter + ' [' + _that.selectors.valueAttr + ']', function (e) {
            // if blur isn't from key tab
            if (!_that.istab && !_that.isDown && !_that.isUp) {
                _that.hideDropdown($(this), true);
            }
        });

        //On key UP filter content
        $(document).on('keyup', _that.selectors.filter + ' input', function (e) {
            _that.filterFunction($(this));
            _that.checkValue($(this));
        });

        //On click icon delete
        $(document).on('click', _that.selectors.delete, function (e) {
            $(this).prev().val('').focus();
            $(this).css('display', 'none');
        });

        //On key down : focus on dropdown
        $(document).on('keydown', _that.selectors.filter + ' input', function (e) {
            _that.istab = false;
            _that.isEscap = false;
            _that.isDown = false;
            _that.isUp = false;
            //is tab key and no shift key
            if ((e.key === 'Tab' || e.keyCode === 9) && !e.shiftKey) {
                _that.istab = true;
            }
            if (e.key === 'Tab' && e.shiftKey) {
                _that.shifTab = true;
                _that.hideDropdown($(this), _that.shifTab);
            }
            if (e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27) {
                _that.isEscap = true;
                _that.setSelected($(this), $(this).find('option:selected').val());
                _that.checkValue($(this));
            }
            if (e.key === 'ArrowDown' || e.keyCode === 40) {
                _that.isDown = true;
            }
            if (e.key === 'ArrowUp' || e.keyCode === 38) {
                _that.isUp = true;
            }
            if (e.key === 'Enter' || e.key === '13') {
                e.preventDefault();

                if (_that.stateOpen === false) {
                    $(this).val('');
                    _that.filterFunction($(this));
                    _that.showDropdown($(this));
                } else {
                    _that.hideDropdown($(this), false);
                }
            }
        });

        $(document).on('click', _that.selectors.filter + ' [' + _that.selectors.valueAttr + ']', function () {
            _that.setSelected($(this), $(this).data('filter-value'));
            _that.hideDropdown($(this), _that.shifTab);
        });

        $(document).on('keydown', _that.selectors.filter + ' [' + _that.selectors.valueAttr + ']', function (e) {
            if (e.key === 13 || e.key === 'Enter') {
                e.preventDefault();
                _that.setSelected($(this), $(this).data('filter-value'));
                _that.hideDropdown($(this), false);
                $(this).closest(_that.selectors.filter).find('.m-filter__icon-delete').css('display', 'block');
            }
        });

        //on select change, set selected value
        $(document).on('change', _that.selectors.filter + ' select', function () {
            _that.setSelected($(this), $(this).find('option:selected').val());
        });

        //Accessibility Keyboard
        $(document).on('keydown', _that.selectors.filter, function (e) {
            if (e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27) {
                _that.isEscap = true;
                _that.hideDropdown($(this), _that.shifTab);
                $(this).closest(_that.selectors.filter).find('input').focus();
            }

            //Arrow key mechanics
            var isDown = e.key === 'ArrowDown' || e.keyCode === 40;
            var isUp = e.key === 'ArrowUp' || e.keyCode === 38;

            if (e.key === 'Tab' || e.keyCode === 9) {
                //_that.showDropdown($(this).children('input'));
                if (($(e.target).is('[data-filter-value]') && !e.shiftKey) || isDown || isUp) {
                    var item = $(e.target);
                    var itemdisplayed = item.nextAll('li:visible');
                    //if tab out of component
                    if (itemdisplayed.length === 0) {
                        _that.hideDropdown($(this), true);
                    }
                }
            }
            if (isDown || isUp) {
                e.preventDefault();
                _that.showDropdown($(this).children('input'));

                var items = $(this).find('[data-filter-value]:visible');

                if (isDown) {
                    _that.currentItemIndex++;
                }
                if (isUp) {
                    _that.currentItemIndex--;
                }
                if (_that.currentItemIndex <= 0) {
                    _that.currentItemIndex = 0;
                }
                if (_that.currentItemIndex > items.length - 1) {
                    _that.currentItemIndex = items.length - 1;

                    if (isDown) {
                        _that.currentItemIndex = 0;
                    }
                }

                if ($(':focus').is('input')) {
                    if (isDown) {
                        _that.currentItemIndex = 0;
                    } else if (isUp) {
                        _that.currentItemIndex = items.length - 1;
                    }
                }

                if ($(':focus').is('input') && isUp) {
                    _that.currentItemIndex = items.length - 1;
                }
                if (_that.currentItemIndex === 0 && isUp) {
                    _that.currentItemIndex = items.length - 1;
                }
                items[_that.currentItemIndex].focus();
            }
        });

        //close dropdown if click elsewhere
        $(document).on('click', function (e) {
            if ($(e.target).closest(_that.selectors.filter).length === 0 && $(_that.selectors.filter).find('.m-filter__container').hasClass('.js-is-active')) {
                _that.hideDropdown($('.m-filter__container.js-is-active'), false);
            }
        });
    },

    /**
     * filterFunction : filtre les lements
     * @param {Element} _self
     */
    filterFunction: function (_self) {
        var filter,
            items,
            i,
            hasResult = 0;
        filter = _self.val().toUpperCase();
        items = _self.parent().find('ul [' + this.selectors.valueAttr + ']');

        _self.removeAttr('aria-activedescendant');
        _self.parent().find('li').removeAttr('id');

        for (i = 0; i < items.length; i++) {
            var txtValue = items[i].textContent || items[i].innerText;
            if (txtValue.toUpperCase().indexOf(filter) > -1) {
                items[i].style.display = '';
                _self.siblings('.m-filter__icon-delete').css('display', 'block');
                hasResult++;
            } else {
                items[i].style.display = 'none';
            }
        }

        if (hasResult === 0) {
            this.showError(_self);
        } else {
            this.hideError(_self);
        }
    },

    /**
     * setSelected : set selected element
     * @param {Element} _self
     * @param {String} _val
     */
    setSelected: function (_element, _val) {
        var parent = _element.closest(this.selectors.filter),
            input = parent.find('input'),
            items = parent.find('li'),
            currentItem = parent.find('[' + this.selectors.valueAttr + '=' + _val + ']');

        //remove selected class
        parent.find('[' + this.selectors.valueAttr + ']').removeClass('js-is-selected');
        items.removeAttr('id');

        //add selected class to current item
        currentItem.addClass('js-is-selected').attr('id', _val);

        input.attr('aria-activedescendant', _val);

        // set selected text into input
        input.val(
            parent
                .find('[' + this.selectors.valueAttr + '=' + _val + ']')
                .text()
                .trim()
        );
        parent.find('select option[value= ' + _val + ']').prop('selected', true);
        this.hideError(_element);
    },

    /**
     * checkValue : //check if input value is in the list and set it.
     * @param {Element} _self
     */
    checkValue: function (_self) {
        var filter = _self.val().toUpperCase(),
            items = _self.parent().find('select option');

        var isValid = items.filter(function () {
            return filter === $(this).text().toUpperCase();
        }).length;
        if (!isValid) {
            this.onInvalidCallback(_self);
            this.showError(_self);
        } else {
            this.onvalidCallback(_self);
        }
    },

    /**
     * showError :
     * @param {Element} _self
     */
    showError: function (_self) {
        var errorField = _self.closest(this.selectors.filter).find(this.selectors.error);
        var errorMessage = $(errorField).attr('data-message');
        var errorMessageElement = $('<p class="a-text--small">' + errorMessage + '</p>');

        if ($(errorField).children('p').length === 0) {
            $(errorField).append(errorMessageElement);
        }
        errorField.addClass('js-error').css('display', 'flex');
        _self.attr('aria-invalid', 'true');
    },
    /**
     * hideError :
     * @param {Element} _self
     */
    hideError: function (_self) {
        _self.closest(this.selectors.filter).find(this.selectors.error).children('p').remove();
        _self.closest(this.selectors.filter).find(this.selectors.error).removeClass('js-error').hide();
        _self.closest(this.selectors.filter).find('input').removeAttr('aria-invalid');
    },

    /**
     * showDropdown :
     * @param {Element} _self
     */
    showDropdown: function (_self) {
        this.stateOpen = true;
        var _parent = _self.closest(this.selectors.filter);
        _parent.find('.m-filter__container').addClass('js-is-active');
        _parent.find('[' + this.selectors.valueAttr + ']').attr('tabindex', '0');
        _parent.find(' input').attr('aria-expanded', 'true');
        _parent.find('.m-filter__container').css('max-height', '215px');
        _parent.find('ul').removeAttr('aria-hidden');
        _parent.find('.m-filter__container').parent().attr('aria-atomic', 'true');
    },
    /**
     * hideDropdown :
     * @param {Element} _self
     */
    hideDropdown: function (_self, shiftTab) {
        this.stateOpen = false;
        var _parent = _self.closest(this.selectors.filter);
        _parent.find('.m-filter__container').removeClass('js-is-active');
        _parent.find('[' + this.selectors.valueAttr + ']').attr('tabindex', '-1');
        _parent.find(' input').attr('aria-expanded', 'false');
        _parent.find('ul').attr('aria-hidden', 'true');
        _parent.find('.m-filter__container').parent().removeAttr('aria-atomic');

        this.istab = false;
        this.checkValue(_parent.find('input'));

        setTimeout(function () {
            _parent.find('.m-filter__container').css('max-height', '0');
            if (shiftTab === false) {
                _parent.find('input').focus();
            }
        }, 100);
    },

    /**
     * init :
     * @param {Element}
     */
    init: function () {
        this.event();
    },
};

module.exports = FilterInput;

},{}],58:[function(require,module,exports){
function NewsletterPush() {}

NewsletterPush.prototype = {
    selectors: {
        input: '#newsletterPushEmail',
        button: '#newsletterPushButton',
        errorMsg: '#newsletterPushEmail-error',
    },
    config: {
        path: $('.o-newsletterPush form').attr('data-path'), // url of encrypted function
        idfrom: $('.o-newsletterPush form').attr('data-idfrom'), // idfrom of the form NewsletterPush to send to the page
        url: '', // url destination of newsletter formulaire (where the iframe is)
    },

    init: function () {
        this.config.url = $('.o-newsletterPush form').attr('action');
        this.event();
    },
    event: function () {
        var that = this;

        $(document).on('click', this.selectors.button, function (event) {
            event.preventDefault();
            var inputVal = $(that.selectors.input).val();
            if (inputVal) {
                that.getEncryptedMail(inputVal);
            } else {
                that.gotoIframeForm();
            }
        });
    },

    /**
     * getEncryptedMail: send ajax request to get encrypted format  of the email
     * @param {STRING} _email
     */
    getEncryptedMail: function (_email) {
        var that = this;

        $.ajax({
            url: that.config.path,
            type: 'GET',
            dataType: 'text',
            contentType: 'application/json; charset=utf-8',
            data: {
                email: _email,
            },
            success: function (_result) {
                _result = JSON.parse(_result);
                if (_result.hasOwnProperty('email')) {
                    sessionStorage.setItem(
                        'NPE',
                        JSON.stringify({
                            email: _result.email,
                            idfrom: that.config.idfrom,
                        })
                    );
                    that.gotoIframeForm(_result.email);
                } else {
                    $(this.selectors.errorMsg).removeClass('u-js-hidden');
                }
            },
            error: function (request, status, error) {
                var val = request.responseText;
                console.log('error' + val);
                $(this.selectors.errorMsg).removeClass('u-js-hidden');
            },
        });
    },
    /**
     * gotoIframeForm: change Browser location to newsletter formulaire with Iframe
     * @param {STRING} _encryptedMail
     */
    gotoIframeForm: function (_encryptedMail) {
        var targetUrl = this.config.url;
        if (_encryptedMail) {
            targetUrl += '?e=' + _encryptedMail;
            if (this.config.idfrom) {
                targetUrl += '&idfrom=' + this.config.idfrom;
            }
        }
        if (!_encryptedMail && this.config.idfrom) {
            targetUrl += '?idfrom=' + this.config.idfrom;
        }
        location = targetUrl;
    },
};

/**
 * init NewsletterPush
 */
(function ($) {
    if ($('.o-newsletterPush').length) {
        var newsletterPush = new NewsletterPush();
        newsletterPush.init();
    }
})(window.jQuery);

},{}],59:[function(require,module,exports){
function NewsletterIframe() {}

NewsletterIframe.prototype = {
    selectors: {
        iframe: '.m-newsletteriframe iframe',
    },
    data: {
        keyword: $('.m-newsletteriframe iframe').attr('data-idfrom'),
    },
    config: {
        emailkeyword: '<email>', // keyword searched in parameter URL '<email>',
        idkeyword: '<idfrom>', // keyword searched in parameter URL '<email>',
        emailparam: 'e=<email>',
        idfromparam: 'idfrom=<idfrom>',
    },

    init: function () {
        this.getParam();
    },

    /**
     * getParam : get encrypted mail from url parameter
     */
    getParam: function () {
        var encryptedMail;
        if (sessionStorage.getItem('NPE')) {
            encryptedMail = JSON.parse(sessionStorage.getItem('NPE'));
        }
        if (encryptedMail === null || encryptedMail === undefined) {
            encryptedMail = '';
        }
        this.getUrl(encryptedMail.email, encryptedMail.idfrom);
    },

    /**
     *  getUrl : get URL from iframe so we can set the encrypted mail & _idfrom strings as parameter
     * @param {STRING} _encryptedMail
     * @param {STRING} _idfrom
     */
    getUrl: function (_encryptedMail, _idfrom) {
        var url = $(this.selectors.iframe).attr('data-src');

        if (url !== undefined) {
            if (_encryptedMail === undefined) {
                url = url.replace(this.config.emailparam, '');
            } else {
                url = url.replace(this.config.emailkeyword, _encryptedMail);
            }
            if (_idfrom !== undefined) {
                url = url.replace(this.config.idkeyword, _idfrom);
            } else if (this.data.keyword !== undefined) {
                url = url.replace(this.config.idkeyword, this.data.keyword);
            } else {
                url = url.replace(this.config.idfromparam, '');
            }
        }
        this.setUrl(url);
    },

    /**
     * set URL of iframe
     * @param {STRING} _url
     */
    setUrl: function (_url) {
        $(this.selectors.iframe).attr('src', _url);
    },
};

/**
 * init NewsletterIframe
 */
(function ($) {
    if ($('.m-newsletteriframe').length) {
        var newsletterIframe = new NewsletterIframe();
        newsletterIframe.init();
    }
})(window.jQuery);

},{}],60:[function(require,module,exports){
function Newslist() {}

Newslist.prototype = {
    selectors: {
        container: $('#newslist'),
        layoutTrigger: $('input[type=radio][name*=newslist-view]'),
    },

    init: function () {
        // Retrieve layout from session
        var layout = sessionStorage.getItem('lbp.listeactu.layout') || this.selectors.container.attr('data-view');
        this.setLayout(layout);
        this.event();
        this.showFeatured();
    },

    event: function () {
        var _that = this;

        //switch layout grid
        this.selectors.layoutTrigger.change(function () {
            _that.setLayout(this.value);
        });

        this.selectors.layoutTrigger.on('keypress', function (e) {
            if (e.which === 13 || e.which === 32) {
                $(this).trigger('click');
            }
        });
    },

    showFeatured: function (param) {
        var featureArticle = $('.o-featurearticle');

        if (param === '' || param === undefined) {
            featureArticle.addClass('o-featurearticle--active');
            featureArticle.removeAttr('aria-hidden');
            featureArticle.find('a').removeAttr('tabindex');
        } else {
            featureArticle.removeClass('o-featurearticle--active');
            featureArticle.attr('aria-hidden', 'true');
            featureArticle.find('a').attr('tabindex', '-1');
        }
    },

    /**
     * Set Layout to Newslist
     * @param {String} _layout
     */
    setLayout: function (_layout) {
        var items = this.selectors.container.find('.m-container--isCard');
        var layoutType = _layout === 'o-containerlist--grid' ? 'm-container--isCard--column' : '';

        this.selectors.container.removeClass('o-containerlist--horizontal');
        this.selectors.container.removeClass('o-containerlist--grid');

        items.each(function () {
            $(this).removeClass('m-container--isCard--column').addClass(layoutType);
            $(this).removeClass('u-unvisible--sm').addClass('u-visible--sm');
        });

        this.selectors.container.addClass(_layout);
        sessionStorage.setItem('lbp.listeactu.layout', _layout);

        this.selectors.layoutTrigger.each(function () {
            $(this).prop('checked', false);
        });

        this.selectors.layoutTrigger.filter('[value=' + _layout + ']').prop('checked', true);
    },
};

/**
 * init  Newslist
 */
(function ($) {
    if ($('#newslist').length) {
        var newslist = new Newslist();
        newslist.init();

        /**
         * init Filtre Newslist
         */
        if ($('[data-filters]').length) {
            var FilterNewslist = require('../components/filter-newslist.js');

            var filter = new FilterNewslist();
            filter.init();
        }
    }
})(window.jQuery);

module.exports = Newslist;

},{"../components/filter-newslist.js":56}],61:[function(require,module,exports){
function GraphOpc() {}
GraphOpc.prototype = {
    selectors: {
        container: $('.o-graph-opc'),
        selectDate: $('.o-graph-opc').find('.js-selectdate-listitem'),
        firstDate: undefined,
        lastDate: undefined,
        benchfirstDate: undefined,
        benchlastDate: undefined,
        errorcontribstart: $('.o-graph-opc').find('a.comparestart'),
        errorcontribend: $('.o-graph-opc').find('a.compareend'),
        calendarStart: $('.o-graph-opc').find('.o-graph-opc__calendar-start'),
        calendarEnd: $('.o-graph-opc').find('.o-graph-opc__calendar-end'),
    },
    data: {
        values: '',
        keys: '',
        benchValues: '',
        benchKeys: '',
        variationValues: '',
        variationBenchValues: '',
        formattedKeys: '',
    },

    init: function () {
        this.bindEvents();
    },

    bindEvents: function () {
        document.addEventListener(
            'trigger:opcgraph',
            function () {
                this.selectors.selectDate.last().addClass('m-flag--active');
                var _this = this;
                _this.ajaxPerfRequest();

                if ($(window).width() < 768) {
                    this.loadCarousel();
                    $('canvas').attr('height', '312');
                }
            }.bind(this)
        );

        $.each(
            $('.o-graph-opc__calendar__input'),
            function (index, element) {
                if ($(element).is(':empty')) {
                    this.calendar(element);
                }
            }.bind(this)
        );
        $.each($('.o-graph-opc__calendar__start__icon'), function (index, element) {
            if ($(element).is(':empty')) {
                this.calendar(element);
            }
        });
        $.each(
            $('.o-graph-opc__calendar__end__icon'),
            function (index, element) {
                if ($(element).is(':empty')) {
                    this.calendar(element);
                }
            }.bind(this)
        );

        this.selectors.selectDate.on(
            'click',
            function (e) {
                var $this = $(e.target);
                var choosenDate = $this.data('switch'),
                    date = this.setDate(this.selectors.lastDate, choosenDate),
                    dates = [this.formatMonth(date)];

                this.selectors.errorcontribstart.css('display', 'none');
                this.selectors.errorcontribend.css('display', 'none');
                this.selectors.calendarStart.removeClass('error');
                this.selectors.calendarEnd.removeClass('error');

                this.selectors.selectDate.not($this).removeClass('m-flag--active');
                $this.toggleClass('m-flag--active');
                this.selectors.calendarStart.datepicker('setDate', date);

                this.updateChart(dates);
            }.bind(this)
        );

        $(document).on(
            'change keydown',
            '.o-graph-opc__calendar__input',
            function (e) {
                var $this = $(e.target);

                this.selectors.selectDate.removeClass('m-flag--active');

                if (e.type !== 'keydown' || e.which === 13 || e.which === 9) {
                    var date = $this.val(),
                        $error = $this.siblings('a').hasClass('comparestart') ? this.selectors.errorcontribstart : this.selectors.errorcontribend,
                        uistartDate = this.setMonthToNumber(this.selectors.calendarStart.datepicker('getDate')),
                        uiendDate = this.getEndDate(),
                        startDate = this.momentToDate(uistartDate, 'L'),
                        endDate = this.momentToDate(uiendDate, 'L'),
                        lastdate = this.momentToDate(this.selectors.lastDate, 'LL'),
                        minDate = this.momentToDate(this.selectors.firstDate, 'LL'),
                        compare = this.compareDate(startDate, endDate),
                        compareMin = this.compareDate(startDate, minDate),
                        compareMax = this.compareDate(endDate, lastdate);

                    if (compareMax === false) {
                        this.selectors.calendarEnd.datepicker('setDate', lastdate);
                        $this.siblings('a.end').css('display', 'block');
                        $this.addClass('error');
                    } else {
                        $this.siblings('a.end').css('display', 'none');
                        $this.removeClass('error');
                    }
                    if (compareMin === true) {
                        this.selectors.calendarStart.datepicker('setDate', minDate);
                        $this.siblings('a.start').css('display', 'block');
                        $this.addClass('error');
                    } else {
                        $this.siblings('a.start').css('display', 'none');
                        $this.removeClass('error');
                    }

                    moment(endDate, 'dd/MMM/YYYY').format('L');
                    var isDateValid = moment(date, 'L', true).isValid();

                    if (!isDateValid) {
                        $this.siblings('a.contrib').css('display', 'block');
                        $this.addClass('error');
                    } else {
                        $this.siblings('a.contrib').css('display', 'none');
                        $this.removeClass('error');
                    }

                    if (compare === false) {
                        $error.css('display', 'block');
                        $this.addClass('error');
                    } else {
                        this.selectors.errorcontribend.css('display', 'none');
                        this.selectors.errorcontribstart.css('display', 'none');
                        $this.parents('.o-graph-opc__calendar').find('input').removeClass('error');
                    }
                    if (compare === true && compareMax === true && compareMin === false && isDateValid) {
                        var dates = [this.formatMonth(uistartDate), this.formatMonth(uiendDate)];
                        this.updateChart(dates);
                    }
                }
            }.bind(this)
        );
    },

    loadCarousel() {
        const list = this.selectors.container.find('.o-graph-opc__selectdate__list');
        var Carousel = require('../../components/carousel.js');

        list.find('li').each(function () {
            const itemWidth = $(this).outerWidth() + 2;
            $(this).width(itemWidth);
        });
        slide = new Carousel();
        slide.initOpcCarousel();
    },

    /* retrieve performances values */
    ajaxPerfRequest: function () {
        var perfRequest = $.ajax({
            url: window.location.pathname.split('.')[0] + '.opcperformancevl' + '.json',
            type: 'GET',
            dataType: 'json',
            success: function (data) {
                if (!$.isEmptyObject(data)) {
                    this.selectors.container.css('display', 'block');
                    this.buildArray(data);
                    this.ajaxBenchRequest();
                }
            }.bind(this),
        });
    },

    /* retrieve benchmark values */
    ajaxBenchRequest: function () {
        var benchRequest = $.ajax({
            url: window.location.pathname.split('.')[0] + '.opcperformancebenchmark' + '.json',
            type: 'GET',
            dataType: 'json',
            success: function (data) {
                if (!$.isEmptyObject(data)) {
                    this.selectors.container.css('display', 'block');
                    this.buildBenchArray(data);
                } else {
                    this.hideChartLabels();
                }
            }.bind(this),
            error: function () {
                this.hideChartLabels();
            }.bind(this),
        });
    },

    /* re-add 0 values if array mist starts with 0 values  */
    concatArrays: function (first, slicedBench, variationBenchValues) {
        var slice0values = slicedBench.slice(slicedBench[0], first);
        variationBenchValues = slice0values.concat(variationBenchValues);
        return variationBenchValues;
    },

    /* build keys & values for Performances chart line */
    buildArray: function (data, type) {
        var pk = [],
            pv = [],
            _this = this;

        moment.locale('fr');

        var getPerfArray = function () {
            $.each(data, function (key, value) {
                pk.push(key);
                pv.push(value);
            });
            return [pk, pv];
        };
        var perfArray = getPerfArray();

        this.data.keys = pk;
        this.data.values = pv;
        this.selectors.firstDate = pk[0];
        this.selectors.lastDate = pk.slice(-1).pop();

        var momentDateStart = this.momentToDate(this.selectors.firstDate, 'LL');
        var momentEndDate = this.momentToDate(this.selectors.lastDate, 'LL');

        var compare = this.compareDate(moment(this.selectors.firstDate, 'LL').toDate(), moment(this.setDate(this.selectors.lastDate, 6), 'L').toDate());
        this.selectors.calendarStart.datepicker('setDate', compare === true ? this.setDate(this.selectors.lastDate, 6) : this.selectors.firstDate);
        this.selectors.calendarStart.datepicker('option', 'minDate', new Date(momentDateStart));
        this.selectors.calendarStart.datepicker('option', 'maxDate', new Date(momentEndDate));

        this.selectors.calendarEnd.datepicker('setDate', this.setMonthToNumber(this.selectors.lastDate));
        this.selectors.calendarEnd.datepicker('option', 'minDate', new Date(momentDateStart));
        this.selectors.calendarEnd.datepicker('option', 'maxDate', new Date(momentEndDate));

        /* hide preselected buttons if older than firstdate value */
        this.selectors.selectDate.each(
            function () {
                var $this = $(this);

                var selectDate = _this.setDate(this.selectors.lastDate, $this.data('switch'));
                var compare = _this.compareDate(moment(this.selectors.firstDate, 'LL').toDate(), moment(selectDate, 'L').toDate());
                if (compare === false) {
                    $this.css('display', 'none');
                }
            }.bind(this)
        );

        if (perfArray !== null && perfArray !== undefined) {
            this.buildChart(type);
        }
    },

    /* Build chartjs plugin */
    buildChart: function () {
        var _this = this,
            index,
            slicedIdx,
            slicedValues,
            variationValues,
            previousdate;

        var format = this.formatMonth(this.setDate(_this.selectors.lastDate, 6));

        /* Build lines based on limit date values (5years) OR first date in keys list */
        var slicePerf = function () {
            index = this.data.keys.indexOf(format);

            if (index !== -1) {
                slicedIdx = this.data.keys.slice(index);
                slicedValues = this.data.values.slice(index);
                this.data.variationValues = this.calcValuesPercentage(slicedValues[0], slicedValues);
            } else {
                var compare = this.compareDate(moment(this.selectors.firstDate, 'LL').toDate(), moment(this.setDate(this.selectors.lastDate, 6), 'L').toDate());
                if (compare === true) {
                    previousdate = this.getPreviousDate(this.data.keys, this.setDate(this.selectors.lastDate, 6));
                } else {
                    previousdate = this.selectors.firstDate;
                }
                index = this.data.keys.indexOf(previousdate);
                slicedIdx = this.data.keys.slice(index);
                slicedValues = this.data.values.slice(index);
                this.data.variationValues = this.calcValuesPercentage(slicedValues[0], slicedValues);

                var momentPrevdate = this.momentToDate(previousdate, 'LL');
                this.selectors.calendarStart.datepicker('setDate', moment(momentPrevdate).format('L'));
            }
            return [slicedIdx, this.data.variationValues];
        }.bind(this);
        slicePerf();

        var config = {
            type: 'line',
            data: {
                datasets: [
                    {
                        data: _this.data.variationValues,
                        backgroundColor: 'rgb(255, 178, 0)',
                        borderColor: 'rgb(255, 178, 0)',
                        pointBorderColor: 'rgba(255, 255, 255, 0)',
                        pointBackgroundColor: 'rgba(255, 255, 255, 0)',
                        pointHoverBorderColor: 'rgb(255, 178, 0)',
                        pointHoverBackgroundColor: 'rgb(255, 178, 0)',
                        borderWidth: $(window).width() < 768 ? 1 : 2,
                        fontColor: 'rgb(0, 0, 0)',
                        fontSize: 15,
                        pointBorderWidth: 10,
                        borderCapStyle: 'round',
                        onlyShowForDatasetIndex: [0],
                        fill: false,
                        label: _this.selectors.container.attr('data-opc-title'),
                    },
                    {
                        data: [],
                        backgroundColor: 'rgb(204,204,204)',
                        borderColor: 'rgb(204,204,204)',
                        pointBorderColor: 'rgba(255, 255, 255, 0)',
                        pointBackgroundColor: 'rgba(255, 255, 255, 0)',
                        pointHoverBorderColor: 'rgb(204,204,204, 0)',
                        pointHoverBackgroundColor: 'rgb(204,204,204, 0)',
                        borderWidth: $(window).width() < 768 ? 1 : 2,
                        fontColor: 'rgb(0, 0, 0)',
                        fontSize: 15,
                        pointBorderWidth: 0,
                        borderCapStyle: 'round',
                        fill: false,
                        label: 'Indicateur de rfrence',
                    },
                ],
                labels: slicedIdx,
            },
            options: {
                animation: {
                    duration: 0,
                },
                tooltips: {
                    mode: 'index',
                    intersect: false,
                    mode: 'single',
                    titleFontSize: 12,
                    titleFontStyle: 'bold',
                    bodyFontColor: 'rgb(0,0,0)',
                    titleFontColor: 'rgb(0,0,0)',
                    bodyFontFamily: "'Arial', sans-serif",
                    backgroundColor: 'rgb(229,229,229)',
                    yPadding: 11,
                    xPadding: 16,
                    cornerRadius: 3.5,
                    displayColors: false,
                    position: 'nearest',
                    spanGaps: true,
                    /* custom option defined in chartPlugin.js */
                    onlyShowForDatasetIndex: [0],
                    callbacks: {
                        label: function (t, d) {
                            if (Array.isArray(_this.data.variationValues)) {
                                var perf = t.datasetIndex === 0 ? 'Performance cumule : ' + _this.data.variationValues[t.index] + ' %' : '';
                                return perf;
                            }
                        },
                        afterLabel: function (t, d) {
                            if (Array.isArray(_this.data.variationBenchValues)) {
                                var bench = t.datasetIndex === 0 ? 'Indicateur de rfrence :' + _this.data.variationBenchValues[t.index] + ' %' : '';
                                return bench;
                            }
                        },
                    },
                },
                hover: {
                    mode: 'nearest',
                    intersect: 'intersect',
                },
                xAxes: [
                    {
                        display: true,
                        scaleLabel: {
                            display: true,
                            labelString: 'Performance Cumule',
                        },
                    },
                ],
                legend: {
                    display: true,
                    position: 'bottom',
                    labels: {
                        fontColor: 'rgb(0, 0, 0)',
                        fontSize: 15,
                        fontFamily: "'Arial', sans-serif",
                    },
                },
                scales: {
                    xAxes: [
                        {
                            display: 'true',
                            maxRotation: 0,
                            ticks: {
                                fontSize: 12,
                                fontColor: 'rgb(0, 0, 0)',
                            },
                        },
                    ],
                    yAxes: [
                        {
                            display: true,
                            maxRotation: 0,
                            scaleLabel: {
                                display: true,
                                fontStyle: 'bold',
                                fontColor: 'rgb(0, 0, 0)',
                                labelString: 'Performance cumule',
                            },
                            ticks: {
                                beginAtZero: true,
                            },
                        },
                    ],
                },
                maintainAspectRatio: false,
                responsive: true,
            },
        };
        var ctx = document.getElementById('myChart').getContext('2d');
        this.myLineChart = new Chart(ctx, config);
    },

    /* build keys & values for Benchmark chart line */
    buildBenchArray: function (data) {
        var _this = this,
            index,
            slicedBench,
            bk = [],
            bv = [],
            previousdate,
            firstOcc,
            indexFirstOcc;

        var format = this.formatMonth(this.setDate(this.selectors.lastDate, 6));

        var getBenchArray = function () {
            $.each(data, function (key, value) {
                bk.push(key);
                bv.push(value);
            });
            return [bk, bv];
        };

        /* slice benchmark array according to dates indexes  */
        var sliceBench = function () {
            index = _this.data.benchKeys.indexOf(format);

            if (index !== -1) {
                slicedBench = _this.data.benchValues.slice(index);
                _this.data.variationBenchValues = _this.calcValuesPercentage(slicedBench[0], slicedBench);
                firstOcc = _this.firstOccurence(slicedBench);
                indexFirstOcc = _this.data.benchValues.indexOf(firstOcc);

                if (slicedBench[0] === '0.00') {
                    _this.concatArrays(indexFirstOcc, slicedBench, _this.data.variationBenchValues);
                }
            } else {
                var compare = _this.compareDate(moment(_this.selectors.firstDate, 'LL').toDate(), moment(_this.setDate(_this.selectors.lastDate, 6), 'L').toDate());

                /* get prevous date availbale OR first date in array list */
                if (compare === true) {
                    previousdate = _this.getPreviousDate(_this.data.benchKeys, _this.setDate(_this.selectors.lastDate, 6));
                } else {
                    previousdate = _this.selectors.firstDate;
                }
                index = _this.data.benchKeys.indexOf(previousdate);
                slicedBench = _this.data.benchValues.slice(index);

                /* get first value !== 0 if arrays start with 0 value  */
                firstOcc = _this.firstOccurence(slicedBench);
                indexFirstOcc = slicedBench.indexOf(firstOcc);
                _this.data.variationBenchValues = _this.calcValuesPercentage(firstOcc, slicedBench);

                if (slicedBench[0] === '0.00') {
                    _this.data.variationBenchValues = _this.concatArrays(indexFirstOcc, slicedBench, _this.data.variationBenchValues);
                }
            }
            return [_this.data.variationBenchValues, slicedBench];
        }.bind(this);

        function getBench() {
            return new Promise(function (resolve, reject) {
                getBenchArray();
                _this.data.benchKeys = bk;
                _this.data.benchValues = bv;
                resolve();
            });
        }

        function slice() {
            sliceBench();
            _this.myLineChart.data.datasets[1].data = _this.data.variationBenchValues;
            _this.myLineChart.update();
        }
        getBench().then(slice);
    },

    /* update chartjs plugin on events listeners trigger */
    updateChart: function (dates) {
        var _this = this,
            refinedValueList = [],
            variationValues,
            refinedDateList = [],
            momentStartDate,
            momentEndDate;

        if (dates !== undefined) {
            if (Array.isArray(this.data.keys)) {
                var indexKey1 = this.data.keys.indexOf(dates[0]);
                var indexKey2 = this.data.keys.indexOf(dates[1]);
            }
            if (Array.isArray(this.data.benchKeys)) {
                var indexBench1 = this.data.benchKeys.indexOf(dates[0]);
                var indexBench2 = this.data.benchKeys.indexOf(dates[1]);
            }

            /* Slice arrays based on indexes passed in params
                @param : values, index
                return array variationValues
            */
            var sliceArrays = function (values, index) {
                refinedValueList = values.slice(index);

                if (refinedValueList[0] !== '0.00') {
                    variationValues = _this.calcValuesPercentage(refinedValueList[0], refinedValueList);
                } else {
                    var firstOcc = _this.firstOccurence(refinedValueList);
                    var indexFirstOcc = refinedValueList.indexOf(firstOcc);
                    variationValues = _this.concatArrays(indexFirstOcc, refinedValueList, variationValues);
                }
                return variationValues;
            };
            var sliceArrayDatePicker = function (values, index1, index2) {
                refinedValueList = values.slice(index1, index2);

                if (refinedValueList[0] !== '0.00') {
                    variationValues = _this.calcValuesPercentage(refinedValueList[0], refinedValueList);
                } else {
                    var firstOcc = _this.firstOccurence(refinedValueList);
                    var indexFirstOcc = refinedValueList.indexOf(firstOcc);
                    variationValues = _this.concatArrays(indexFirstOcc, refinedValueList, variationValues);
                }
                return variationValues;
            };
            /* update Index based on date(s) selected - update date picker input display */
            var updateIndex = function (keys, index, z) {
                if (z === 0 && index === -1) {
                    index = keys.indexOf(_this.getPreviousDate(keys, dates[z], 'LL'));
                    momentStartDate = _this.momentToDate(_this.getPreviousDate(_this.data.keys, dates[0]), 'LL');
                    _this.selectors.calendarStart.datepicker('setDate', moment(momentStartDate).format('L'));
                }
                if (z === 1 && index === -1) {
                    momentEndDate = _this.momentToDate(_this.getPreviousDate(_this.data.keys, dates[1]), 'LL');
                    _this.selectors.calendarEnd.datepicker('setDate', moment(momentEndDate).format('L'));
                }
                return index;
            };
            /* if update triggered by datepickers */
            if (dates.length > 1) {
                if (Array.isArray(this.data.keys)) {
                    var perfindex1 = updateIndex(this.data.keys, indexKey1, 0);
                    var perfindex2 = updateIndex(this.data.keys, indexKey2, 1);
                    refinedDateList = _this.data.keys.slice(perfindex1, perfindex2);
                    _this.data.variationValues = sliceArrayDatePicker(_this.data.values, perfindex1, perfindex2);
                }
                if (Array.isArray(this.data.benchKeys)) {
                    var benchindex1 = updateIndex(this.data.benchKeys, indexBench1, 0);
                    var benchindex2 = updateIndex(this.data.benchKeys, indexBench2, 1);
                    this.data.variationBenchValues = sliceArrayDatePicker(this.data.benchValues, benchindex1, benchindex2);
                }
            }
            /* if update triggered by preselected buttons / dropdown list */
            if (dates.length === 1) {
                if (Array.isArray(this.data.keys)) {
                    var index = updateIndex(this.data.keys, indexKey1, 0);

                    /* if no date found in array values - get previous date available */
                    if (this.data.keys.indexOf(dates[0]) === -1) {
                        index = this.data.keys.indexOf(this.getPreviousDate(this.data.keys, dates[0]));
                        var momentPrevdate = this.momentToDate(this.getPreviousDate(this.data.keys, dates[0]), 'LL');

                        if (indexKey1) {
                            this.selectors.calendarStart.datepicker('setDate', moment(momentPrevdate).format('L'));
                        }
                    }
                    refinedDateList = this.data.keys.slice(index);
                    _this.data.variationValues = sliceArrays(this.data.values, index);
                }
                if (Array.isArray(this.data.benchKeys)) {
                    var benchIndex;

                    if (this.data.benchKeys.indexOf(dates[0]) === -1) {
                        benchIndex = this.data.benchKeys.indexOf(this.getPreviousDate(this.data.benchKeys, dates[0]));
                    } else {
                        benchIndex = updateIndex(this.data.benchKeys, indexBench1, 0);
                    }
                    this.data.variationBenchValues = sliceArrays(this.data.benchValues, benchIndex);
                }
                this.selectors.calendarEnd.datepicker('setDate', moment(this.selectors.lastDate).format('L'));
            }
        }
        if (Array.isArray(this.data.keys)) {
            this.myLineChart.data.datasets[0].data = this.data.variationValues;
            this.myLineChart.data.labels = refinedDateList;
        }
        if (Array.isArray(this.data.benchKeys)) {
            this.myLineChart.data.datasets[1].data = this.data.variationBenchValues;
        }
        this.myLineChart.update();
    },

    /*  Hide labels chart if no data retrieved from ajax request */
    hideChartLabels() {
        this.myLineChart.data.datasets[1].label = '';
        this.myLineChart.data.datasets[1].backgroundColor = 'rgba(255, 255, 255, 0)';
        this.myLineChart.data.datasets[1].borderColor = 'rgba(255, 255, 255, 0)';
        this.myLineChart.update();
    },

    /* calculate rate of change */
    calcValuesPercentage: function (vd, values) {
        var percentList = [];

        values.forEach(function (va) {
            if (va !== '0.00') {
                var v = ((va - vd) / vd) * 100;
                var dec = v.toFixed(2);
                return percentList.push(dec);
            }
        });
        return percentList;
    },

    /* datepicker construct */
    calendar: function (element) {
        var months = this.getMonths();
        this.lastUIElementSelected = null;
        this.selectedBPStatus;

        this.jquidatepicker = $(element).datepicker({
            monthNames: months,
            dayNamesMin: ['Di', 'Lu', 'Ma', 'Me', 'Je', 'Ve', 'Sa'],
            firstDay: 1, // First day is now monday
            showOtherMonths: true,
            selectOtherMonths: false,
            hideIfNoPrevNext: false,
            nextText: 'Mois suivant',
            prevText: 'Mois prcdent',
            dateFormat: 'dd/mm/yy',

            beforeShow: function (input, inst) {
                var screenOffset = $(input).offset().top;
                $(inst.dpDiv).addClass('graphopc');

                $('body,html').animate(
                    {
                        scrollTop: screenOffset - 100,
                    },
                    300
                );
                setTimeout(function () {
                    inst.dpDiv.css({
                        top: $('.o-graph-opc__calendar__input').offset().top + 50,
                        marginTop: '20px',
                    });
                }, 300);
            },
        });
    },

    /* find first occurence !== 0 - Avoid NAN || Infinity result in variation percentage calculation */
    firstOccurence: function (array) {
        var number = array.find(function (element) {
            return element !== '0.00';
        });
        return number;
    },

    /* compare dates  */
    compareDate: function (startDate, endDate) {
        var startm = this.momentToDate(startDate, 'L'),
            endm = this.momentToDate(endDate, 'L'),
            dstart = new Date(startm),
            dend = new Date(endm);

        if (dend !== null && dstart !== null) {
            if (moment(dend).isBefore(dstart)) {
                return false;
            } else if (moment(dstart).isAfter(dend)) {
                return true;
            } else {
                return true;
            }
        }
    },

    getEndDate: function () {
        var datePickerEnd = $('.o-graph-opc__calendar-end').datepicker('getDate'),
            endDate;

        if (datePickerEnd !== null) {
            endDate = this.setMonthToNumber(datePickerEnd);
        } else {
            endDate = this.setMonthToNumber(new Date());
        }
        return endDate;
    },

    /* get month literal from month number 2 digits */
    formatMonth: function (date) {
        var format = this.momentToDate(date);
        moment.locale('fr');

        if (format.getDate() < 10) {
            format = moment(format).format('LL');
            format = '0'.concat(format);
        } else {
            format = moment(format).format('LL');
        }
        return format;
    },

    /* get month 2 digits from month literal */
    setMonthToNumber: function (el) {
        moment.locale('fr');
        var dateA = moment(el, 'LL').toDate();
        return moment(dateA).format('L');
    },

    /*  returns date based on preset dates options */
    setDate: function (endDate, choosenDate) {
        moment.locale('fr');
        var d = this.momentToDate(endDate, 'LL'),
            month,
            year;

        switch (choosenDate) {
            case 0:
                var year = d.getFullYear(),
                    firstDay = new Date(year, 0, 1);
                return moment(firstDay).subtract(1, 'days').format('L');
            case 1:
                month = d.setMonth(d.getMonth() - 1);
                return moment(month).subtract(1, 'days').format('L');

            case 2:
                month = d.setMonth(d.getMonth() - 3);
                return moment(month).subtract(1, 'days').format('L');

            case 3:
                month = d.setMonth(d.getMonth() - 6);
                return moment(month).subtract(1, 'days').format('L');
            case 4:
                year = d.setYear(d.getFullYear() - 1);
                return moment(year).subtract(1, 'days').format('L');
            case 5:
                year = d.setYear(d.getFullYear() - 3);
                return moment(year).subtract(1, 'days').format('L');

            case 6:
                year = d.setYear(d.getFullYear() - 5);
                return moment(year).subtract(1, 'days').format('L');
            default:
                console.log('default');
        }
    },

    /* If no index found in arraylist with date option - take the closest value */
    getPreviousDate: function (array, date) {
        moment.locale('fr');
        var ref = this.momentToDate(date, 'L'),
            _this = this,
            distance = Infinity,
            closest;

        for (i = 0; i <= array.length; i++) {
            var date = _this.momentToDate(array[i], 'LL'),
                diff = moment(ref).diff(date, 'days');

            if (diff < distance && diff > 0) {
                closest = array[i];
            }
        }
        if (closest === undefined) {
            closest = array[0];
        }
        return closest;
    },

    /*  returns date String from moment Object */
    momentToDate: function (date, format) {
        if (moment(date, 'LL', true).isValid()) {
            date = moment(date, 'LL').toDate();
        } else {
            date = moment(date, 'L').toDate();
        }
        return date;
    },

    getMonths: function () {
        var monthNames = ['janvier', 'fvrier', 'mars', 'avril', 'mai', 'juin', 'juillet', 'aot', 'septembre', 'octobre', 'novembre', 'dcembre'];
        return monthNames;
    },
};

/* Init component */
$(function () {
    $('.o-graph-opc').each(function () {
        var chart = new GraphOpc();
        chart.init();
    });
});

},{"../../components/carousel.js":54}],62:[function(require,module,exports){
function OpcSelector() {}

OpcSelector.prototype = {
    selectors: {
        currentContainer: '',
        opcContainer: $('.o-opc-selector'),
        dropdown: $('.m-dropdown'),
        dropdownContent: $('.m-overlay__content'),
        tableWrapper: $('.o-opc-selector').find('table'),
        tableHead: $('.o-opc-selector').find('th'),
        sortElement: $('.o-opc-selector').find('th').find('a'),
        tableRow: $('.o-opc-selector').find('tbody > tr'),
        tableCell: $('.o-opc-selector').find('tr').find('td'),
        panelOrderMobile: $('[data-mobile-order-panel]'),
        panelFilterMobile: $('[data-mobile-filter-panel]'),
    },
    state: { filters: [], desc: false },

    init: function () {
        this.bindEvents();
    },
    bindEvents: function () {
        var _this = this;

        $(window).on('load', function () {
            if ($(window).width() < 768) {
                _this.setDataAttr();
            }
        });

        /* update Filter number */
        $('body').on('change', '[data-filter-value]', function (e) {
            var filters = [];
            var parent = $(this).closest('.m-dropdown');

            parent.find('[data-filter-value]').removeAttr('aria-selected');
            parent.find('[data-filter-value]:checked').each(function () {
                filters.push($(this).data('filter-value'));
                $(this).attr('aria-selected', 'true');
            });

            _this.setFiltersBadge($(this).closest('.m-dropdown'), filters);
            _this.filterList(e);
            _this.setAriaCheckboxLabel($(this), filters);
        });

        $('[data-filter-reset]').on('click', function (e) {
            _this.resetFilter();
            _this.filterList(e);
            _this.updateNbResults();
        });

        /* Update table order on desktop view */
        $('.o-table--opc tr > th').on('click', function (e) {
            e.preventDefault();
            var $th = $(e.currentTarget);

            if ($(this).attr('data-sort-desc') === undefined) {
                _this.state.desc = false;
            }
            _this.attrDataSort($th);
            _this.sortResults($th);
        });

        /* Update table order on mobile view */
        $('[data-order-mobile]').on('click', function () {
            _this.showMobileOrderPanel();
        });

        // Hide panel order
        $('body').on('click', '[data-filter-show]', function (e) {
            e.preventDefault();
            $('#o-filter-button').prop('checked', false);
        });

        /* Mobile filter opc view */
        $('body').on('click', '[data-filter-hide-panel]', function (e) {
            e.preventDefault();
            _this.hideOrderMobilePanel();
        });

        /* Order table results in mobile view*/
        this.selectors.panelOrderMobile.find('.a-radio__item').on('click', function (e) {
            var $th = _this.selectors.tableHead.eq($(e.target).attr('data-index'));
            _this.toggleRadioDisplay(e.target);
            _this.attrDataSort($th);
            _this.sortResults($th);
        });
    },
    toggleRadioDisplay: function (el) {
        $(el).siblings().removeClass('a-radio__item--is-active');
        $(el).siblings().removeAttr('aria-selected');
        $(el).siblings().attr('tabindex', '-1');
        $(el).toggleClass('a-radio__item--is-active');
        $(el).attr({ 'tabindex': '0', 'aria-selected': 'true' });
    },
    showMobileOrderPanel() {
        this.selectors.panelOrderMobile.css('display', 'block');
        $('html').css('overflow', 'hidden');
    },
    hideOrderMobilePanel: function () {
        this.selectors.panelOrderMobile.css('display', 'none');
        $('html').css('overflow', 'auto');
    },
    setFiltersBadge: function (el, filters) {
        var filterBadge = el.find('[data-filter-badge-number]');

        if (filters.length > 0) {
            filterBadge.parent().addClass('a-input__panel--active');
            filterBadge.addClass('a-badge--is-visible');
        } else {
            this.resetFiltersBadge();
            filterBadge.parent().removeClass('a-input__panel--active');
        }
        filterBadge.html(filters.length);
    },
    resetFiltersBadge: function () {
        $('[data-filter-badge-number]').removeClass('a-badge--is-visible');
    },
    resetFilter: function () {
        this.resetFiltersBadge();
        this.selectors.opcContainer.find('tbody > tr').each(function () {
            $(this).css('display', 'table-row');
        });
        this.selectors.opcContainer.find('.u-checkbox__trigger').prop('checked', false);
        $('[data-filter-value]').prop('checked', false);

        this.selectors.dropdown.each(function () {
            var $input = $(this).find('.a-input__panel');
            if ($input.hasClass('a-input__panel--active')) {
                $input.removeClass('a-input__panel--active');
            }
        });
    },
    filterList: function (e) {
        var _this = this,
            elt_a = '',
            idx_a = '',
            type = '',
            filters,
            filterStack = [];

        $('tbody').find('tr').show();
        this.selectors.dropdownContent.each(function (idx, elt) {
            idx_a = idx;
            elt_a = elt;
            type = $(elt).attr('data-type');
            filters = [];

            $(elt)
                .find('[type=checkbox]:checked')
                .each(function (idx2, elt2) {
                    var name = $(elt2).attr('data-filter-value');
                    filters.push(name);
                    filterStack.push(name);
                });

            if (filters.length) {
                var rowArray = [];
                $('tbody tr').each(function (i) {
                    var $row = $(this);
                    var firstTd = $row.find('td').first().text().trim();

                    $row.find('td[data-type="' + type + '"]').each(function (elt2) {
                        for (var i = 0; i < filters.length; i++) {
                            if (
                                $(this).text().trim().indexOf(filters[i].trim()) !== -1 ||
                                ($(this).data('text') !== undefined && $(this).data('text').trim().indexOf(filters[i].trim()) !== -1)
                            ) {
                                var rowName = $(this).parent().find('td').first().text().trim();
                                rowArray.push(rowName);
                            }
                        }
                    });

                    if (rowArray.indexOf(firstTd) !== -1) {
                        $row.attr('data-visible', 'visible');
                    } else {
                        $row.css('display', 'none');
                    }
                });
            }
        });

        _this.updateNbResults();
        sessionStorage.setItem('opcvm_filters', filterStack); // save selected filters during user session
    },

    updateNbResults: function () {
        var _this = this;

        $('[data-results-placeholder]').each(function () {
            var txt,
                $resultLine = $(this).find('span'),
                $txtResultsSpan = $resultLine.last(),
                $nbResultsSpan = $resultLine.first(),
                nbr_results_value = _this.selectors.tableWrapper.find('tbody > tr:visible').length,
                noTxt = $(this).attr('data-no-result-txt') === undefined;

            switch (nbr_results_value) {
                case 0:
                    txt = _this.selectors.opcContainer.attr('data-noresults');
                    $nbResultsSpan.empty();
                    noTxt ? $txtResultsSpan.text(txt) : $(this).find('span').css('display', 'none');
                    break;
                case 1:
                    txt = _this.selectors.opcContainer.attr('data-oneresults');
                    $nbResultsSpan.text(nbr_results_value);
                    noTxt ? $txtResultsSpan.text(txt) : $(this).find('span').css('display', 'block');
                    break;
                default:
                    txt = _this.selectors.opcContainer.attr('data-multiple-results');
                    $nbResultsSpan.text(nbr_results_value);
                    noTxt ? $txtResultsSpan.text(txt) : $(this).find('span').css('display', 'block');
                    break;
            }
        });
    },

    /* set data-type on each td element depending on th element text for mobile display */
    setDataAttr: function () {
        var dataArray = [],
            _this = this;

        _this.selectors.tableHead.each(function () {
            var $th = $(this);

            dataArray.push({
                type: $th.data('type'),
                txt: $th.find('span').last().text(),
            });
        });
        _this.selectors.tableRow.find('td').each(function () {
            var $this = $(this),
                type = $this.data('type');
            _this.matchTableCellType(dataArray, type, $this);
            _this.selectors.tableWrapper.css('display', 'block');
        });
    },
    matchTableCellType: function (array, type, el) {
        var i, j, item;

        for (i = 0, j = array.length; i < j; i++) {
            item = array[i];
            if (typeof item.type !== 'undefined' && item.type === type) {
                return el.attr('data-type-mobile', item.txt);
            }
        }
    },
    attrDataSort: function (el) {
        var _this = this;

        if (el.attr('data-sort-desc') === 'false') {
            this.state.desc = true;
            el.attr('data-sort-desc', true);
        } else {
            this.state.desc = false;
            el.attr('data-sort-desc', false);
        }
        el.siblings().removeAttr('data-sort-desc');

        if ($(window).width() < 768) {
            $('[data-filteropc-name]').each(function () {
                $(this).text(el.find('span').last().text());
            });
            _this.hideOrderMobilePanel();
        }
    },
    /* sort results logic */
    sortResults: function ($th) {
        var resultsArray = [],
            $tBody = $th.parents('table').find('tbody'),
            allTboby = $('.o-tabs').find('tbody'),
            thIndex = $th.closest('th').index();

        function sortResults(a, b) {
            if (a.type === 'text') {
                var stra = a.string.replace(/&gt;|&lt;/g, '').trim();
                var strb = b.string.replace(/&gt;|&lt;/g, '').trim();

                if (stra < strb) {
                    return -1;
                }
                if (stra > strb) {
                    return 1;
                }
                return 0;
            } else if (a.type === 'number') {
                if (a.string.trim() === '-') {
                    a.string = '0';
                }

                var c = parseFloat(a.string.replace(/,/g, '.')).toFixed(2);
                var d = parseFloat(b.string.replace(/,/g, '.')).toFixed(2);
                return c - d;
            } else {
                var e = new Date(a.string);
                var f = new Date(b.string);

                if (e < f) {
                    return -1;
                }
                if (e > f) {
                    return 1;
                }
            }
        }

        $tBody.find('td:nth-child(' + (thIndex + 1) + ')').each(function (idx, elt) {
            resultsArray.push({
                'idx': $(elt).closest('tr').index(),
                'type': $(elt).data('value-type'),
                'string': $(elt)
                    .html()
                    .replace(/(<([^>]+)>)/gi, ''),
            });
        });
        resultsArray.sort(sortResults);

        if (this.state.desc) {
            resultsArray.reverse();
        }
        allTboby.each(function () {
            var newList = $('<div></div>');
            for (var i = 0; i < resultsArray.length; i++) {
                newList.append(
                    $(this)
                        .find('tr:nth-child(' + (resultsArray[i].idx + 1) + ')')
                        .clone()
                );
            }
            $(this).empty().append(newList.html());
        });
    },
    setAriaCheckboxLabel: function (el, type) {
        var trigger = el.closest('.m-dropdown').find('label').first();

        if (type.length > 0) {
            var labelEnd = trigger.attr('data-i18n-suffix');
            trigger.children('[data-suffix-label]').text(labelEnd);
        } else {
            trigger.children('[data-suffix-label]').text('');
        }
    },
};

$(function () {
    var opcvm = new OpcSelector();
    opcvm.init();
});

},{}],63:[function(require,module,exports){
function Select() {}

Select.prototype = {
    init: function () {
        this.event();
    },
    selectors: {
        svgPath: '/etc.clientlibs/labanquepostale/commons/clientlibs/base/resources/svg-icons.svg',
    },
    event: function () {
        var that = this;
        //close other dropdown when opening/closing one
        $('body').on('change', '.m-dropdown .u-checkbox__trigger', function (e) {
            e.preventDefault();
            var $this = $(this);
            var state = $this.prop('checked'),
                trigger = $this.closest('.m-dropdown').find('.a-input__trigger__item__active');

            if (state) {
                // remove trigger label on open
                trigger.hide();
            }
            $('.m-dropdown .u-checkbox__trigger').prop('checked', false);
            $('.m-dropdown .u-checkbox__trigger')
                .not($this)
                .siblings('svg')
                .children('use')
                .attr('xlink:href', that.selectors.svgPath + '#ic-interface-chevron-down');
            $this.prop('checked', state);

            if ($this.prop('checked') === false) {
                $this.siblings('label').attr('aria-expanded', 'false');
            } else {
                $this.siblings('label').attr('aria-expanded', 'true');
            }
        });

        //set selected style on selected dropdown & match selected option in select
        $('body').on('click', '.m-dropdown .a-radio__item', function () {
            var $this = $(this);
            var state = $this.hasClass('a-radio__item--is-active'),
                value = '';

            $this.siblings('.a-radio__item').removeClass('a-radio__item--is-active').removeAttr('aria-selected');

            if (!state) {
                $this.addClass('a-radio__item--is-active').attr('aria-selected', 'true');
                value = $this.data('value');
            }
            var select = $this.closest('.m-dropdown').find('.m-dropdown__select');
            select.val(value).change();
        });

        // close other dropdowns on keyboard navigation
        $('.m-dropdown .js-focus').on('focus', function (e) {
            var checks = $('.m-dropdown .u-checkbox__trigger').not($(this));
            checks.each(function () {
                $(this).prop('checked', false);
                $(this).closest('.m-dropdown').find('.js-focus').attr('aria-expanded', 'false');

                if ($(window).width() >= 768) {
                    $(this)
                        .closest('.m-dropdown')
                        .find('svg')
                        .first()
                        .children('use')
                        .attr('xlink:href', that.selectors.svgPath + '#ic-interface-chevron-down');
                }
            });
            $('.m-dropdown .a-radio__item').attr('tabindex', '-1');
        });

        // close other dropdowns on keyboard navigation
        $('.js-button--reset').on('focus', function () {
            var checks = $('.m-dropdown .u-checkbox__trigger').not($(this));
            checks.each(function () {
                $(this).prop('checked', false);
                $(this).closest('.m-dropdown').find('.js-focus').attr('aria-expanded', 'false');
                $(this)
                    .closest('.m-dropdown')
                    .find('svg')
                    .children('use')
                    .attr('xlink:href', that.selectors.svgPath + '#ic-interface-chevron-down');
                $(this).next('label').removeClass('a-input__panel--active');
            });
            $('.m-dropdown .a-radio__item').attr('tabindex', '-1');
        });

        //unselect dropdown on click on dropdown label
        $('body').on('click', '.m-dropdown .a-input__trigger', function () {
            var $this = $(this);

            var svg = $this.closest('.m-dropdown__label').siblings('svg').children('use');
            if ($this.closest('.m-dropdown').find('.u-checkbox__trigger').is(':checked')) {
                $this.siblings('.m-dropdown__content').find('.a-radio__item').removeClass('a-radio__item--is-active').removeAttr('aria-selected');
                $this.siblings('.m-dropdown__content').find('.a-radio__item').attr('tabindex', '-1');
                $this.attr('aria-expanded', 'false');

                var select = $this.closest('.m-dropdown').find('.m-dropdown__select');
                svg.attr('xlink:href', that.selectors.svgPath + '#ic-interface-chevron-down');
                select.trigger('change');
            } else {
                $this.siblings('.m-dropdown__content').find('.a-radio__item').attr('tabindex', '0');
                svg.attr('xlink:href', that.selectors.svgPath + '#ic-interface-chevron-up');
                $this.attr('aria-expanded', 'true');
                $this.blur();

                setTimeout(function () {
                    $this.siblings('.m-dropdown__content').find('.a-radio__item').first().focus().addClass('is--focused');
                }, 300);
            }
        });

        //match select change to desktop  dropdown
        $('body').on('change', '.m-dropdown__select', function () {
            var $this = $(this);
            $this.siblings('.m-dropdown__label').find('.a-radio__item').removeClass('a-radio__item--is-active').removeAttr('aria-selected');

            $this
                .siblings('.m-dropdown__label')
                .find('.a-radio__item[data-value="' + $this.val() + '"]')
                .addClass('a-radio__item--is-active')
                .attr('aria-selected', 'true');

            //set Accessibility label
            var trigger = $this.parent().find('.js-input__trigger__item__active');
            var labeltype = $this.prev('p').text();

            if ($this.val() !== '') {
                var labelValue = $this.find('option:selected').text();
                var labelStart = 'Slectionnez une ';
                var arialabel = labelStart.concat(labeltype);
                trigger.attr('aria-label', labelValue + ' - ' + arialabel);
                trigger.text(labelValue).css('display', 'block');
            }
        });

        //close dropdown if click elsewhere
        $(document).on('click', function (e) {
            if ($(e.target).closest('.m-dropdown').length === 0) {
                $('.m-dropdown .u-checkbox__trigger').prop('checked', false);
                $('.m-dropdown .a-input__trigger')
                    .closest('.m-dropdown__label')
                    .siblings('svg')
                    .children('use')
                    .attr('xlink:href', that.selectors.svgPath + '#ic-interface-chevron-down');

                $('.m-dropdown').find('.a-radio__item').data('tabindex', '-1');
                $('.m-dropdown').find('.m-overlay__item').data('tabindex', '-1');
            }
        });
        $('body').on('keypress', '.m-dropdown .a-input__trigger', function (e) {
            // enter & space
            if (e.which === 13 || e.which === 32) {
                e.preventDefault();
                $(this).trigger('click');
            }
        });
        $('body').on('keydown', '.m-dropdown .a-radio__item', function (e) {
            // Esc
            if (e.which === 27) {
                $(this).closest('.m-dropdown').find('.u-checkbox__trigger').prop('checked', false);
                $('.m-dropdown .a-radio__item').attr('tabindex', '-1');
                $(this).closest('.m-dropdown__content').siblings('.a-input__trigger').focus();
            }
            if (e.which === 13 || e.which === 32) {
                e.preventDefault();
                $(this).trigger('click');
                $('.m-dropdown .a-radio__item').attr('tabindex', '-1');
                $(this).closest('.m-dropdown__content').siblings('.a-input__trigger').focus();
            }
        });
        $('body').on('keydown', '.m-dropdown .a-input__panel', function (e) {
            // enter OR space OR click
            if (e.which === 13 || e.which === 32) {
                e.preventDefault();
                $(this).trigger('click');
            }
            if (e.which === 27) {
                $(this).closest('.m-dropdown').find('.u-checkbox__trigger').prop('checked', false);
                $('.m-dropdown .a-radio__item').attr('tabindex', '-1');
                $(this).closest('.m-dropdown__content').siblings('.a-input__trigger').focus();
            }
        });
        $('body').on('keydown', '[data-filter-tag-value]', function (e) {
            // enter & space
            if (e.which === 13 || e.which === 32) {
                e.preventDefault();
                $(this).trigger('click');
            }
            //Esc
            if (e.which === 27) {
                $(this).closest('.m-dropdown').find('.u-checkbox__trigger').prop('checked', false);
                $('.m-dropdown .a-radio__item').attr('tabindex', '-1');
                $(this).closest('.m-dropdown').find('.a-input__panel').focus();
            }
        });
        $('body').on('keydown', '[data-filter-typology-value]', function (e) {
            // enter & space
            if (e.which === 13 || e.which === 32) {
                e.preventDefault();
                $(this).trigger('click');
            }
            //Esc
            if (e.which === 27) {
                $(this).closest('.m-dropdown').find('.u-checkbox__trigger').prop('checked', false);
                $('.m-dropdown .a-radio__item').attr('tabindex', '-1');
                $(this).closest('.m-dropdown').find('.a-input__panel').focus();
            }
        });
        $('body').on('keypress', '.a-input--toggle__container', function (e) {
            // enter & space
            if (e.which === 13 || e.which === 32) {
                $(this).trigger('click');
            }
        });

        $('body').on('keydown', '.m-dropdown .js-focus', function (e) {
            // Shiftab
            if (e.which === 9 && e.shiftKey) {
                $(this).closest('.m-dropdown').find('.u-checkbox__trigger').prop('checked', false);
                $('.m-dropdown .a-radio__item').attr('tabindex', '-1');
            }
        });
    },
};

/**
 * init Select componant
 */
(function ($) {
    if ($('.m-dropdown').length) {
        var select = new Select();
        select.init();
    }
})(window.jQuery);

},{}],64:[function(require,module,exports){
/*!
 * swiped-events.js - v@version@
 * Pure JavaScript swipe events
 * https://github.com/john-doherty/swiped-events
 * @inspiration https://stackoverflow.com/questions/16348031/disable-scrolling-when-touch-moving-certain-element
 * @author John Doherty <www.johndoherty.info>
 * @license MIT
 */
(function (window, document) {
    'use strict';

    // patch CustomEvent to allow constructor creation (IE/Chrome)
    if (typeof window.CustomEvent !== 'function') {
        window.CustomEvent = function (event, params) {
            params = params || { bubbles: false, cancelable: false, detail: undefined };

            var evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
            return evt;
        };

        window.CustomEvent.prototype = window.Event.prototype;
    }

    document.addEventListener('touchstart', handleTouchStart, false);
    document.addEventListener('touchmove', handleTouchMove, false);
    document.addEventListener('touchend', handleTouchEnd, false);

    var xDown = null;
    var yDown = null;
    var xDiff = null;
    var yDiff = null;
    var timeDown = null;
    var startEl = null;

    /**
     * Fires swiped event if swipe detected on touchend
     * @param {object} e - browser event object
     * @returns {void}
     */
    function handleTouchEnd(e) {
        // if the user released on a different target, cancel!
        if (startEl !== e.target) return;

        var swipeThreshold = parseInt(getNearestAttribute(startEl, 'data-swipe-threshold', '20'), 10); // default 20px
        var swipeTimeout = parseInt(getNearestAttribute(startEl, 'data-swipe-timeout', '500'), 10); // default 500ms
        var timeDiff = Date.now() - timeDown;
        var eventType = '';
        var changedTouches = e.changedTouches || e.touches || [];

        if (Math.abs(xDiff) > Math.abs(yDiff)) {
            // most significant
            if (Math.abs(xDiff) > swipeThreshold && timeDiff < swipeTimeout) {
                if (xDiff > 0) {
                    eventType = 'swiped-left';
                } else {
                    eventType = 'swiped-right';
                }
            }
        } else if (Math.abs(yDiff) > swipeThreshold && timeDiff < swipeTimeout) {
            if (yDiff > 0) {
                eventType = 'swiped-up';
            } else {
                eventType = 'swiped-down';
            }
        }

        if (eventType !== '') {
            var eventData = {
                dir: eventType.replace(/swiped-/, ''),
                touchType: (changedTouches[0] || {}).touchType || 'direct',
                xStart: parseInt(xDown, 10),
                xEnd: parseInt((changedTouches[0] || {}).clientX || -1, 10),
                yStart: parseInt(yDown, 10),
                yEnd: parseInt((changedTouches[0] || {}).clientY || -1, 10),
            };

            // fire `swiped` event event on the element that started the swipe
            startEl.dispatchEvent(new CustomEvent('swiped', { bubbles: true, cancelable: true, detail: eventData }));

            // fire `swiped-dir` event on the element that started the swipe
            startEl.dispatchEvent(new CustomEvent(eventType, { bubbles: true, cancelable: true, detail: eventData }));
        }

        // reset values
        xDown = null;
        yDown = null;
        timeDown = null;
    }

    /**
     * Records current location on touchstart event
     * @param {object} e - browser event object
     * @returns {void}
     */
    function handleTouchStart(e) {
        // if the element has data-swipe-ignore="true" we stop listening for swipe events
        if (e.target.getAttribute('data-swipe-ignore') === 'true') return;

        startEl = e.target;

        timeDown = Date.now();
        xDown = e.touches[0].clientX;
        yDown = e.touches[0].clientY;
        xDiff = 0;
        yDiff = 0;
    }

    /**
     * Records location diff in px on touchmove event
     * @param {object} e - browser event object
     * @returns {void}
     */
    function handleTouchMove(e) {
        if (!xDown || !yDown) return;

        var xUp = e.touches[0].clientX;
        var yUp = e.touches[0].clientY;

        xDiff = xDown - xUp;
        yDiff = yDown - yUp;
    }

    /**
     * Gets attribute off HTML element or nearest parent
     * @param {object} el - HTML element to retrieve attribute from
     * @param {string} attributeName - name of the attribute
     * @param {any} defaultValue - default value to return if no match found
     * @returns {any} attribute value or defaultValue
     */
    function getNearestAttribute(el, attributeName, defaultValue) {
        // walk up the dom tree looking for attributeName
        while (el && el !== document.documentElement) {
            var attributeValue = el.getAttribute(attributeName);

            if (attributeValue) {
                return attributeValue;
            }

            el = el.parentNode;
        }

        return defaultValue;
    }
})(window, document);

},{}],65:[function(require,module,exports){
/*
 * multi line text overflow ellipsis (on desktop)
 *
 */

var utils = require('../librairies/utils.js');

function Clamp() {}
Clamp.prototype = {
    clampSelector: '[data-clamp]',
    clampList: [],
    ellipsis: '...',

    init: function () {
        var that = this,
            clampSelector = $(that.clampSelector);

        that.clampList = [];

        if (clampSelector.length) {
            clampSelector.each(function () {
                var clamp = new ClampElement($(this), that.ellipsis);
                if ($(window).width() >= 768) {
                    clamp.setEllipsis();
                }
                that.clampList.push(clamp);
            });
        }
    },
    event: function () {
        var that = this;

        //on resize
        $(window).resize(function () {
            utils.waitForFinalEvent(
                function () {
                    that.clampList.forEach(function (clamp) {
                        if ($(window).width() < 768) {
                            clamp.removeEllipsis();
                        } else {
                            clamp.setEllipsis();
                        }
                    });
                },
                300,
                'resizeClamp'
            );
        });

        //* Custom event to be triggerred elsewhere *//
        //usage :  $(document).trigger("reclamp");
        $(document).on('reclamp', function () {
            that.init();
        });
    },
};
/**
 * @param {HTMLElement} element Question template view
 * @param {String} ellipsis ... string
 */
function ClampElement(element, ellipsis) {
    this.element = element;
    this.fontSize = parseInt(element.css('font-size'));
    this.fontWeight = element.css('font-weight');
    this.letterSpacing = element.css('letter-spacing');
    this.clamp = element.data('clamp'); //number of line to be clamped
    this.maxHeight = this.fontSize * this.clamp;
    this.ellipsis = ellipsis;

    if (!element.data('clamp-is-truncated')) {
        this.content = this.element.text();
    } else {
        this.element.data('clamp-is-truncated', '');
    }
}
ClampElement.prototype = {
    content: '',
    element: null,
    fontSize: 0,
    fontWeight: 0,
    letterSpacing: 0,
    clamp: 0,
    maxHeight: 0,
    isClamped: false,
    ellipsis: '...',

    removeEllipsis: function () {
        this.element.html(this.content);
        this.element.css('max-height', '');
    },

    setEllipsis: function () {
        var that = this;

        that.isClamped = false;
        this.element.css('max-height', this.element.css('line-height') * this.clamp + 'px');

        var clone = $('<div>', { 'class': 'u-js-hidden' });

        var elementText = this.content;
        clone.empty();

        for (var i = 0; i < elementText.length; i++) {
            clone.append('<span>' + elementText[i] + '</span>');
        }

        clone.width(this.element.width());
        clone.height(this.maxHeight);
        clone.css('font-size', this.fontSize);
        clone.css('font-weight', this.fontWeight);
        clone.css('letter-spacing', this.letterSpacing);
        clone.css('line-height', 1);
        clone.css('font-family', this.element.css('font-family'));

        $('body').append(clone);

        var isOver = true;
        var cloneVisibleContent = clone.find('span').filter(function (index) {
            if ($(this).position().top + that.fontSize < clone.position().top + that.maxHeight && isOver) {
                return $(this);
            }
            isOver = false;
            that.isClamped = true;
        });

        if (that.isClamped) {
            that.element.html(this.content.slice(0, cloneVisibleContent.length - that.ellipsis.length) + that.ellipsis);
        }

        clone.remove();
    },
};

/**
 * init Clamp
 */

(function ($) {
    var clamp = new Clamp();

    if (document.fonts === undefined) {
        //if ie11
        clamp.init();
    }
    clamp.event();
})(window.jQuery);

},{"../librairies/utils.js":67}],66:[function(require,module,exports){
var isIE11 = !!window.MSInputMethodContext && !!document.documentMode;

/*** Polyfill for css object-fit:cover ie11 ***/
if ('objectFit' in document.documentElement.style === false) {
    document.addEventListener('DOMContentLoaded', function () {
        $('img[data-object-fit]').each(function () {
            var img = document.createElement('div');
            $(img).addClass('polyfill--img-cover');
            $(img).css('background-image', "url('" + $(this).get(0).src + "')");

            $(this).parent().parent().append(img);
            $(this).parent().remove();
        });
    });
}

/*** Polyfill for css position:sticky ie11 ***/
if (isIE11) {
    document.addEventListener('DOMContentLoaded', function () {
        $('[sticky]').each(function () {
            var stickyTop = parseInt($(this).css('top'));

            $(this).stickybits({
                stickyBitStickyOffset: stickyTop,
            });
        });
    });
}

/*** Polyfill js Array.find ***/
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find#Polyfill
if (!Array.prototype.find) {
    Object.defineProperty(Array.prototype, 'find', {
        value: function (predicate) {
            // 1. Let O be ? ToObject(this value).
            if (this === null) {
                throw TypeError('"this" is null or not defined');
            }

            var o = Object(this);

            // 2. Let len be ? ToLength(? Get(O, "length")).
            var len = o.length >>> 0;

            // 3. If IsCallable(predicate) is false, throw a TypeError exception.
            if (typeof predicate !== 'function') {
                throw TypeError('predicate must be a function');
            }

            // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
            var thisArg = arguments[1];

            // 5. Let k be 0.
            var k = 0;

            // 6. Repeat, while k < len
            while (k < len) {
                // a. Let Pk be ! ToString(k).
                // b. Let kValue be ? Get(O, Pk).
                // c. Let testResult be ToBoolean(? Call(predicate, T,  kValue, k, O )).
                // d. If testResult is true, return kValue.
                var kValue = o[k];
                if (predicate.call(thisArg, kValue, k, o)) {
                    return kValue;
                }
                // e. Increase k by 1.
                k++;
            }

            // 7. Return undefined.
            return undefined;
        },
        configurable: true,
        writable: true,
    });
}

/*** Polyfill js Array.filter ***/
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Polyfill
if (!Array.prototype.filter) {
    Array.prototype.filter = function (func, thisArg) {
        'use strict';
        if (!((typeof func === 'Function' || typeof func === 'function') && this)) {
            throw new TypeError();
        }

        var len = this.length >>> 0,
            res = new Array(len), // preallocate array
            t = this,
            c = 0,
            i = -1;

        var kValue;
        if (thisArg === undefined) {
            while (++i !== len) {
                // checks to see if the key was set
                if (i in this) {
                    kValue = t[i]; // in case t is changed in callback
                    if (func(t[i], i, t)) {
                        res[c++] = kValue;
                    }
                }
            }
        } else {
            while (++i !== len) {
                // checks to see if the key was set
                if (i in this) {
                    kValue = t[i];
                    if (func.call(thisArg, t[i], i, t)) {
                        res[c++] = kValue;
                    }
                }
            }
        }

        res.length = c; // shrink down array to proper size
        return res;
    };
}

/*** Polyfill js Array.map ***/
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Polyfill
if (!Array.prototype.map) {
    Array.prototype.map = function (callback /*, thisArg*/) {
        var T, A, k;

        if (this === null) {
            throw new TypeError('this is null or not defined');
        }

        // 1. Let O be the result of calling ToObject passing the |this|
        //    value as the argument.
        var O = Object(this);

        // 2. Let lenValue be the result of calling the Get internal
        //    method of O with the argument "length".
        // 3. Let len be ToUint32(lenValue).
        var len = O.length >>> 0;

        // 4. If IsCallable(callback) is false, throw a TypeError exception.
        // See: http://es5.github.com/#x9.11
        if (typeof callback !== 'function') {
            throw new TypeError(callback + ' is not a function');
        }

        // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
        if (arguments.length > 1) {
            T = arguments[1];
        }

        // 6. Let A be a new array created as if by the expression new Array(len)
        //    where Array is the standard built-in constructor with that name and
        //    len is the value of len.
        A = new Array(len);

        // 7. Let k be 0
        k = 0;

        // 8. Repeat, while k < len
        while (k < len) {
            var kValue, mappedValue;

            // a. Let Pk be ToString(k).
            //   This is implicit for LHS operands of the in operator
            // b. Let kPresent be the result of calling the HasProperty internal
            //    method of O with argument Pk.
            //   This step can be combined with c
            // c. If kPresent is true, then
            if (k in O) {
                // i. Let kValue be the result of calling the Get internal
                //    method of O with argument Pk.
                kValue = O[k];

                // ii. Let mappedValue be the result of calling the Call internal
                //     method of callback with T as the this value and argument
                //     list containing kValue, k, and O.
                mappedValue = callback.call(T, kValue, k, O);

                // iii. Call the DefineOwnProperty internal method of A with arguments
                // Pk, Property Descriptor
                // { Value: mappedValue,
                //   Writable: true,
                //   Enumerable: true,
                //   Configurable: true },
                // and false.

                // In browsers that support Object.defineProperty, use the following:
                // Object.defineProperty(A, k, {
                //   value: mappedValue,
                //   writable: true,
                //   enumerable: true,
                //   configurable: true
                // });

                // For best browser support, use the following:
                A[k] = mappedValue;
            }
            // d. Increase k by 1.
            k++;
        }

        // 9. return A
        return A;
    };
}
/*** Polyfill js Object.entries ***/
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries#Polyfill
if (!Object.entries) {
    Object.entries = function (obj) {
        var ownProps = Object.keys(obj),
            i = ownProps.length,
            resArray = new Array(i); // preallocate the Array
        while (i--) resArray[i] = [ownProps[i], obj[ownProps[i]]];

        return resArray;
    };
}

/**
 * Generate svg on IE
 */
function SvgPolyfill() {}
SvgPolyfill.prototype = {
    init: function () {
        var ua = detect.parse(navigator.userAgent);
        if (ua.browser.family === 'IE') {
            svg4everybody({
                nosvg: true, // shiv <svg> and <use> elements and use image fallbacks
                polyfill: true, // polyfill <use> elements for External Content
            });
        }
    },
};
/**
 * init Svg
 */
(function ($) {
    var svg = new SvgPolyfill();
    svg.init();
})(window.jQuery);

if (window.NodeList && !NodeList.prototype.forEach) {
    NodeList.prototype.forEach = Array.prototype.forEach;
}

if (!Element.prototype.matches) Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

if (!Element.prototype.closest)
    Element.prototype.closest = function (s) {
        var el = this;
        if (!document.documentElement.contains(el)) return null;
        do {
            if (el.matches(s)) return el;
            el = el.parentElement || el.parentNode;
        } while (el !== null && el.nodeType == 1);
        return null;
    };

/**
 * Applies the :focus-visible polyfill at the given scope.
 * A scope in this case is either the top-level Document or a Shadow Root.
 *
 * @param {(Document|ShadowRoot)} scope
 * @see https://github.com/WICG/focus-visible
 */
function applyFocusVisiblePolyfill(scope) {
    var hadKeyboardEvent = true;
    var hadFocusVisibleRecently = false;
    var hadFocusVisibleRecentlyTimeout = null;

    var inputTypesAllowlist = {
        text: true,
        search: true,
        url: true,
        tel: true,
        email: true,
        password: true,
        number: true,
        date: true,
        month: true,
        week: true,
        time: true,
        datetime: true,
        'datetime-local': true,
    };

    /**
     * Helper function for legacy browsers and iframes which sometimes focus
     * elements like document, body, and non-interactive SVG.
     * @param {Element} el
     */
    function isValidFocusTarget(el) {
        if (el && el !== document && el.nodeName !== 'HTML' && el.nodeName !== 'BODY' && 'classList' in el && 'contains' in el.classList) {
            return true;
        }
        return false;
    }

    /**
     * Computes whether the given element should automatically trigger the
     * `focus-visible` class being added, i.e. whether it should always match
     * `:focus-visible` when focused.
     * @param {Element} el
     * @return {boolean}
     */
    function focusTriggersKeyboardModality(el) {
        var type = el.type;
        var tagName = el.tagName;

        if (tagName === 'INPUT' && inputTypesAllowlist[type] && !el.readOnly) {
            return true;
        }

        if (tagName === 'TEXTAREA' && !el.readOnly) {
            return true;
        }

        if (el.isContentEditable) {
            return true;
        }

        return false;
    }

    /**
     * Add the `focus-visible` class to the given element if it was not added by
     * the author.
     * @param {Element} el
     */
    function addFocusVisibleClass(el) {
        if (el.classList.contains('focus-visible')) {
            return;
        }
        el.classList.add('focus-visible');
        el.setAttribute('data-focus-visible-added', '');
    }

    /**
     * Remove the `focus-visible` class from the given element if it was not
     * originally added by the author.
     * @param {Element} el
     */
    function removeFocusVisibleClass(el) {
        if (!el.hasAttribute('data-focus-visible-added')) {
            return;
        }
        el.classList.remove('focus-visible');
        el.removeAttribute('data-focus-visible-added');
    }

    /**
     * If the most recent user interaction was via the keyboard;
     * and the key press did not include a meta, alt/option, or control key;
     * then the modality is keyboard. Otherwise, the modality is not keyboard.
     * Apply `focus-visible` to any current active element and keep track
     * of our keyboard modality state with `hadKeyboardEvent`.
     * @param {KeyboardEvent} e
     */
    function onKeyDown(e) {
        if (e.metaKey || e.altKey || e.ctrlKey) {
            return;
        }

        if (isValidFocusTarget(scope.activeElement)) {
            addFocusVisibleClass(scope.activeElement);
        }

        hadKeyboardEvent = true;
    }

    /**
     * If at any point a user clicks with a pointing device, ensure that we change
     * the modality away from keyboard.
     * This avoids the situation where a user presses a key on an already focused
     * element, and then clicks on a different element, focusing it with a
     * pointing device, while we still think we're in keyboard modality.
     * @param {Event} e
     */
    function onPointerDown(e) {
        hadKeyboardEvent = false;
    }

    /**
     * On `focus`, add the `focus-visible` class to the target if:
     * - the target received focus as a result of keyboard navigation, or
     * - the event target is an element that will likely require interaction
     *   via the keyboard (e.g. a text box)
     * @param {Event} e
     */
    function onFocus(e) {
        // Prevent IE from focusing the document or HTML element.
        if (!isValidFocusTarget(e.target)) {
            return;
        }

        if (hadKeyboardEvent || focusTriggersKeyboardModality(e.target)) {
            addFocusVisibleClass(e.target);
        }
    }

    /**
     * On `blur`, remove the `focus-visible` class from the target.
     * @param {Event} e
     */
    function onBlur(e) {
        if (!isValidFocusTarget(e.target)) {
            return;
        }

        if (e.target.classList.contains('focus-visible') || e.target.hasAttribute('data-focus-visible-added')) {
            // To detect a tab/window switch, we look for a blur event followed
            // rapidly by a visibility change.
            // If we don't see a visibility change within 100ms, it's probably a
            // regular focus change.
            hadFocusVisibleRecently = true;
            window.clearTimeout(hadFocusVisibleRecentlyTimeout);
            hadFocusVisibleRecentlyTimeout = window.setTimeout(function () {
                hadFocusVisibleRecently = false;
            }, 100);
            removeFocusVisibleClass(e.target);
        }
    }

    /**
     * If the user changes tabs, keep track of whether or not the previously
     * focused element had .focus-visible.
     * @param {Event} e
     */
    function onVisibilityChange(e) {
        if (document.visibilityState === 'hidden') {
            // If the tab becomes active again, the browser will handle calling focus
            // on the element (Safari actually calls it twice).
            // If this tab change caused a blur on an element with focus-visible,
            // re-apply the class when the user switches back to the tab.
            if (hadFocusVisibleRecently) {
                hadKeyboardEvent = true;
            }
            addInitialPointerMoveListeners();
        }
    }

    /**
     * Add a group of listeners to detect usage of any pointing devices.
     * These listeners will be added when the polyfill first loads, and anytime
     * the window is blurred, so that they are active when the window regains
     * focus.
     */
    function addInitialPointerMoveListeners() {
        document.addEventListener('mousemove', onInitialPointerMove);
        document.addEventListener('mousedown', onInitialPointerMove);
        document.addEventListener('mouseup', onInitialPointerMove);
        document.addEventListener('pointermove', onInitialPointerMove);
        document.addEventListener('pointerdown', onInitialPointerMove);
        document.addEventListener('pointerup', onInitialPointerMove);
        document.addEventListener('touchmove', onInitialPointerMove);
        document.addEventListener('touchstart', onInitialPointerMove);
        document.addEventListener('touchend', onInitialPointerMove);
    }

    function removeInitialPointerMoveListeners() {
        document.removeEventListener('mousemove', onInitialPointerMove);
        document.removeEventListener('mousedown', onInitialPointerMove);
        document.removeEventListener('mouseup', onInitialPointerMove);
        document.removeEventListener('pointermove', onInitialPointerMove);
        document.removeEventListener('pointerdown', onInitialPointerMove);
        document.removeEventListener('pointerup', onInitialPointerMove);
        document.removeEventListener('touchmove', onInitialPointerMove);
        document.removeEventListener('touchstart', onInitialPointerMove);
        document.removeEventListener('touchend', onInitialPointerMove);
    }

    /**
     * When the polfyill first loads, assume the user is in keyboard modality.
     * If any event is received from a pointing device (e.g. mouse, pointer,
     * touch), turn off keyboard modality.
     * This accounts for situations where focus enters the page from the URL bar.
     * @param {Event} e
     */
    function onInitialPointerMove(e) {
        // Work around a Safari quirk that fires a mousemove on <html> whenever the
        // window blurs, even if you're tabbing out of the page. \_()_/
        if (e.target.nodeName && e.target.nodeName.toLowerCase() === 'html') {
            return;
        }

        hadKeyboardEvent = false;
        removeInitialPointerMoveListeners();
    }

    // For some kinds of state, we are interested in changes at the global scope
    // only. For example, global pointer input, global key presses and global
    // visibility change should affect the state at every scope:
    document.addEventListener('keydown', onKeyDown, true);
    document.addEventListener('mousedown', onPointerDown, true);
    document.addEventListener('pointerdown', onPointerDown, true);
    document.addEventListener('touchstart', onPointerDown, true);
    document.addEventListener('visibilitychange', onVisibilityChange, true);

    addInitialPointerMoveListeners();

    // For focus and blur, we specifically care about state changes in the local
    // scope. This is because focus / blur events that originate from within a
    // shadow root are not re-dispatched from the host element if it was already
    // the active element in its own scope:
    scope.addEventListener('focus', onFocus, true);
    scope.addEventListener('blur', onBlur, true);

    // We detect that a node is a ShadowRoot by ensuring that it is a
    // DocumentFragment and also has a host property. This check covers native
    // implementation and polyfill implementation transparently. If we only cared
    // about the native implementation, we could just check if the scope was
    // an instance of a ShadowRoot.
    if (scope.nodeType === Node.DOCUMENT_FRAGMENT_NODE && scope.host) {
        // Since a ShadowRoot is a special kind of DocumentFragment, it does not
        // have a root element to add a class to. So, we add this attribute to the
        // host element instead:
        scope.host.setAttribute('data-js-focus-visible', '');
    } else if (scope.nodeType === Node.DOCUMENT_NODE) {
        document.documentElement.classList.add('js-focus-visible');
        document.documentElement.setAttribute('data-js-focus-visible', '');
    }
}

// It is important to wrap all references to global window and document in
// these checks to support server-side rendering use cases
// @see https://github.com/WICG/focus-visible/issues/199
if (typeof window !== 'undefined' && typeof document !== 'undefined') {
    // Make the polyfill helper globally available. This can be used as a signal
    // to interested libraries that wish to coordinate with the polyfill for e.g.,
    // applying the polyfill to a shadow root:
    window.applyFocusVisiblePolyfill = applyFocusVisiblePolyfill;

    // Notify interested libraries of the polyfill's presence, in case the
    // polyfill was loaded lazily:
    var event;

    try {
        event = new CustomEvent('focus-visible-polyfill-ready');
    } catch (error) {
        // IE11 does not support using CustomEvent as a constructor directly:
        event = document.createEvent('CustomEvent');
        event.initCustomEvent('focus-visible-polyfill-ready', false, false, {});
    }

    window.dispatchEvent(event);
}

if (typeof document !== 'undefined') {
    // Apply the polyfill to the global document, so that no JavaScript
    // coordination is required to use the polyfill in the top-level document:
    applyFocusVisiblePolyfill(document);
}

},{}],67:[function(require,module,exports){
/*** 

/**
 wait for event to be over (resize)
 @param {*} function
  https://stackoverflow.com/a/4541963/6211815 
-- Usage :  --
     $(window).resize(function () {
         waitForFinalEvent(function () {
             alert('Resize...');
             //...
         }, 500, "some unique string");
     }); 
 */
var waitForFinalEvent = (function () {
    var timers = {};
    return function (callback, ms, uniqueId) {
        if (!uniqueId) {
            uniqueId = "Don't call this twice without a uniqueId";
        }
        if (timers[uniqueId]) {
            clearTimeout(timers[uniqueId]);
        }
        timers[uniqueId] = setTimeout(callback, ms);
    };
})();

/**
 * emptyString
 * @param {String} str
 */
function emptyString(str) {
    switch (str) {
        case '':
        case 0:
        case '0':
        case null:
        case false:
        case typeof this === 'undefined':
        case typeof this === undefined:
            return true;
        default:
            return false;
    }
}

var utils = {
    waitForFinalEvent: waitForFinalEvent,
    emptyString: emptyString,
};

module.exports = utils;

},{}],68:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.Accordion = void 0;

var Accordion =
/** @class */
function () {
  function Accordion() {
    this.title = document.querySelectorAll('.o-accordion__title');

    if (this.title === null) {
      return;
    }
  }

  Accordion.prototype.init = function () {
    this.events();
  };

  Accordion.prototype.events = function () {
    var _that = this;

    this.title.forEach(function (item) {
      return item.addEventListener('click', clickHandler, false);
    });

    function clickHandler() {
      _that.Animate(this);
    }

    this.title.forEach(function (item) {
      return item.addEventListener('keydown', function (e) {
        var element = this;
        var evn = e;
        var isSpace = evn.which === 32 || evn.key === 'Space';
        var isEnter = evn.which === 13 || evn.key === 'Enter';
        if (isSpace || isEnter) setTimeout(function () {
          element.classList.add('is--focused');
          element.focus();
        }, 200);
      });
    });
  };

  Accordion.prototype.Animate = function (element) {
    element.classList.toggle('o-accordion__title--opened');
    element.nextElementSibling.classList.toggle('o-accordion__content--visible');
    element.querySelector('.o-accordion__label__open').classList.toggle('o-accordion__label__open--hidden');
    element.querySelector('.o-accordion__label__close').classList.toggle('o-accordion__label__close--visible');
  };

  return Accordion;
}();

exports.Accordion = Accordion;

},{}],69:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.AvoidLinks = void 0;

var _Utils_1 = require("../utils/_Utils");

var menu_1 = require("../components/header/menu");

var header_1 = require("../components/header/header");

var TemplateTypes;

(function (TemplateTypes) {
  TemplateTypes["Editorial"] = "editorialpage";
  TemplateTypes["SimplePage"] = "simpletitlepage";
  TemplateTypes["StoreLocator"] = "storelocatorpage";
  TemplateTypes["Search"] = "searchresultspage";
  TemplateTypes["Connexion"] = "loginpage";
})(TemplateTypes || (TemplateTypes = {}));
/*
/* Set behavior on accessibility links on top of the page
*/


var AvoidLinks =
/** @class */
function () {
  function AvoidLinks() {
    this.container = document.querySelector('.js-avoidlinks');
    this.menu = new menu_1.Menu(document.getElementById('header'));
    this.header = new header_1.Header();
    this.tplName = document.querySelector('head').getAttribute('data-template');
    this.main = document.querySelector('main');

    if (this.container !== null && this.container !== undefined) {
      this.avoidLinks = this.container.querySelectorAll('.a-avoidlink__item');
      this.events();
    }
  }

  AvoidLinks.prototype.events = function () {
    var _that = this;

    this.avoidLinks.forEach(function (element) {
      element.addEventListener('focusin', function () {
        _that.container.classList.add('js-avoidlinks--displayed');
      });
      element.addEventListener('click', function (e) {
        _that.setNVDAFocus(this, e);
      });
      element.addEventListener('keydown', function (e) {
        var isEnter = e.which === 13 || e.key === 'Enter';

        if (isEnter) {
          _that.setNVDAFocus(this, e);
        }
      });
    });
  };

  AvoidLinks.prototype.setNVDAFocus = function (element, event) {
    var _that = this;

    element.classList.remove('is--focused');
    this.container.classList.remove('js-avoidlinks--displayed');
    var htmltarget = event.target;
    var link = htmltarget.getAttribute('href');

    if (link === '#avoid-menu') {
      if (_Utils_1.Utils.ViewportUtils.isDesktop()) {
        var li_1 = this.menu.list.querySelector('.a-navigation__list__item');
        setTimeout(function () {
          li_1.querySelector('button').focus();
          li_1.querySelector('button').classList.add('is--focused');
        }, 400);
      } else {
        this.menu.hamburger.classList.add('is--focused');
        setTimeout(function () {
          _that.menu.hamburger.focus();
        }, 400);
      }
    } else if (link === '#avoid-contenu') {
      var firstLink_1 = this.checkTplType(_that.main);
      setTimeout(function () {
        firstLink_1.focus();
        firstLink_1.classList.add('is--focused');
      }, 200);
    }
  };

  AvoidLinks.prototype.getListLink = function () {
    var firstLink;
    var hasFeatureArticle = this.main.querySelector('.o-featurearticle') !== null;

    if (hasFeatureArticle === true) {
      firstLink = this.main.getElementsByTagName('a')[1];
    } else {
      firstLink = this.main.querySelector('.a-input__trigger');
    }

    return firstLink;
  };

  AvoidLinks.prototype.checkTplType = function (main) {
    switch (this.tplName) {
      case TemplateTypes.Editorial:
        return main.getElementsByTagName('a')[1];

      case TemplateTypes.SimplePage:
        return main.querySelector('.contactlist') !== null ? main.getElementsByTagName('a')[1] : this.getListLink();

      case TemplateTypes.StoreLocator:
        return main.querySelector('.m-searchbar__input');

      case TemplateTypes.Search:
        return main.querySelector('.m-searchbar__input');

      case TemplateTypes.Connexion:
        return main.querySelector('iframe');
    }
  };

  return AvoidLinks;
}();

exports.AvoidLinks = AvoidLinks;

},{"../components/header/header":80,"../components/header/menu":83,"../utils/_Utils":102}],70:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.ConsentModal = void 0;

var _Utils_1 = require("../utils/_Utils");

var ConsentModal =
/** @class */
function () {
  function ConsentModal() {
    this.popin = null;
    this.popinElement = document.getElementById('o-popin--consent');

    if (this.popinElement === null) {
      return;
    }

    this.apporoveBtn = this.popinElement.querySelector('.o-popin__consent__approval');
    this.coockieName = this.popinElement.getAttribute('data-cookie').replace(/\s+/g, '');
  }

  ConsentModal.prototype.init = function () {
    if (!_Utils_1.Cookie.getCookie(this.coockieName)) {
      this.showPopin();
    }

    this.events();
  };

  ConsentModal.prototype.showPopin = function () {
    if (this.popin === undefined || this.popin === null) {
      this.popin = new popinBox('#o-popin--consent', '', '', '', '', false);
    }

    this.popin.showPopin();
  };

  ConsentModal.prototype.events = function () {
    var _that = this;

    this.apporoveBtn.addEventListener('click', function () {
      _that.popin.hidePopin();

      _Utils_1.Cookie.setCookie(_that.coockieName, '1', 360 * 86400000);
    });
  };

  return ConsentModal;
}();

exports.ConsentModal = ConsentModal;

},{"../utils/_Utils":102}],71:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.Container = void 0;

var _Utils_1 = require("../utils/_Utils");

var Container =
/** @class */
function () {
  function Container() {
    this.content = document.querySelector('.o-container.o-container--isDecisiontree');
  }

  Container.prototype.show = function () {
    if (this.content !== null) {
      this.content.setAttribute('aria-hidden', 'false');
      this.content.classList.remove('u-hidden--all');
    }
  };

  Container.prototype.hide = function () {
    if (this.content !== null) {
      this.content.setAttribute('aria-hidden', 'true');
      this.content.classList.add('u-hidden--all');
    }
  };

  Container.prototype.toogle = function () {
    if (this.content !== null) {
      if (this.content.getAttribute('aria-hidden') === 'true') {
        this.content.setAttribute('aria-hidden', 'false');
      } else {
        this.content.setAttribute('aria-hidden', 'true');
      }

      this.content.classList.toggle('u-hidden--all');
    }
  };

  Container.prototype.event = function () {
    var that = this;

    _Utils_1.Utils.EventUtils.setDocEvent('container:displaydecisiontree:toogle', '.container', function (target) {
      that.toogle();
    });

    _Utils_1.Utils.EventUtils.setDocEvent('container:displaydecisiontree:show', '.container', function (target) {
      that.show();
    });

    _Utils_1.Utils.EventUtils.setDocEvent('container:displaydecisiontree:hide', '.container', function (target) {
      that.hide();
    });
  };

  Container.prototype.init = function () {
    this.event();
  };

  return Container;
}();

exports.Container = Container;

},{"../utils/_Utils":102}],72:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.CvsLogin = void 0;

var _Utils_1 = require("../utils/_Utils");

var CvsLogin =
/** @class */
function () {
  function CvsLogin() {
    this.cvsLayer = document.getElementById('cvslayer');
    this.deviceLayer = document.getElementById('devicelayer');
    this.storeBtn = document.getElementById('appredirect');
    this.cookie = _Utils_1.Cookie.getCookie('espace_connecte_choisi');
    this.focusables = '.js-logo-type, .o-metanavigation__trigger, .m-header__links__item, .m-header__menu__hamburger, #connectwebsite, #mobilewebsite, #appredirect';

    if (this.deviceLayer !== null) {
      this.stores = document.querySelector('.o-cvslogin').getAttribute('data-app-stores');
      this.choiceBtn = this.deviceLayer.querySelectorAll('.u-btn');
      this.deviceMobile = this.deviceLayer.getAttribute('device-mobile') === 'true';
      this.deviceTablet = this.deviceLayer.getAttribute('device-tablet') === 'true';
    }
  }

  CvsLogin.prototype.init = function () {
    this.events();
  };

  CvsLogin.prototype.events = function () {
    var _that = this;

    this.checkCvs();
    this.choiceBtn.forEach(function (item) {
      item.addEventListener('click', function () {
        var cookieName = this.getAttribute('id');
        var time = 15 * 86400000;

        _Utils_1.Cookie.setCookie('espace_connecte_choisi', cookieName, time);

        if (cookieName === 'connectwebsite') {
          _that.showCvs();
        }
      });
    });
    this.choiceBtn.forEach(function (item) {
      item.addEventListener('keydown', function (e) {
        var isTab = e.which === 9 || e.key === 'Tab';
        var keybordEvent = e;

        if (isTab || isTab && keybordEvent.shiftKey) {
          e.preventDefault();
          new _Utils_1.Utils.FocusUtils({
            item: document.querySelector('body'),
            event: e,
            focusableSelectors: _that.focusables
          }).setFocus();
        }
      });
    });
    var ua = detect.parse(navigator.userAgent);
    var isAndroid = ua.os.family.toLowerCase() === 'android';

    if (!isAndroid) {
      window.addEventListener('resize', function () {
        _Utils_1.Utils.LegacyUtils.waitForFinalEvent(function () {
          _that.checkCvs();
        }, 500);
      });
    }
  };

  CvsLogin.prototype.checkCvs = function () {
    var isDesktop = _Utils_1.Utils.ViewportUtils.isDesktop();

    var isNewUser = !isDesktop && this.cookie === undefined;
    var isDesktopUser = isDesktop || this.cookie === 'connectwebsite';
    var isAppredirect = !isDesktop && this.cookie !== undefined && this.cookie !== 'connectwebsite';

    if (isNewUser) {
      this.showDevicelayer();
      this.checkDevices(false);
    } else if (isDesktopUser) {
      this.showCvs();
    } else if (isAppredirect) {
      this.showDevicelayer();
      this.checkDevices(true);
    }
  };

  CvsLogin.prototype.showDevicelayer = function () {
    if (this.deviceMobile && this.deviceTablet) {
      this.deviceLayer.classList.add('u-flex');
    } else if (this.deviceMobile && !this.deviceTablet) {
      this.deviceLayer.classList.add('u-flex--xs');
    } else if (this.deviceTablet && !this.deviceMobile) {
      this.deviceLayer.classList.add('u-flex--sm');
    } else {
      this.deviceLayer.classList.remove('u-hidden--all');
      this.cvsLayer.classList.add('u-hidden--all');
    }

    document.querySelector('body').setAttribute('aria-hidden', 'true');
  };

  CvsLogin.prototype.showCvs = function () {
    this.cvsLayer.classList.remove('u-hidden--all');
    this.deviceLayer.classList.add('u-hidden--all');
    this.deviceLayer.setAttribute('tabindex', '-1');
    this.deviceLayer.setAttribute('aria-hidden', 'true');
    setTimeout(function () {
      document.querySelector('body').focus();
    }, 300);
    document.querySelector('body').removeAttribute('aria-hidden');
    document.querySelector('body').setAttribute('tabindex', '-1');

    if (this.deviceMobile && this.deviceTablet) {
      this.cvsLayer.classList.remove('hasdevicelayer');
    } else if (this.deviceMobile && !this.deviceTablet) {
      this.cvsLayer.classList.remove('hasdevicelayer--xs');
    } else if (this.deviceTablet && !this.deviceMobile) {
      this.cvsLayer.classList.remove('hasdevicelayer--sm');
    }
  };
  /**
   * Check if device is available & set associated url store
   */


  CvsLogin.prototype.checkDevices = function (redirect) {
    var _this = this;

    if (_Utils_1.Utils.ViewportUtils.isMobile) {
      var storeParse = JSON.parse(this.stores);
      var ua = detect.parse(navigator.userAgent);
      var device_1 = {
        name: ua.os.family.toLowerCase(),
        version: parseInt(ua.browser.major),
        type: ua.device.type.toLowerCase()
      };

      var _isHuawei_1 = this.isHuawei();

      storeParse.appStores.forEach(function (element) {
        var relatedDevice = element.appStoreLinkModel.relatedDevice;
        var version = element.appStoreLinkModel.osMinVersion;
        var type = element.device.label.toLowerCase();

        if (relatedDevice.indexOf(device_1.name) > -1 && parseInt(version) < device_1.version && type.indexOf(device_1.type) > -1 || _isHuawei_1 && relatedDevice === 'huawei') {
          _this.storeBtn.style.display = 'block';

          _this.storeBtn.setAttribute('href', element.appStoreLinkModel.linkPath);

          if (redirect) {
            window.open(_this.storeBtn.getAttribute('href'), '_self');
          }
        }
      });
    }
  };

  CvsLogin.prototype.isHuawei = function () {
    var _isHuawei = false;
    var patternList = [/\b((?:agr|ags[23]|bah2?|sht?)-a?[lw]\d{2})/i, /d\/huawei([\w\s-]+)[;\)]/i, /\b(nexus\s6p|vog-[at]?l\d\d|ane-[at]?l[x\d]\d|eml-a?l\d\da?|lya-[at]?l\d[\dc]|clt-a?l\d\di?|ele-l\d\d)/i, /\b(\w{2,4}-[atu][ln][01259][019])[;\)\s]/i];
    patternList.forEach(function (pattern) {
      var test = pattern.test(navigator.userAgent);

      if (test) {
        _isHuawei = true;
      }
    });
    return _isHuawei;
  };

  return CvsLogin;
}();

exports.CvsLogin = CvsLogin;

},{"../utils/_Utils":102}],73:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.DecisionTree = void 0;

var questions_1 = require("./questions");

var result_1 = require("./result");

var step_1 = require("./step");

var DecisionTree =
/** @class */
function () {
  function DecisionTree() {
    this.decisiontree = document.querySelector('[data-tree]');
  }

  DecisionTree.prototype.init = function () {
    if (this.decisiontree !== null && this.decisiontree !== undefined) {
      this.isAuthor = this.decisiontree.getAttribute('data-author') !== null;
      this.questions = new questions_1.DecisionTreeQuestions(this.decisiontree, this);
      this.questions.init();
      this.results = new result_1.DecisionTreeResults(this);
      this.results.init();
      this.stepper = new step_1.Step(this);
      this.stepper.init();
    }
  };

  return DecisionTree;
}();

exports.DecisionTree = DecisionTree;

},{"./questions":74,"./result":75,"./step":76}],74:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.DecisionTreeQuestions = void 0;

var _Utils_1 = require("../../utils/_Utils");

var tooltip_1 = require("../tooltip");

var DecisionTreeQuestions =
/** @class */
function () {
  function DecisionTreeQuestions(decisiontree, _parent) {
    this.current = {
      groupe: 0,
      question: null
    };
    this._parent = _parent;
    this.jsonString = document.querySelector('.o-decisiontree').getAttribute('data-tree');
    this.store = JSON.parse(this.jsonString);
    this.decisiontree = decisiontree;
    this.content = document.querySelector('.o-decisiontree__content');
    this.questions = document.querySelectorAll('.o-decisiontree__questionwrapper');
    this.validateState = false;
    this.stepper = false;
    this.step = document.querySelector('.step');
    this.path = document.querySelector('.o-decisiontree').getAttribute('data-path');
    this.stepperHeader = document.querySelector('.bs-stepper-header');
    this.error = false;
    this.defaultErrorMessage = 'Veuillez rpondre  cette question pour continuer';
    this.isAnimating = false;
  }

  DecisionTreeQuestions.prototype.init = function () {
    if (this.store.groups.length > 0 && this.store.groups[0].questions.length > 0) {
      var stepperState = this.store.groups.length > 1 ? true : false;

      if (stepperState === true) {
        this.buildStepperHeader();
        this.setStepperContent();
        this.stepper = new Stepper(document.querySelector('.bs-stepper'), {
          linear: true,
          animation: true
        });

        if (document.body.clientWidth < 768) {
          var labelSelector = this.stepper._steps[0].querySelector('.bs-stepper-label');

          var labelSelectorMobile = this.stepper._element.querySelector('.bs-stepper-label--mobile');

          var label = labelSelector.textContent;

          if (label !== undefined) {
            labelSelectorMobile.textContent = label;
          }
        } else {
          var labels = this.stepperHeader.querySelectorAll('.bs-stepper-label');
          var isempty_1 = true;
          labels.forEach(function (element) {
            if (element.textContent.trim() !== '') {
              isempty_1 = false;
            }
          });
          isempty_1 === true ? this.stepperHeader.style.paddingBottom = '20px' : '';
        }
      } else {
        this.stepperHeader.style.display = 'none';
      }

      this.events();
      this.buildGroup();
      this.initTooltip();
    }
  };

  DecisionTreeQuestions.prototype.initSelector = function () {
    this.decisiontree = document.querySelector('.o-decisiontree');
    this.content = document.querySelector('.o-decisiontree__content');
    this.questions = document.querySelectorAll('.o-decisiontree__questionwrapper');
    this.stepperHeader = document.querySelector('.bs-stepper-header');
    this.validateState = false;
    this.error = false;
    this.path = document.querySelector('.o-decisiontree').getAttribute('data-path');
  };

  DecisionTreeQuestions.prototype.buildGroup = function () {
    this.buildContent(); //* set selector after Question added to DOM

    this.questions = document.querySelectorAll('.o-decisiontree__questionwrapper');
  };

  DecisionTreeQuestions.prototype.buildStepperHeader = function () {
    var that = this,
        parse = this.store,
        groups = parse.groups;

    for (var i = 0; i < groups.length; i++) {
      var circleLabel = i + 1;

      if (i === 0) {
        that.stepperHeader.insertAdjacentHTML('beforeend', "<div class=\"step\" data-target=\"#decisiontree-step-" + i + "\" data-step-number=\"" + i + "\">\n                        <button type=\"button\" class=\"btn step-trigger\">\n                            <span class=\"bs-stepper-circle\">\n                            <span class=\"bs-stepper-circle--label\">" + circleLabel + "</span>\n                            <svg viewBox=\"0 0 24 24\" class=\"a-icon--s u-svg-color--white\" aria-hidden=\"true\" focusable=\"false\">\n                            <use xlink:href=\"/etc.clientlibs/labanquepostale/commons/clientlibs/base/resources/svg-icons.svg#ic-interface-inline-check\"></use></svg>\n                            </span>\n                            <span class=\"bs-stepper-label\">" + (groups[i].label ? groups[i].label : '') + "</span>\n                        </button>\n                    </div>\n                    <div class=\"line--wrapper\">\n                        <div class=\"line--default line--disabled\"></div>\n                        <div class=\"line--default line--active\"></div>\n                    </div>");
      } else if (i === groups.length - 1) {
        that.stepperHeader.insertAdjacentHTML('beforeend', "<div class=\"step\" data-target=\"#decisiontree-step-" + i + "\" data-step-number=\"" + i + "\">\n                        <button type=\"button\" class=\"btn step-trigger\" disabled=\"disabled\">\n                            <span class=\"bs-stepper-circle\">\n                                <span class=\"bs-stepper-circle--label\">" + circleLabel + "</span>\n                                <svg viewBox=\"0 0 24 24\" class=\"a-icon--s u-svg-color--white\" aria-hidden=\"true\" focusable=\"false\"><use xlink:href=\"/etc.clientlibs/labanquepostale/commons/clientlibs/base/resources/svg-icons.svg#ic-interface-inline-check\"></use></svg>\n                            </span>\n                            <span class=\"bs-stepper-label\">" + (groups[i].label ? groups[i].label : '') + "</span>\n                        </button>\n                    </div>");
      } else {
        that.stepperHeader.insertAdjacentHTML('beforeend', "<div class=\"step\" data-target=\"#decisiontree-step-" + i + "\" data-step-number=\"" + i + "\">\n                        <button type=\"button\" class=\"btn step-trigger\" disabled=\"disabled\">\n                            <span class=\"bs-stepper-circle\">\n                            <span class=\"bs-stepper-circle--label\">" + circleLabel + "</span>\n                            <svg viewBox=\"0 0 24 24\" class=\"a-icon--s u-svg-color--white\" aria-hidden=\"true\" focusable=\"false\"><use xlink:href=\"/etc.clientlibs/labanquepostale/commons/clientlibs/base/resources/svg-icons.svg#ic-interface-inline-check\"></use></svg>\n                            </span>\n                            <span class=\"bs-stepper-label\">" + (groups[i].label ? groups[i].label : '') + "</span>\n                        </button>\n                    </div>\n                    <div class=\"line--wrapper\">\n                        <div class=\"line--default line--disabled\"></div>\n                        <div class=\"line--default\"></div>\n                    </div>");
      }
    }
  };

  DecisionTreeQuestions.prototype.setStepperContent = function () {
    var _this = this;

    var that = this;
    new _Utils_1.Utils.AttributesUtils({
      el: that.decisiontree,
      attrs: {
        'class': 'o-decisiontree bs-stepper',
        'id': 'stepper'
      }
    }).setAttributes();
    var tabs = new _Utils_1.Utils.ChildrenUtils({
      wrapper: that.decisiontree,
      className: 'row'
    }).toChildrenList();
    var stepper_content = '<div class="bs-stepper-content"></div>';
    this.decisiontree.insertAdjacentHTML('beforeend', stepper_content);
    tabs.forEach(function (element, index) {
      var stringIndex = index.toString();

      _this.decisiontree.querySelector('.bs-stepper-content').appendChild(element);

      new _Utils_1.Utils.AttributesUtils({
        el: element,
        attrs: {
          'id': 'decisiontree-step-' + stringIndex,
          'class': 'bs-stepper-pane',
          'role': 'tabpanel'
        }
      }).setAttributes();
    });
  };

  DecisionTreeQuestions.prototype.buildContent = function () {
    var that = this,
        parse = this.store,
        group = parse.groups[this.current.groupe],
        questions = group.questions;
    var currGroupe = document.querySelectorAll('.' + that.content.className)[this.current.groupe];
    currGroupe.setAttribute('data-group-index', this.current.groupe.toString());

    for (var x = questions.length - 1; x >= 0; x--) {
      var message = this.defaultErrorMessage;

      if (questions[x].errorMessage !== undefined) {
        message = questions[x].errorMessage;
      }

      if (x === 0) {
        currGroupe.insertAdjacentHTML('afterbegin', "<div class=\"o-decisiontree__questionwrapper\" data-content-index=\"" + x + "\"><fieldset aria-required=\"true\">\n                        <legend class=\"o-decisiontree__question a-text a-text--description u-margin-2xs-bottom\">\n                        <span class=\"u-spacing-3xs-right\">" + questions[x].label + "</span>\n                        </legend>\n                        <p class=\"a-text a-text--small\">" + (questions[x].description ? questions[x].description : '') + "</p>\n                        <p class=\"o-decisiontree__question__error text-small error u-spacing-s-top u-hidden--all\" name=\"decisiontree\">\n                        <svg viewBox=\"0 0 24 24\" class=\"a-icon--s u-svg-color--error u-spacing-2xs-right\"  aria-hidden=\"true\" focusable=\"false\"><use xlink:href=\"/etc.clientlibs/labanquepostale/commons/clientlibs/base/resources/svg-icons.svg#ic-notification-alerte\"></use></svg>\n                        " + message + "\n                        </p></fieldset>\n                        </div>");
      } else {
        currGroupe.insertAdjacentHTML('afterbegin', "<div class=\"o-decisiontree__questionwrapper\" data-content-index=\"" + x + "\"><fieldset aria-required=\"true\">\n                    <legend class=\"o-decisiontree__question a-text a-text--description u-margin-3xs-bottom u-spacing-3xs-right\">\n                    <span class=\"u-spacing-3xs-right\">" + questions[x].label + "</span>\n                    </legend>\n                    <p class=\"a-text a-text--small\">" + (questions[x].description ? questions[x].description : '') + "</p>\n                    <p class=\"o-decisiontree__question__error text-small error u-spacing-s-top u-hidden--all\" name=\"decisiontree\">\n                    <svg viewBox=\"0 0 24 24\" class=\"a-icon--s u-svg-color--error u-spacing-2xs-right\"  aria-hidden=\"true\" focusable=\"false\"><use xlink:href=\"/etc.clientlibs/labanquepostale/commons/clientlibs/base/resources/svg-icons.svg#ic-notification-alerte\"></use></svg>\n                    " + message + "\n                    </p></fieldset></div>");
      }

      var first = currGroupe.firstChild;
      var p = first.querySelector('legend');
      var question = currGroupe;
      questions[x].tooltip !== undefined ? that.buildTooltip(p, questions[x].tooltip, questions[x].label, this.current.groupe) : false;
      questions[x].answers.length > 0 ? that.buildAnswers(question, x, questions, questions[x].validationLabel) : false;
    }

    this.store.groups[this.current.groupe]['loaded'] = true;
  };
  /**
   * @param {HTMLElement} el List wrapper
   * @param {integer} i Question index
   * @param {Array} list Question List in JsonObj
   * @param {String} validationLabel
   */


  DecisionTreeQuestions.prototype.buildAnswers = function (el, i, list, validationLabel) {
    var radio = list[i].type === 'radio';
    var answers = list[i].answers;
    el.querySelector('.o-decisiontree__question__error').insertAdjacentHTML('beforebegin', '<ul class="m-list m-list--vertical"></ul>');
    var ul = el.querySelector('ul');
    ul.setAttribute('data-validate', '');

    for (var y = 0; y < answers.length; y++) {
      if (radio) {
        var idLabel = answers[y].label.replace(/ /g, '');
        ul.insertAdjacentHTML('beforeend', "<li class=\"a-radio__item a-radio__item--m a-radio__item--bordered u-margin-s-top\" data-level=\"" + i + "\" data-sublevel=\"" + y + "\" data-type=\"" + list[i].type + "\"><input type=\"radio\" name=\"decisiontree\" value=\"" + answers[y].label + "\" id=\"" + idLabel + "-" + y + "\"></input><label for=\"" + idLabel + "-" + y + "\">" + answers[y].label + "</label>\n                    <p class=\"a-text--tiny " + (answers[y].description ? 'u-margin-2xs-top' : '') + "\">" + (answers[y].description ? answers[y].description : '') + "</p></li>");
      } else {
        ul.insertAdjacentHTML('beforeend', "<li class=\"a-checkbox a-checkbox--bordered u-margin-s-top\" data-level=\"" + i + "\" data-sublevel=\"" + y + "\"><input type=\"checkbox\" name=\"decisiontree\" class=\"a-checkbox__input\"/><span class=\"a-checkbox__checkmark\"></span><span class=\"a-checkbox__label a-checkbox__label--m\">" + answers[y].label + "</span>\n                    <p class=\"a-text--tiny " + (answers[y].description ? 'u-margin-2xs-top' : '') + "\">" + (answers[y].description ? answers[y].description : '') + "</p></li>");
      }
    }
  };
  /**
   * @param {HTMLElement} el paragraph question
   * @param {String} str Tooltip message from Json description Key
   * @param {integer} i question index
   */


  DecisionTreeQuestions.prototype.buildTooltip = function (el, str, question, i) {
    el.insertAdjacentHTML('beforeend', "<button data-tippy-trigger-click data-tippy-content=\"" + str + "\" class=\"closed\">\n                <svg viewBox=\"0 0 24 24\" class=\"a-icon--s\" aria-hidden=\"true\" focusable=\"false\">\n                <use xlink:href=\"/etc.clientlibs/labanquepostale/commons/clientlibs/base/resources/svg-icons.svg#ic-notification-info\"></use></svg>\n                <span class=\"sr-only\"><span>Afficher</span> l\u2019aide sur " + question + "</span>\n                </button>\n                <span class=\"o-overlay\">\n                <input type=\"checkbox\" id=\"o-overlay-button-" + i + "\" class=\"o-overlay__input\" aria-hidden=\"true\" focusable=\"false\"/>\n                <div class=\"o-overlay__content\"><div class=\"m-overlay__header visible-xs u-spacing-2xl-bottom\">\n                <div class=\"m-overlay__header__title m-title u-align-center\"><p>" + str + "</p></div>\n                <label class=\"m-overlay__header__icons\" for=\"o-overlay-button-" + i + "\" tabindex=\"0\" aria-label=\"fermer\">\n                <svg viewBox=\"0 0 24 24\" class=\"a-icon--s\" aria-hidden=\"true\" focusable=\"false\">\n                <use xlink:href=\"/etc.clientlibs/labanquepostale/commons/clientlibs/base/resources/svg-icons.svg#ic-interface-close\"></use></svg></label></div></div>\n                </span>");
  };

  DecisionTreeQuestions.prototype.initTooltip = function () {
    if (!_Utils_1.Utils.ViewportUtils.isMobile()) {
      console.log('tooltip update');
      this.tooltips = new tooltip_1.Tooltip();
      this.tooltips.init();
    }
  };
  /**
   * @param {String} level Level 1  Json (groups)
   * @param {String} sublevel Level 2  Json (answers)
   * @param {String} type Input type
   */


  DecisionTreeQuestions.prototype.recordAnswers = function (level, sublevel, type) {
    var answsers = this.store.groups[this.current.groupe].questions[level].answers;

    for (var i = 0; i < answsers.length; i++) {
      if (type === 'radio' && answsers[i].checked === true && answsers[i] !== answsers[sublevel]) {
        delete answsers[i].checked;
      } else if (type !== 'radio' && answsers[i] === answsers[sublevel] && answsers[sublevel].checked === true) {
        delete answsers[i].checked;
      } else if (answsers[i] === answsers[sublevel] && !answsers[sublevel].checked) {
        this.store.groups[this.current.groupe].questions[level].answers[sublevel]['checked'] = true;
      }
    }

    this.jsonString = this.store;
  };
  /**
   * @param {String} str button message
   * @param {String} level Level 1  Json (groups)
   */


  DecisionTreeQuestions.prototype.recordValidationMessage = function (str) {
    var groups = this.store.groups;

    for (var i = 0; i < groups.length; i++) {
      if (i === this.current.groupe) {
        this.store.groups[this.current.groupe]['validationMessage'] = str;
      }
    }

    this.store.jsonString = this.store;
  };
  /**
   * @param {String} level Level 1 Question Json
   * @return
   */


  DecisionTreeQuestions.prototype.isAnwsered = function (level) {
    var listAnwsered = this.store.groups[this.current.groupe].questions[level].answers.filter(function (anwser) {
      if (anwser.checked === true) {
        return true;
      }
    });
    return listAnwsered.length > 0;
  };

  DecisionTreeQuestions.prototype.events = function () {
    var that = this;

    _Utils_1.Utils.EventUtils.setDocEvent('focusin', '.a-radio__item > input', function (target, event) {
      target.parentElement.classList.add('is--focused');
    });

    _Utils_1.Utils.EventUtils.setDocEvent('focusout', '.a-radio__item > input', function (target, event) {
      target.parentElement.classList.remove('is--focused');
    });

    _Utils_1.Utils.EventUtils.setDocEvent('click', '.a-radio__item', function (target, event) {
      event.preventDefault();
      var type = target.getAttribute('data-type');
      var level = target.getAttribute('data-level');
      var sublevel = target.getAttribute('data-sublevel');
      var parent = target.closest('.o-decisiontree__questionwrapper');
      parent.querySelector('ul').setAttribute('data-validate', 'true');
      parent.querySelectorAll('.a-radio__item').forEach(function (element) {
        element.classList.remove('a-radio__item--is-active', 'a-radio__item--bordered--is-active');
      });
      target.classList.toggle('a-radio__item--bordered--is-active');
      target.classList.toggle('a-radio__item--is-active');
      that.recordAnswers(level, sublevel, type);
    });

    _Utils_1.Utils.EventUtils.setDocEvent('click', '.o-decisiontree__questionwrapper .a-checkbox', function (target, event) {
      event.preventDefault();
      var check = new _Utils_1.Utils.ChildrenUtils({
        wrapper: target,
        className: 'a-checkbox__input'
      }).toChildrenList();
      var parent = target.closest('.o-decisiontree__questionwrapper');
      var nextgroup = target.closest('.o-decisiontree__questionwrapper').nextElementSibling;
      var errorEl = parent.querySelectorAll('p.error');
      var level = target.getAttribute('data-level');
      var sublevel = target.getAttribute('data-sublevel');
      var checked = [];
      that.recordAnswers(level, sublevel, '');
      target.classList.toggle('a-checkbox--bordered--is-active');
      target.classList.toggle('a-checkbox__label--is-active');
      check.forEach(function (element) {
        var target = element;
        var state = !target.checked;
        target.checked = state;
      });
      parent.querySelectorAll('.a-checkbox__input').forEach(function (element, i) {
        var target = element;

        if (target.checked === true) {
          checked.push(i);
        }
      });

      if (errorEl.length > 0) {
        errorEl.forEach(function (element) {
          element.classList.add('u-hidden--all');
        });
        parent.querySelectorAll('.a-checkbox').forEach(function (element) {
          element.classList.remove('error');
        });
      }

      if (checked.length > 0 && nextgroup === undefined) {
        parent.querySelector('ul').setAttribute('data-validate', 'true');
      } else if (checked.length === 0 && nextgroup !== undefined) {
        parent.querySelector('ul').setAttribute('data-validate', 'false');
      } else if (checked.length > 0) {
        parent.querySelector('ul').setAttribute('data-validate', 'true');
      } else if (checked.length === 0) {
        parent.querySelector('ul').setAttribute('data-validate', 'false');
      }
    });

    _Utils_1.Utils.EventUtils.setDocEvent('click', '.o-decisiontree__validator input', function (target, event) {
      event.preventDefault(); //tracking - JQuery dependency

      var nom_formulaire = $(this).TaggingStringCheck($('body').attr('data-title'));
      var etape_formulaire;
      var label = that.store.groups[that.current.groupe].label;

      if (label !== undefined) {
        etape_formulaire = $(this).TaggingStringCheck(label);
      }

      try {
        $(this).Tagging({
          trigger: this,
          event: 'pageview',
          args: {
            xiti_xtsite: tc_vars.xiti_xtsite,
            xiti_xtn2: tc_vars.xiti_xtn2,
            'pageName': 'outil_aide_decision::' + nom_formulaire + '::' + etape_formulaire
          }
        });
      } catch (err) {
        console.error(err);
      }

      if (that.store.groups.length === that.current.groupe + 1) {
        try {
          $(this).Tagging({
            trigger: this,
            event: 'pageview',
            args: {
              xiti_xtsite: tc_vars.xiti_xtsite,
              xiti_xtn2: tc_vars.xiti_xtn2,
              'pageName': 'outil_aide_decision::' + nom_formulaire + '::' + 'resultats'
            }
          });
        } catch (err) {
          console.error(err);
        }
      }

      that.recordValidationMessage(target.getAttribute('value'));
      var unchecked = [];
      var currGroupe = document.querySelectorAll('.' + that.content.className)[that.current.groupe];
      var validate = currGroupe.querySelectorAll('[data-validate]');
      that.checkError(validate, unchecked);

      if (unchecked.length === 0 && that.store.groups.length - 1 === that.current.groupe) {
        that.validate();
      } else if (unchecked.length === 0 && that.current.groupe < that.store.groups.length - 1) {
        var forward = true;
        var rect = document.querySelector('.decisiontree').getBoundingClientRect();
        var offset = {
          top: rect.top + window.scrollY
        };
        that.stepper.next();
        that.setStep(forward, that.current.groupe + 1, true, that.error);

        if (!that.store.groups[that.current.groupe].loaded) {
          that.buildGroup();
          that.populateQuestion(that.store);
        }

        scroll({
          top: offset.top,
          behavior: 'smooth'
        });
      }
    });

    _Utils_1.Utils.EventUtils.setDocEvent('click', '.step-trigger', function (target, event) {
      event.preventDefault();
      var stepNb = parseInt(target.parentElement.getAttribute('data-step-number')),
          forward = stepNb > that.current.groupe ? true : false;
      that.stepper.to(stepNb + 1);
      that.setStep(forward, stepNb, false, that.error);

      if (!that.store.groups[stepNb].loaded && that.error === false) {
        that.buildGroup();
        that.populateQuestion(that.jsonString);
      }
    });

    _Utils_1.Utils.EventUtils.setDocEvent('keydown', '.m-overlay__header__icons', function (target, event) {
      event.preventDefault();

      if (_Utils_1.Utils.ViewportUtils.isMobile()) {
        target.click();
        target.setAttribute('aria-hidden', 'true');
        var parent_1 = target.closest('legend');
        var tooltipBtn = parent_1.querySelector('button');
        var overlay = parent_1.querySelector('.o-overlay');
        overlay.style.display = 'none';
        tooltipBtn.focus();
        tooltipBtn.classList.add('is--focused');
      }
    });
  };
  /**
   * @param {Boolean} forward Step before / after current step
   * @param {integer} targetStep Index of steps requested
   * @param {Boolean} next use next() Stepper method
   */


  DecisionTreeQuestions.prototype.setStep = function (forward, targetStep, next, error) {
    if (error === false && targetStep !== this.current.groupe) {
      if (forward === false) {
        var next_1 = new _Utils_1.Utils.SiblingsUtils({
          el: this.stepper._steps[this.current.groupe],
          className: '.line--wrapper'
        }).getNext();

        if (next_1 !== null) {
          var line = next_1.lastElementChild;
          line.classList.remove('line--active');
        }

        this.stepper._steps.forEach(function (element, index) {
          if (index !== targetStep) {
            element.querySelector('.step-trigger').removeAttribute('disabled');
          }
        });

        if (this.stepper._steps[this.current.groupe].className !== 'completed') {
          var prev = new _Utils_1.Utils.SiblingsUtils({
            el: this.stepper._steps[this.current.groupe],
            className: '.line--wrapper'
          }).getNext();

          if (prev !== null) {
            var lines = Array.from(prev.children);
            lines.forEach(function (element) {
              var target = element;
              target.classList.remove('line--completed');
            });
          }
        }

        this.current.groupe = targetStep;
        this.stepper._currentIndex = targetStep;
      } else {
        this.stepper._steps[this.current.groupe].classList.add('completed');

        var next_2 = new _Utils_1.Utils.SiblingsUtils({
          el: this.stepper._steps[this.current.groupe],
          className: '.line--wrapper'
        }).getNext();

        if (next_2 !== null) {
          var lines = Array.from(next_2.children);
          var last = next_2.lastElementChild;
          last.classList.add('line--active');
          lines.forEach(function (element) {
            var target = element;
            target.classList.add('line--completed');
          });
        }

        var stepperComplete = this.stepper._element.querySelectorAll('.step.completed');

        Array.from(stepperComplete).forEach(function (element) {
          var el = element;
          el.querySelector('.step-trigger').removeAttribute('disabled');
        });
        this.current.groupe = targetStep;
        this.stepper._currentIndex = targetStep;
      }

      if (_Utils_1.Utils.ViewportUtils.isMobile()) {
        var label = this.stepper._steps[targetStep].querySelector('.bs-stepper-label').textContent;

        this.stepper._element.querySelector('.bs-stepper-label--mobile').textContent = label;
      }
    }
  };
  /**
   * @param {HTMLElement} el
   * @param {list} list
   */


  DecisionTreeQuestions.prototype.checkError = function (el, list) {
    var that = this;
    var errorfound = false;
    el.forEach(function (el, i) {
      var element = el;
      var parent = element.closest('.o-decisiontree__questionwrapper');

      if (element.getAttribute('data-validate') !== 'true') {
        parent.querySelector('.error').classList.remove('u-hidden--all');

        if (errorfound === false) {
          var parentHtml = parent.getAttribute('data-content-index');
          that.scrollToQuestion(parentHtml);
          errorfound = true;
        }

        list.push(i);
      } else {
        parent.querySelector('.error').classList.add('u-hidden--all');
      }
    });
    return list;
  };
  /**
   * @param {HTMLElement} el nextgroup question
   * @param {Boolean} summary
   */


  DecisionTreeQuestions.prototype.scrollToQuestion = function (attr) {
    var that = this;
    that.isAnimating = true;
    var rect = document.querySelector('[data-content-index="' + attr + '"]').getBoundingClientRect();
    var offset = {
      top: rect.top + window.scrollY
    };
    scroll({
      top: offset.top - 80,
      behavior: 'smooth'
    });
  };
  /**
   * @param {Json} Json
   */


  DecisionTreeQuestions.prototype.populateQuestion = function (json) {
    var groups = json.groups;
    var that = this;
    var listQuestions = groups[this.current.groupe].questions,
        wrapper = document.querySelector('.o-decisiontree__questionwrapper'),
        questionIndex = 0,
        answerIndex = 0,
        questionType = '';
    var unchecked = [];

    for (var j = 0; j < listQuestions.length; j++) {
      var answers = listQuestions[j].answers;
      questionType = listQuestions[j].type;

      for (var k = 0; k < answers.length; k++) {
        questionIndex = j;

        if (answers[k].checked === true) {
          answerIndex = k;
          unchecked.push(k);
          var currGroupe = document.querySelectorAll('.' + that.content.className)[this.current.groupe];
          var el = currGroupe.querySelector('[data-level="' + questionIndex + '"][data-sublevel="' + answerIndex + '"]');
          el.parentElement.setAttribute('data-validate', 'true');

          if (questionType === 'radio') {
            el.classList.toggle('a-radio__item--bordered--is-active');
            el.classList.toggle('a-radio__item--is-active');
          } else {
            el.classList.toggle('a-checkbox--bordered--is-active');
            el.classList.toggle('a-checkbox__label--is-active');
            var children = new _Utils_1.Utils.ChildrenUtils({
              wrapper: el,
              className: 'a-checkbox__input'
            }).toChildrenList();
            children.forEach(function (element) {
              var target = element;
              target.checked = true;
            });
          }

          el.closest('.' + wrapper.className).classList.remove('is--disabled');
        }
      }
    }
  };

  DecisionTreeQuestions.prototype.validate = function () {
    var groups = this.store.groups;

    for (var y = 0; y < groups.length; y++) {
      delete groups[y].loaded;
    }

    this._parent.results.getData();
  };

  return DecisionTreeQuestions;
}();

exports.DecisionTreeQuestions = DecisionTreeQuestions;

},{"../../utils/_Utils":102,"../tooltip":99}],75:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.DecisionTreeResults = void 0;

var _Utils_1 = require("../../utils/_Utils");

var footnotes_1 = require("../footnotes");

var container_1 = require("../container");

var DecisionTreeResults =
/** @class */
function () {
  function DecisionTreeResults(_parent) {
    this._parent = _parent;
    this.url = this._parent.isAuthor ? this._parent.decisiontree.getAttribute('data-tree-target') + '.' + this._parent.decisiontree.getAttribute('data-producttype') + '.html?wcmmode=disabled' : this._parent.decisiontree.getAttribute('data-tree-target') + '.' + this._parent.decisiontree.getAttribute('data-producttype') + '.html';
  }

  DecisionTreeResults.prototype.init = function () {
    this.event();
  };

  DecisionTreeResults.prototype.setTitle = function () {
    var title = this._parent.decisiontree.querySelector('h2');

    if (title) {
      var txt = title.textContent;
      var nbresults = title.getAttribute('data-size');
      var marker_1 = /[##]{2}/g;

      if (txt.match(marker_1)) {
        var replaceHtml = function replaceHtml() {
          var labeltxt = title.innerHTML;

          if (labeltxt.match(marker_1)) {
            var replace = labeltxt.replace(marker_1, '<a><sup></sup></a>');
            title.innerHTML = replace;
          }
        };
      }
    }
  };
  /**
   * init result after ajax request
   */


  DecisionTreeResults.prototype.initCallBack = function (_content) {
    this.content = _content;
    this.show();
    this.setTitle();
  };

  DecisionTreeResults.prototype.getPostData = function () {
    var groups = this._parent.questions.store.groups,
        listPostData = [];

    var _loop_1 = function _loop_1(i) {
      var listQuestions = groups[i].questions;
      var currentGroup = document.querySelector('.o-decisiontree__content')[i];

      var pimcategory = this_1._parent.decisiontree.getAttribute('data-pimcategory');

      listPostData.push({
        pimcategory: pimcategory !== null && pimcategory !== undefined ? pimcategory : '',
        questions: []
      });

      var _loop_2 = function _loop_2(j) {
        listQuestions[j].answers.map(function (answer) {
          if (answer.checked === true) {
            if (answer.type === 'range') {
              listPostData[i].questions.push({
                'key': listQuestions[j].pimProperty !== null && listQuestions[j].pimProperty !== undefined ? listQuestions[j].pimProperty : '',
                'keyMin': listQuestions[j].pimPropertyMin !== null && listQuestions[j].pimPropertyMin !== undefined ? listQuestions[j].pimPropertyMin : '',
                'keyMax': listQuestions[j].pimPropertyMax !== null && listQuestions[j].pimPropertyMax !== undefined ? listQuestions[j].pimPropertyMax : '',
                'questionType': listQuestions[j].type,
                'pimMatchRequired': listQuestions[j].pimMatchRequired,
                'pimcategory': listQuestions[j].pimCategory,
                'answers': [{
                  'answerType': answer.type,
                  'valueMin': answer.valueMin,
                  'valueMax': answer.valueMax
                }]
              });
            } else if (answer.type === 'list') {
              listPostData[i].questions.push({
                'key': listQuestions[j].pimProperty !== null && listQuestions[j].pimProperty !== undefined ? listQuestions[j].pimProperty : '',
                'keyMin': listQuestions[j].pimPropertyMin !== null && listQuestions[j].pimPropertyMin !== undefined ? listQuestions[j].pimPropertyMin : '',
                'keyMax': listQuestions[j].pimPropertyMax !== null && listQuestions[j].pimPropertyMax !== undefined ? listQuestions[j].pimPropertyMax : '',
                'pimMatchRequired': listQuestions[j].pimMatchRequired,
                'pimcategory': listQuestions[j].pimCategory,
                'questionType': listQuestions[j].type,
                'answers': [{
                  'answerType': answer.type,
                  'value': answer.values
                }]
              });
            } else {
              listPostData[i].questions.push({
                'key': listQuestions[j].pimProperty !== null && listQuestions[j].pimProperty !== undefined ? listQuestions[j].pimProperty : '',
                'keyMin': listQuestions[j].pimPropertyMin !== null && listQuestions[j].pimPropertyMin !== undefined ? listQuestions[j].pimPropertyMin : '',
                'keyMax': listQuestions[j].pimPropertyMax !== null && listQuestions[j].pimPropertyMax !== undefined ? listQuestions[j].pimPropertyMax : '',
                'pimMatchRequired': listQuestions[j].pimMatchRequired,
                'pimcategory': listQuestions[j].pimCategory,
                'questionType': listQuestions[j].type,
                'answers': [{
                  'answerType': answer.type,
                  'value': answer.values
                }]
              });
            }
          }
        });
      }; //for each questions


      for (var j = 0; j < listQuestions.length; j++) {
        _loop_2(j);
      }
    };

    var this_1 = this; //for each groups

    for (var i = 0; i < groups.length; i++) {
      _loop_1(i);
    }

    return listPostData;
  };

  DecisionTreeResults.prototype.getData = function () {
    var that = this;
    var json = JSON.stringify({
      decisiontree: that.getPostData()
    });
    var xhr = new XMLHttpRequest();
    xhr.open('POST', that.url);
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.send(json);

    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4 && xhr.status === 200) {
        that.initCallBack(xhr.responseText);
      }
    };
  };

  DecisionTreeResults.prototype.show = function () {
    this._parent.decisiontree.innerHTML = this.content;
    this.checkResponsiveWidth();
    var container = new container_1.Container();
    container.show();
    var rect = document.querySelector('.decisiontree').getBoundingClientRect();
    var offset = {
      top: rect.top + window.scrollY
    };
    scroll({
      top: offset.top - 80,
      behavior: 'smooth'
    });
    var legalNotice = new footnotes_1.Footnotes();
    new _Utils_1.Utils.EmptyUtils({
      wrapper: legalNotice.noticeContainer
    }).empty();
    legalNotice.init();
  };

  DecisionTreeResults.prototype.event = function () {
    var that = this;
    window.addEventListener('resize', function () {
      _Utils_1.Utils.LegacyUtils.waitForFinalEvent(function () {
        that.checkResponsiveWidth();
      }, 500, 'resizeCarousels');
    });

    _Utils_1.Utils.EventUtils.setDocEvent('mouseover', '[data-tree-product-id]', function (target) {
      var el = document.querySelectorAll('[data-tree-product-id="' + target.getAttribute('data-tree-product-id') + '"]');
      el.forEach(function (element) {
        var htmlTarget = element;
        htmlTarget.style.opacity = '1';
      });
    });

    _Utils_1.Utils.EventUtils.setDocEvent('mouseout', '[data-tree-product-id]', function (target) {
      var el = document.querySelectorAll('[data-tree-product-id="' + target.getAttribute('data-tree-product-id') + '"]');
      el.forEach(function (element) {
        var htmlTarget = element;
        htmlTarget.style.opacity = '';
      });
    });

    _Utils_1.Utils.EventUtils.setDocEvent('focus', '[data-tree-product-id] a', function (target) {
      var parent = target.closest('[data-tree-product-id]');
      var el = document.querySelectorAll('[data-tree-product-id="' + parent.getAttribute('data-tree-product-id') + '"]');
      el.forEach(function (element) {
        var htmlTarget = element;
        htmlTarget.style.opacity = '1';
      });
    });

    _Utils_1.Utils.EventUtils.setDocEvent('blur', '[data-tree-product-id] a', function (target) {
      var parent = target.closest('[data-tree-product-id]');
      var el = document.querySelectorAll('[data-tree-product-id="' + parent.getAttribute('data-tree-product-id') + '"]');
      el.forEach(function (element) {
        var htmlTarget = element;
        htmlTarget.style.opacity = '';
      });
    });
  };

  DecisionTreeResults.prototype.initCarousel = function () {
    var that = this;
    var relevantIndex = parseInt(document.querySelector('.m-product--relevant').getAttribute('data-tree-product-id'));

    if (relevantIndex === undefined) {
      relevantIndex = 0;
    }

    var carousel = new _Utils_1.Utils.OwlCarouselUtils({
      selector: $('.o-decisiontree__carousel'),
      caourselOtions: {
        stagePadding: 60,
        loop: false,
        nav: false,
        dots: true,
        dotsClass: 'a-dots',
        dotClass: 'a-dots__item',
        mergeFit: true,
        rewind: false,
        responsive: {
          0: {
            items: 1,
            dotsEach: true
          }
        },
        startPosition: relevantIndex,
        onInitialize: function onInitialize() {
          that.setSlide(relevantIndex);
        },
        onDragged: function onDragged(slider) {
          that.setSlide(slider.page.index);
        }
      }
    }).init();
  };
  /**
   * @param {integer} index
   */


  DecisionTreeResults.prototype.setSlide = function (index) {
    var productId = document.querySelectorAll('[data-tree-product-id]');
    productId.forEach(function (element) {
      var target = element;
      target.style.opacity = '';
    });
    var products = document.querySelector('.o-decisiontree__resultcontent').querySelectorAll('.m-product');
    products.forEach(function (element, count) {
      var target = element;
      target.style.display = 'none';
      target.style.opacity = '0.3';

      if (count === index) {
        target.style.display = 'block';
        target.style.opacity = '1';
      }
    });
    var el = document.querySelector('[data-tree-product-id="' + index.toString() + '"]');
    el.style.opacity = '1';
  };

  DecisionTreeResults.prototype.checkResponsiveWidth = function () {
    var that = this,
        productsContent = document.querySelector('.o-decisiontree__resultcontent');

    if (productsContent !== null) {
      var products = productsContent.querySelectorAll('.m-product');
      products.forEach(function (element) {
        var target = element;
        var productId = document.querySelectorAll('[data-tree-product-id]');

        if (!_Utils_1.Utils.ViewportUtils.isMobile()) {
          target.style.display = 'block';
          productId.forEach(function (element) {
            var target = element;
            target.style.opacity = '';
          });
          new _Utils_1.Utils.OwlCarouselUtils({
            selector: $('.o-decisiontree__carousel')
          }).destroy();
        } else {
          target.style.display = 'none';
          that.initCarousel();
          that.setSlide($('.o-decisiontree__carousel .owl-item.active').index());
        }
      });
    }
  };

  return DecisionTreeResults;
}();

exports.DecisionTreeResults = DecisionTreeResults;

},{"../../utils/_Utils":102,"../container":71,"../footnotes":77}],76:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.Step = void 0;

var _Utils_1 = require("../../utils/_Utils");

var footnotes_1 = require("../footnotes");

var container_1 = require("../container");

var Step =
/** @class */
function () {
  function Step(_parent) {
    this._parent = _parent;
    this.length = 1;
    this.targetStep = 0;
    this.url = document.querySelector('[data-tree]').getAttribute('data-tree-target');
  }

  Step.prototype.init = function () {
    this.event();
  };

  Step.prototype.renderQuestions = function () {
    var container = new container_1.Container();
    container.hide();
    this.getHtml();
    var legalNotice = new footnotes_1.Footnotes();
    legalNotice.hide();
  };

  Step.prototype.renderResult = function () {
    this._parent.results.getData();
  };

  Step.prototype.getHtml = function () {
    var that = this;
    var request = new XMLHttpRequest();
    this._parent.isAuthor ? request.open('GET', that.url + '.html?wcmmode=disabled', true) : request.open('GET', that.url + '.html', true);

    request.onload = function () {
      if (this.status >= 200 && this.status < 400) {
        that.show(this.response);
      }
    };

    request.send();
  };

  Step.prototype.show = function (html) {
    this._parent.decisiontree.innerHTML = html;

    var el = this._parent.decisiontree.querySelector('.o-decisiontree');

    var parent = el.parentNode;

    while (el.firstChild) {
      parent.insertBefore(el.firstChild, el);
    }

    parent.removeChild(el);

    this._parent.questions.initSelector();

    if (this._parent.questions.store.groups.length > 1) {
      this._parent.questions.buildStepperHeader();

      this._parent.questions.setStepperContent();

      this.stepper = new Stepper(document.querySelector('.bs-stepper'), {
        linear: false,
        animation: true
      });
      this.stepper.to(this._parent.questions.current.groupe + 1);

      if (!_Utils_1.Utils.ViewportUtils.isDesktop()) {
        var label = this.stepper._steps[this.targetStep].querySelector('.bs-stepper-label').textContent;

        this.stepper._element.querySelector('.bs-stepper-label--mobile').textContent = label;
      }

      var steps = this.stepper._steps;
      steps.forEach(function (element) {
        element.classList.add('completed');
        element.querySelector('.step-trigger').removeAttribute('disabled');
      });

      this._parent.questions.stepperHeader.querySelector('.line--disabled').classList.add('line--completed');
    } else {
      this._parent.questions.stepperHeader.style.display = 'none';
    }

    this._parent.questions.buildContent();

    this._parent.questions.populateQuestion(this._parent.questions.store); //* set selector after Question added to DOM


    this._parent.questions.questions = document.querySelectorAll('.o-decisiontree__questionwrapper');
    var rect = document.querySelector('.decisiontree').getBoundingClientRect();
    var offset = {
      top: rect.top + window.scrollY
    };
    scroll({
      top: offset.top - 80,
      behavior: 'smooth'
    });
  };

  Step.prototype.event = function () {
    var that = this;

    _Utils_1.Utils.EventUtils.setDocEvent('click', '[data-groups-step]', function (target, event) {
      event.preventDefault();
      that.renderQuestions();
    });
  };

  return Step;
}();

exports.Step = Step;

},{"../../utils/_Utils":102,"../container":71,"../footnotes":77}],77:[function(require,module,exports){
"use strict";

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

exports.__esModule = true;
exports.Footnotes = exports.IdRefs = void 0;

var _Utils_1 = require("../utils/_Utils");

var IdRefs =
/** @class */
function () {
  function IdRefs() {}

  return IdRefs;
}();

exports.IdRefs = IdRefs;
[];

var Footnotes =
/** @class */
function () {
  function Footnotes() {
    this.cpt = document.querySelectorAll('[data-footnotes]');
    this.accessLabel = '';
    this.noticeContainer = document.querySelector('.js-footnotes--container');
    this.footNotes = document.querySelectorAll('.js-footnotes--title');
    this.count = 1;
    this.id = 1;
    this.idRefs = [];
    this.footnoteList = [];
  }

  Footnotes.prototype.init = function () {
    var _this = this;

    if (this.footNotes.length > 0) {
      var _that_1 = this; // display block in case footnotes are loaded after ajax request


      this.noticeContainer.style.display = 'block';

      var setMarkers_1 = function setMarkers_1() {
        return __awaiter(_this, void 0, void 0, function () {
          return __generator(this, function (_a) {
            this.cpt.forEach(function (el) {
              var item = el;
              var ul = item.nextElementSibling.querySelector('.js-footnotes--list');
              _that_1.accessLabel = item.getAttribute('data-back-content');

              if (ul !== null) {
                _that_1.buildAnchors(item, ul, _that_1.count);
              }
            });
            return [2
            /*return*/
            ];
          });
        });
      };

      var setCount_1 = function setCount_1() {
        return __awaiter(_this, void 0, void 0, function () {
          return __generator(this, function (_a) {
            switch (_a.label) {
              case 0:
                return [4
                /*yield*/
                , setMarkers_1()];

              case 1:
                _a.sent();

                _that_1.setCount();

                _that_1.setId();

                return [2
                /*return*/
                ];
            }
          });
        });
      };

      var buildFootnoteList = function buildFootnoteList() {
        return __awaiter(_this, void 0, void 0, function () {
          return __generator(this, function (_a) {
            switch (_a.label) {
              case 0:
                return [4
                /*yield*/
                , setCount_1()];

              case 1:
                _a.sent();

                _that_1.buildLegalNotice(_that_1.footnoteList);

                return [2
                /*return*/
                ];
            }
          });
        });
      };

      buildFootnoteList();
      this.events();
    } else {
      if (this.noticeContainer !== null) {
        this.noticeContainer.style.display = 'none';
      }
    }
  };
  /**
   * Set markers number
   * If markers point to the same footnote they have identical number
   */


  Footnotes.prototype.setCount = function () {
    var _this = this;

    var sup = document.querySelectorAll('.a-footnote');
    sup.forEach(function (el) {
      var _that = _this;
      var item = el;
      var name = item.getAttribute('name');

      var NameinArr = _that.idRefs.find(function (o) {
        return o.name === name;
      });

      var noteLabel = _that.noticeContainer.getAttribute('data-note-label');

      if (NameinArr === undefined) {
        var nb = _that.count++;
        item.querySelector('sup').textContent = '(' + nb.toString() + ')';
        item.setAttribute('aria-label', noteLabel + '(' + nb.toString() + ')');
        item.setAttribute('href', '#footnote-' + nb.toString());

        _that.idRefs.push({
          el: item,
          name: item.getAttribute('name'),
          id: item.getAttribute('id')
        });

        _that.footnoteList.push(item);
      } else {
        var link = document.querySelector('a[name="' + name + '"]');
        var digitRegex = /\d+/g;
        var nb = link.querySelector('sup').textContent.match(digitRegex);
        item.querySelector('sup').textContent = link.querySelector('sup').textContent;
        item.setAttribute('href', '#footnote-' + nb.toString());
        item.setAttribute('aria-label', noteLabel + '(' + nb.toString() + ')');
      }
    });
  };

  Footnotes.prototype.setId = function () {
    var _this = this;

    var sup = document.querySelectorAll('.a-footnote');
    sup.forEach(function (el) {
      var _that = _this;
      var item = el;
      item.setAttribute('id', 'footnote-id--' + _that.id.toString());
      _that.id++;
    });
  };
  /**
   * replace "*$" in contribution title by legal mention iteration count in push list
   */


  Footnotes.prototype.buildAnchors = function (el, ul, count) {
    var noticeRgex = /[*$]{2}/g;

    var _that = this;

    var li = Array.from(ul.querySelectorAll('li'));
    /* Replace *$ by html anchor element */

    var replaceHtml = function replaceHtml() {
      var labeltxt = el.innerHTML;

      if (labeltxt.match(noticeRgex)) {
        var replace = labeltxt.replace(noticeRgex, '<a><sup></sup></a>');
        el.innerHTML = replace;
      }
    };
    /* remove exceeding li html element */


    var _exceed_ = function _exceed_() {
      var li = Array.from(el.nextElementSibling.querySelectorAll('li'));
      var sup = el.querySelectorAll('sup'); // Remove list item if li tags are > to <sup> tags

      if (li.length > sup.length) {
        var exceed = li.slice(sup.length, li.length);
        exceed.forEach(function (element) {
          var node = element.parentNode;
          node.removeChild(element);
        });
        var NodeLi = new _Utils_1.Utils.CloneUtils({
          list: li
        }).toNodeList();
        _that.list = NodeLi;
      }
    };
    /* remove exceeding sup html element + set name data-attribute */


    var checkSup = function checkSup() {
      var sup = el.parentElement.querySelectorAll('sup');
      sup.forEach(function (el, z) {
        // Remove sup item if <sup> tags are > to <li> tags
        if (z + 1 > li.length) {
          el.parentNode.removeChild(el);
        } else {
          var textEl = document.createElement('span');
          textEl.textContent = li[z].innerHTML;
          textEl.classList.add('u-hidden--all');
          el.parentElement.classList.add('a-footnote');
          el.parentElement.setAttribute('name', li[z].getAttribute('name'));
          el.parentElement.appendChild(textEl);
        }
      });
    };

    replaceHtml();

    _exceed_();

    checkSup();
    _that.sup = document.querySelectorAll('a[id*="footnote-id"]');
    _that.count = count;
  };
  /**
   * Footnote list
   */


  Footnotes.prototype.buildLegalNotice = function (list) {
    var _that = this;

    var toArr = Array.from(list);
    var sup = document.querySelectorAll('.a-footnote');

    if (toArr !== undefined) {
      toArr.forEach(function (el, z) {
        var id = (z + 1).toString();

        if (!el.isEqualNode(sup[z])) {
          id = el.getAttribute('id').split('--')[1];
        }

        var txt = el.querySelector('span').textContent;
        var tpl = "<li class='js-footnotes--title a-text a-text--tiny a-footnote__list-item u-margin-3xs-bottom' tabindex='-1' id='footnote-" + (z + 1).toString() + "' ><div><span class=\"a-footnote__number\">(" + (z + 1) + ")</span>" + txt + "</div><a href='#footnote-id--" + id + "' class=\"sr-only-focusable\"><span>" + _that.accessLabel + "</span></a></li>";
        _that.noticeContainer.innerHTML += tpl;
      });
      this.noticeContainer.classList.add('u-spacing-3xl-bottom');
    }
  };

  Footnotes.prototype.hide = function () {
    if (this.noticeContainer !== null) {
      this.noticeContainer.style.display = 'none';
    }
  };

  Footnotes.prototype.events = function () {
    var that = this;

    _Utils_1.Utils.EventUtils.setDocEvent('click', '.a-footnote', function (target, event) {
      event.preventDefault();
      var href = target.getAttribute('href');
      var id = target.getAttribute('id');
      var anchorid = href.split('#')[1];
      var anchor = document.querySelector('[id="' + anchorid + '"]');
      var link = anchor.querySelectorAll('a');
      var strSplit;
      link.forEach(function (el) {
        var item = el;

        if (item.getAttribute('href') !== null && item.getAttribute('href').startsWith('#')) {
          strSplit = item.getAttribute('href').split('#')[1];
        }
      });

      if (id !== strSplit) {
        var anchorList = anchor.querySelectorAll('a');
        anchorList.forEach(function (el) {
          var item = el;
          var href = item.getAttribute('href');

          if (href !== null && href.startsWith('#')) {
            item.setAttribute('href', '#' + id);
          }
        });
      }

      new _Utils_1.Utils.ScrollUtils({
        el: anchor
      }).scrollTo();
    });

    _Utils_1.Utils.EventUtils.setDocEvent('click', '.js-footnotes--container li', function (target, event) {
      event.preventDefault();
      /* return target */

      console.log('target : ', target);
      new _Utils_1.Utils.ScrollUtils({
        el: that.getTarget(target)
      }).scrollTo();
    });
  };
  /**
   * return target anchor element
   * @param {HTMLElement} el anchor element
   */


  Footnotes.prototype.getTarget = function (el) {
    var href = el.querySelectorAll('a');
    var anchorid;
    href.forEach(function (el) {
      var item = el;
      var href = item.getAttribute('href');

      if (href !== null && href.startsWith('#')) {
        anchorid = item.getAttribute('href').split('#')[1];
      }
    });
    var target = document.querySelector('a[id="' + anchorid + '"]');
    return target;
  };

  return Footnotes;
}();

exports.Footnotes = Footnotes;

},{"../utils/_Utils":102}],78:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.AnimateLines = void 0;

var AnimateLines =
/** @class */
function () {
  function AnimateLines(options) {
    this.options = options;
  }

  AnimateLines.prototype.animate = function () {
    if (this.options.line !== undefined) {
      this.options.line.classList.add(this.options.htmlClass);
      this.options.line.style.width = this.options.width;
      this.options.line.style.height = this.options.height;
      this.options.line.style.visibility = this.options.visibility;
      this.options.line.style.top = this.options.top;
      this.options.line.style.left = this.options.left;
      this.options.line.style.marginLeft = this.options.marginLeft;
    }
  };

  return AnimateLines;
}();

exports.AnimateLines = AnimateLines;

},{}],79:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.Connect = void 0;

var _Utils_1 = require("../../utils/_Utils");

var Connect =
/** @class */
function () {
  /**
   * Connect Constructor
   * detect if connected and change icon and label of connect component
   */
  function Connect(header) {
    this.connectedIcon = 'ic-safety-locker-locked';

    if (this.isConnected()) {
      this.header = header;
      this.connectbutton = this.header.querySelector('.m-header__links__item__connect');

      if (this.connectbutton) {
        this.connectedLabel = this.connectbutton.getAttribute('data-connected-label');
        this.connectedTitle = this.connectbutton.getAttribute('data-connected-acces-label');
        this.setConnected();
      }
    }
  }
  /**
   * setConnected
   * change icon and label of connect component
   */


  Connect.prototype.setConnected = function () {
    var div = document.createElement('div');
    div.innerHTML = _Utils_1.Utils.IconUtils.getNewIcon(this.connectedIcon) + "\n        <span class=\"sr-only-sm\">" + this.connectedLabel + "</span>";
    this.connectbutton.setAttribute('title', this.connectedTitle);
    this.connectbutton.innerHTML = ''; //replace content with new Icon

    this.connectbutton.appendChild(div);
    var wrapper = this.connectbutton.querySelector('div');
    wrapper.outerHTML = wrapper.innerHTML;
  };
  /**
   * isConnected
   * read cookie IDENT, return true if user is connected
   */


  Connect.prototype.isConnected = function () {
    var row = document.cookie.split('; ').find(function (row) {
      return row.startsWith('IDENT=');
    });
    var value = false;

    if (row !== undefined) {
      if (row.split('=')[1] === '1') {
        value = true;
      }
    }

    return value;
  };

  return Connect;
}();

exports.Connect = Connect;

},{"../../utils/_Utils":102}],80:[function(require,module,exports){
"use strict";

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

exports.__esModule = true;
exports.Header = void 0;

var menu_1 = require("./menu");

var submenu_1 = require("./submenu");

var sublist_1 = require("./sublist");

var connect_1 = require("./connect");

var headerlinks_1 = require("./headerlinks");

var search_1 = require("../search/search");

var animatelines_1 = require("./animatelines");

var warnbanner_1 = require("../warnbanner");

var _Utils_1 = require("../../utils/_Utils");

var MenuLevels;

(function (MenuLevels) {
  MenuLevels[MenuLevels["Menu"] = 1] = "Menu";
  MenuLevels[MenuLevels["SubMenu"] = 2] = "SubMenu";
  MenuLevels[MenuLevels["SubList"] = 3] = "SubList";
})(MenuLevels || (MenuLevels = {}));

var Header =
/** @class */
function () {
  function Header() {
    this.header = document.getElementById('header');

    if (this.header !== null && !this.header.classList.contains('o-header--simplified')) {
      this.menuHorizontalLine = document.getElementById('menu-h-line');
      this.subMenuVLine;
      this.subMenuHLine;
      this.subListLine;
      this.menu = new menu_1.Menu(this.header);
      this.subMenu = new submenu_1.SubMenu();
      this.subList = new sublist_1.SubList();
      this.connect = new connect_1.Connect(this.header);
      this.search = new search_1.Search();
      this.headerlinks = new headerlinks_1.HeaderLinks();
      this.backBtn = this.menu.list.querySelectorAll('.m-header__panel__back');
      this.subMenuId;
      this.menuReverse = false;
      this.langBtn = this.header.querySelector('.m-header__lang__item');
      this.links = this.header.querySelectorAll('a');
      this.langStateOpen = false;
      this.isEditMode = false;
      this.vp = new _Utils_1.ViewportDetect();
      this.warnbanner = new warnbanner_1.WarnBanner();
      this.isSticky = false;
      this.isHomePage = new _Utils_1.Utils.PageUtils().IsHomePage();
      this.pushLink = document.querySelectorAll('.m-header__submenu__push a');
      this.assistanceLink = this.menu.list.querySelectorAll('.m-header__submenu__card');

      if (this.isHomePage === false) {
        this.logo = this.header.querySelector('.js-logo-type');
      }
    }
  }

  Header.prototype.init = function () {
    this.isEditMode = this.header.className.lastIndexOf('o-header--edit') > -1 ? true : false;

    if (this.isEditMode === false) {
      this.events();
    }
  };

  Header.prototype.events = function () {
    var that = this; // All mouseover/mouseleave event on desktop menu

    if (_Utils_1.Utils.ViewportUtils.isDesktop()) {
      this.subMenu.item.forEach(function (item) {
        item.addEventListener('mouseover', function (e) {
          var _this = this;

          var htmlTarget = e.target;
          var htmlItem = item;

          if (that.subMenu.itemOpened && (htmlTarget.isEqualNode(this) || htmlTarget.parentElement.isEqualNode(this))) {
            var doPadding_1 = function doPadding_1() {
              return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                  switch (_a.label) {
                    case 0:
                      that.openPadding(htmlItem);
                      return [4
                      /*yield*/
                      , new _Utils_1.Utils.PromiseUtils({
                        item: htmlItem
                      }).onceAnimationEnd()];

                    case 1:
                      _a.sent();

                      return [2
                      /*return*/
                      ];
                  }
                });
              });
            };

            var updateLine = function updateLine() {
              return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                  switch (_a.label) {
                    case 0:
                      return [4
                      /*yield*/
                      , doPadding_1()];

                    case 1:
                      _a.sent();

                      that.UpdateSubMenuLines();
                      return [2
                      /*return*/
                      ];
                  }
                });
              });
            };

            updateLine();
          } else {
            that.openPadding(item);
          }
        });
      });
      this.subMenu.item.forEach(function (item) {
        item.addEventListener('mouseout', function () {
          if (!this.isEqualNode(that.subMenu.itemOpened)) {
            that.closePadding(item);

            if (that.subMenu.itemOpened) {
              that.UpdateSubMenuLines();
            }
          }
        });
      });
      this.subList.item.forEach(function (item) {
        item.addEventListener('mouseover', function () {
          that.openPadding(item);
          that.subListLine = this.querySelector('.sublist-h-line ');
          that.updateSubListLines(item);
        });
      });
      this.subList.item.forEach(function (item) {
        item.addEventListener('mouseleave', function () {
          that.closePadding(item);
          var lineList = [that.subListLine];
          that.RemoveLines(lineList);
        });
      });
      this.subList.panel.forEach(function (item) {
        item.addEventListener('mouseover', function (e) {
          var htmlTarget = e.target;

          if (!htmlTarget.isEqualNode(this)) {
            return;
          } else {
            that.UpdateSubMenuLines();
            that.RemoveLines([that.subListLine]);
          }
        });
      });
      this.subList.panel.forEach(function (item) {
        item.addEventListener('mouseleave', function () {
          that.RemoveLines([that.subListLine]);
          that.UpdateSubMenuLines();
        });
      });
    }

    window.addEventListener('resize', function () {
      _Utils_1.Utils.LegacyUtils.waitForFinalEvent(function () {
        var currentVp = that.vp.getCurrentVp();

        if ((currentVp === 'xs' || currentVp === 'sm') && that.menu.stateOpened === true) {
          var lineList = [that.menuHorizontalLine, that.subMenuVLine, that.subMenuHLine];
          that.RemoveLines(lineList);
          that.menu.hamburgerStateOpen = false;
          that.MobileMenu(that.menu.hamburger);
        } else if (currentVp === 'md') {
          if (that.subMenu.itemOpened !== undefined) {
            that.CreateLines(that.subMenu.itemOpened);
          }

          document.querySelector('html').style.overflow = 'auto';
        }
      }, 100);
    }); // Click events

    this.menu.item.forEach(function (item) {
      return item.addEventListener('click', function (e) {
        var htmlTarget = e.target;

        if (htmlTarget.isEqualNode(this) || htmlTarget.parentElement.isEqualNode(this)) {
          if (htmlTarget.tagName !== 'A') {
            e.preventDefault();
            that.Menu(this, e.target);
          }

          if (!_Utils_1.Utils.ViewportUtils.isDesktop()) {
            var backBtn = item.querySelector('.m-header__panel__back');
            htmlTarget.classList.remove('is--focused');
            that.focusBackBtn(backBtn);
          }
        }
      });
    });
    this.subMenu.item.forEach(function (item) {
      return item.addEventListener('click', function (e) {
        var htmlTarget = e.target;

        if (htmlTarget.isEqualNode(this) || htmlTarget.parentElement.isEqualNode(this)) {
          var isLink = this.querySelector('.a-navigation__submenu__item__label').tagName === 'A';

          if (!isLink) {
            e.preventDefault();
            that.SubMenu(this, e);
          }

          that.subMenuHLine = this.querySelector('.submenu-h-line');
          that.subMenuVLine = that.menu.itemOpened.querySelector('.submenu-v-line');

          if (!_Utils_1.Utils.ViewportUtils.isDesktop()) {
            var backBtn = item.querySelector('.m-header__panel__back');
            that.focusBackBtn(backBtn);
          }
        }
      });
    });
    this.backBtn.forEach(function (item) {
      return item.addEventListener('click', function (e) {
        var level = parseInt(this.getAttribute('data-level'));
        var levelObj = that.CheckLevel(level - 1);
        var itemopened = levelObj.itemOpened;
        setTimeout(function () {
          var htmlTarget = e.target;
          new _Utils_1.Utils.AttributesUtils({
            el: htmlTarget,
            attrs: {
              'aria-hidden': 'true',
              'tabindex': '-1'
            }
          }).setAttributes();
          itemopened.querySelector('.js-navigation-menu-target').classList.add('is--focused');
          itemopened.querySelector('.js-navigation-menu-target').focus();
        }, 300);
        that.CloseMenu(level - 1); // Remove accessibility attributes on menu level

        if (level === 2 && !_Utils_1.Utils.ViewportUtils.isDesktop()) {
          that.setAccessibilityAttrs(that.menu.item, that.menu.stateOpened);
        } // Remove accessibility attributes on submenu level


        if (level === 3 && !_Utils_1.Utils.ViewportUtils.isDesktop()) {
          that.setAccessibilityAttrs(that.subMenu.item, that.subMenu.stateOpened);
        }
      });
    });
    this.menu.hamburger.addEventListener('click', function (e) {
      e.preventDefault();
      that.MobileMenu(this);
    });

    if (this.search.searchHeader.searchOpen !== undefined) {
      this.search.searchHeader.searchOpen.addEventListener('click', function (e) {
        e.preventDefault();
        var lineList = [that.menuHorizontalLine, that.subMenuVLine, that.subMenuHLine];
        that.RemoveLines(lineList);
        that.search.searchHeader.open(this.parentElement);

        if (_Utils_1.Utils.ViewportUtils.isMobile()) {
          document.querySelector('html').style.overflow = 'hidden';
        }

        if (that.menu.hamburgerStateOpen) {
          that.menu.list.classList.remove('opened');
          that.menu.hamburger.classList.remove('active');
        }

        if (that.menu.itemOpened) {
          that.CloseMenu(1);
        }

        if (that.subMenu.itemOpened) {
          that.closePadding(that.subMenu.itemOpened);
          that.CloseMenu(2);
        } // Avoid calling twice search


        e.stopPropagation();
      });
    }
    /**
     *  Manage scroll animation & sticky behavior
     */


    var lastScrollTop = 0;
    window.addEventListener('scroll', function (e) {
      var st = window.pageYOffset || document.documentElement.scrollTop; //scroll DOWN

      if (st > lastScrollTop) {
        if (that.warnbanner.banner !== null && that.warnbanner.stateOpen === true) {
          if (window.pageYOffset > 0) {
            that.warnbanner.banner.classList.add('o-warnbanner--moved');
          }
        }

        if (window.pageYOffset > 130 && window.pageYOffset < 150) {
          that.header.classList.add('o-header--moved');
        }

        if (window.pageYOffset > 165) {
          that.header.classList.remove('o-header--moved');
          that.header.classList.add('o-header--sticky');
          that.isSticky = true;

          if (that.menu.itemOpened !== undefined) {
            var lines = [that.menuHorizontalLine, that.subMenuVLine, that.subMenuHLine];

            if (that.menu.stateOpened === true) {
              that.CloseMenu(1);
            }

            if (that.subMenu.stateOpened === true) {
              that.closePadding(that.subMenu.itemOpened);
              that.CloseMenu(2);
            }

            that.RemoveLines(lines);
          }
        } //scroll UP

      } else {
        if (window.pageYOffset < 10) {
          that.header.classList.remove('o-header--moved--up');
        }

        if (window.pageYOffset > 10 && window.pageYOffset < 190) {
          that.header.classList.remove('o-header--moved');
          that.header.classList.add('o-header--moved--up');

          if (that.warnbanner.banner !== null && that.warnbanner.stateOpen === true) {
            that.warnbanner.banner.classList.remove('o-warnbanner--moved');
          }
        }

        if (window.pageYOffset < 190) {
          that.header.classList.remove('o-header--sticky');
          that.isSticky = false;
          var lines = [that.menuHorizontalLine, that.subMenuVLine, that.subMenuHLine];
          that.RemoveLines(lines);
        }
      } //update scroll position


      lastScrollTop = st <= 0 ? 0 : st;

      if (that.search.searchHeader !== undefined && that.search.searchHeader.isOpen === true) {
        that.search.searchHeader.close();
      }
    });
    /**
     * Close Menu when click outside menu
     */

    document.addEventListener('click', function (e) {
      var htmlTarget = e.target;

      if (!htmlTarget.isEqualNode(that.header) && !htmlTarget.closest('header') && that.menu.stateOpened === true) {
        that.CloseMenu(1);
        that.subMenu.stateOpened = false;
        that.menu.stateOpened = false;

        if (_Utils_1.Utils.ViewportUtils.isDesktop()) {
          that.RemoveLines([that.menuHorizontalLine, that.subMenuHLine, that.subMenuVLine, that.subListLine]);

          if (that.subMenu.itemOpened) {
            that.closePadding(that.subMenu.itemOpened);
            that.CloseMenu(2);
          }
        }
      }
    });
    /**
     * Accessibility events
     */

    document.addEventListener('DOMContentLoaded', function () {
      if (_Utils_1.Utils.ViewportUtils.isDesktop()) {
        that.subMenu.titles.forEach(function (item) {
          return item.removeAttribute('tabindex');
        });
      }

      if (_Utils_1.Utils.ViewportUtils.isMobile()) {
        var isClient = that.header.querySelector('.m-header__links').getAttribute('data-client');
        var btnClient = that.header.querySelector('#client');

        if (isClient === 'false' && btnClient) {
          var htmlClient = btnClient.parentElement;
          htmlClient.remove();
        }
      }
    });
    document.addEventListener('keydown', function (e) {
      if (e.which === 27 && that.menu.stateOpened === true) {
        that.menu.itemOpened.querySelector('button').focus();
        that.menu.itemOpened.querySelector('button').classList.add('is--focused');
        that.CloseMenu(1);
      }
    });
    this.menu.hamburger.addEventListener('keydown', function (e) {
      var isTab = e.which === 9 || e.key === 'Tab';
      var isEnter = e.which === 13 || e.key === 'Enter';

      if (isEnter) {
        e.preventDefault();
        that.MobileMenu(this);
      }

      if (isTab) {
        if (that.menu.stateOpened === true && that.subMenu.stateOpened === false) {
          e.preventDefault();
          that.menu.itemOpened.querySelector('.m-header__panel__back').focus();
        } else if (that.subMenu.stateOpened) {
          e.preventDefault();
          that.subMenu.itemOpened.querySelector('.m-header__panel__back').focus();
        }
      }
    });
    this.menu.item.forEach(function (item) {
      return item.addEventListener('keydown', function (e) {
        var htmlTarget = e.target;
        var isTab = e.which === 9 || e.key === 'Tab';
        var isEnter = e.which === 13 || e.key === 'Enter';
        var isSpace = e.which === 32 || e.key === 'Space';

        if (htmlTarget.isEqualNode(this) || htmlTarget.parentElement.isEqualNode(this)) {
          if (isEnter || isSpace) {
            if (htmlTarget.tagName === 'BUTTON') {
              e.preventDefault();
              that.Menu(this, e.target);

              if (!_Utils_1.Utils.ViewportUtils.isDesktop()) {
                var backBtn = item.querySelector('.m-header__panel__back');
                that.focusBackBtn(backBtn);
              }
            }
          }

          if (isTab) {
            if (!_Utils_1.Utils.ViewportUtils.isDesktop()) {
              e.preventDefault();
              new _Utils_1.Utils.FocusUtils({
                item: that.header,
                event: e,
                focusableSelectors: that.menu.focusables
              }).setFocus();
            }
          }
        }
      });
    }); // FF complete prevent default of keydown event on same selector

    this.menu.item.forEach(function (item) {
      return item.addEventListener('keyup', function (e) {
        var isEnter = e.which === 13 || e.key === 'Enter';
        var isSpace = e.which === 32 || e.key === 'Space';

        if (isEnter || isSpace) {
          e.preventDefault();
        }
      });
    });
    this.subMenu.item.forEach(function (item) {
      return item.addEventListener('keydown', function (e) {
        var htmlTarget = e.target;
        var keybordEvent = e;
        var isTab = keybordEvent.which === 9 || keybordEvent.key === 'Tab';
        var isEnter = keybordEvent.which === 13 || keybordEvent.key === 'Enter';
        var isLink = this.querySelector('.a-navigation__submenu__item__label').tagName === 'A';
        var isSpace = e.which === 32 || e.key === 'Space';

        if (htmlTarget.isEqualNode(this) || htmlTarget.parentElement.isEqualNode(this)) {
          if (!isLink && (isEnter || isSpace)) {
            e.preventDefault();
            that.SubMenu(this, keybordEvent);
            var backBtn = item.querySelector('.m-header__panel__back');
            htmlTarget.classList.remove('is--focused');
            that.focusBackBtn(backBtn);
          }

          if (!_Utils_1.Utils.ViewportUtils.isDesktop() && isTab) {
            new _Utils_1.Utils.FocusUtils({
              item: that.header,
              event: keybordEvent,
              focusableSelectors: that.subMenu.focusables
            }).setFocus(); // Close Menu if is last submenu item
          } else if (_Utils_1.Utils.ViewportUtils.isDesktop() && isTab) {
            var assistanceLink = that.menu.itemOpened.querySelector('.m-header__submenu__card');
            var pushLink = that.menu.itemOpened.querySelector('.m-header__submenu__push a');

            if (htmlTarget.parentElement.getAttribute('last-item') !== null && that.subMenu.stateOpened === false && assistanceLink === null && pushLink === null) {
              that.CloseMenu(1);
            }
          }
        }
      });
    });
    this.pushLink.forEach(function (item) {
      item.addEventListener('keydown', function (e) {
        var htmlTarget = e.target;
        var keybordEvent = e;
        var isTab = keybordEvent.which === 9 || keybordEvent.key === 'Tab';

        if (htmlTarget.isEqualNode(this) && isTab) {
          if (_Utils_1.Utils.ViewportUtils.isDesktop()) {
            that.CloseMenu(1);
          }
        }
      });
    });
    this.assistanceLink.forEach(function (item) {
      item.addEventListener('keydown', function (e) {
        var htmlTarget = e.target;
        var keybordEvent = e;
        var isTab = keybordEvent.which === 9 || keybordEvent.key === 'Tab';

        if (htmlTarget.isEqualNode(this) || htmlTarget.closest('a').isEqualNode(this) && isTab) {
          if (_Utils_1.Utils.ViewportUtils.isDesktop() && isTab) {
            that.CloseMenu(1);
          }
        }
      });
    });
    this.subList.item.forEach(function (item) {
      item.addEventListener('keydown', function (e) {
        var htmlTarget = e.target;
        var keybordEvent = e;
        var isTab = keybordEvent.which === 9 || keybordEvent.key === 'Tab';
        var lastItem = item.getAttribute('last-item') !== null;
        var lastParentItem = that.subMenu.itemOpened.getAttribute('last-item') !== null;
        var pushLink = that.menu.itemOpened.querySelector('.m-header__submenu__card'); // Close Menu if is last item in sublist + last submenu item

        if (htmlTarget.isEqualNode(this) || htmlTarget.closest('li').isEqualNode(this)) {
          if (_Utils_1.Utils.ViewportUtils.isDesktop() && isTab && !keybordEvent.shiftKey) {
            if (lastItem && lastParentItem && !pushLink) {
              that.CloseMenu(2);
              that.CloseMenu(1);
            } else if (lastItem && !lastParentItem) {
              that.CloseMenu(2);
            }
          }

          if (!_Utils_1.Utils.ViewportUtils.isDesktop() && isTab) {
            e.preventDefault();
            new _Utils_1.Utils.FocusUtils({
              item: that.header,
              event: e,
              focusableSelectors: that.subList.focusables
            }).setFocus();
          }
        }
      });
    });
    this.backBtn.forEach(function (item) {
      return item.addEventListener('keydown', function (e) {
        var keybordEvent = e;
        var isTab = keybordEvent.which === 9 || keybordEvent.key === 'Tab';
        var isEnter = keybordEvent.which === 13 || keybordEvent.key === 'Enter';
        var isSpace = e.which === 32 || e.key === 'Space';
        var level = parseInt(this.getAttribute('data-level'));
        var levelObj = that.CheckLevel(level - 1);
        var itemopened = levelObj.itemOpened;

        if (isSpace || isEnter || isTab && keybordEvent.shiftKey) {
          e.preventDefault();
          var level_1 = parseInt(this.getAttribute('data-level'));
          that.CloseMenu(level_1 - 1); // Remove accessibility attributes on menu level

          if (level_1 === 2 && !_Utils_1.Utils.ViewportUtils.isDesktop()) {
            that.setAccessibilityAttrs(that.menu.item, that.menu.stateOpened);
          } // Remove accessibility attributes on submenu level


          if (level_1 === 3 && !_Utils_1.Utils.ViewportUtils.isDesktop()) {
            that.setAccessibilityAttrs(that.subMenu.item, that.subMenu.stateOpened);
          }

          setTimeout(function () {
            var htmlTarget = e.target;
            new _Utils_1.Utils.AttributesUtils({
              el: htmlTarget,
              attrs: {
                'aria-hidden': 'true',
                'tabindex': '-1'
              }
            }).setAttributes();
            itemopened.querySelector('.js-navigation-menu-target').classList.add('is--focused');
            itemopened.querySelector('.js-navigation-menu-target').focus();
          }, 300);
        }
      });
    });
    this.links.forEach(function (item) {
      return item.addEventListener('keydown', function (e) {
        var keybordEvent = e;
        var isEnter = keybordEvent.which === 13 || keybordEvent.key === 'Enter';
        var isSpace = keybordEvent.which === 32 || keybordEvent.key === 'Space';

        if (isEnter || isSpace) {
          this.click();
        }
      });
    });
  };

  Header.prototype.Menu = function (item, target) {
    var htmlTarget = target;
    var targetEqualItemOpen;

    if (this.menu.itemOpened !== undefined) {
      targetEqualItemOpen = htmlTarget.parentElement.isEqualNode(this.menu.itemOpened) || htmlTarget.isEqualNode(this.menu.itemOpened);
    } //click on menu item opened


    if (this.menu.stateOpened === true && targetEqualItemOpen) {
      var lineList = [this.menuHorizontalLine, this.subMenuVLine, this.subMenuHLine];
      this.CloseMenu(1);
      this.RemoveLines(lineList);

      if (this.subMenu.stateOpened === true) {
        this.CloseMenu(2);

        if (_Utils_1.Utils.ViewportUtils.isDesktop()) {
          this.closePadding(this.subMenu.itemOpened);
        }
      } //click on other menu item

    } else if (this.menu.stateOpened === true && !targetEqualItemOpen) {
      this.CloseMenu(1);
      this.OpenMenu(item, 1); //close submenu item if opened

      if (this.subMenu.itemOpened !== undefined && this.subMenu.itemOpened !== '') {
        if (_Utils_1.Utils.ViewportUtils.isDesktop()) {
          var lineList = [this.menuHorizontalLine, this.subMenuVLine, this.subMenuHLine];
          this.RemoveLines(lineList);
          this.closePadding(this.subMenu.itemOpened);
        }

        item.querySelector('button').setAttribute('aria-expanded', 'false');
        item.querySelector('button').setAttribute('aria-current', 'false');
        this.CloseMenu(2);
      } //no menu item opened yet

    } else if (this.menu.stateOpened === false) {
      this.OpenMenu(item, 1);

      if (!_Utils_1.Utils.ViewportUtils.isDesktop()) {
        this.setAccessibilityAttrs(this.menu.item, this.menu.stateOpened);
      }
    }

    if (!_Utils_1.Utils.ViewportUtils.isDesktop()) {
      this.checkMenuPosition(item.querySelector('.m-header__submenu'));
    }
  };

  Header.prototype.SubMenu = function (item, event) {
    var lineList = [this.subMenuHLine, this.subMenuVLine, this.menuHorizontalLine]; //click on submenu opened

    if (this.subMenu.stateOpened === true && item.isEqualNode(this.subMenu.itemOpened)) {
      if (_Utils_1.Utils.ViewportUtils.isDesktop()) {
        this.RemoveLines(lineList);
        this.closePadding(item);
      }

      this.CloseMenu(2);
    } //no submenu opened yet
    else if (this.subMenu.stateOpened === false) {
        if (_Utils_1.Utils.ViewportUtils.isDesktop() && event.type === 'click') {
          this.CreateLines(item);
        }

        this.OpenMenu(item, 2);

        if (!_Utils_1.Utils.ViewportUtils.isDesktop()) {
          this.setAccessibilityAttrs(this.subMenu.item, this.menu.stateOpened);
        }
      } //click on submenu siblings
      else if (this.subMenu.stateOpened === true && !item.isEqualNode(this.subMenu.itemOpened)) {
          if (_Utils_1.Utils.ViewportUtils.isDesktop()) {
            this.closePadding(this.subMenu.itemOpened);

            if (event.type === 'click') {
              this.UpdateSubMenuLines();
            }
          }

          this.CloseMenu(2);
          this.OpenMenu(item, 2);
        }

    if (!_Utils_1.Utils.ViewportUtils.isDesktop()) {
      this.checkMenuPosition(item.querySelector('.m-header__sublist__panel'));
    }
  };

  Header.prototype.MobileMenu = function (item) {
    var menumobile = item.nextSibling;
    var closeLabel = item.getAttribute('data-close-title');
    var openLabel = item.getAttribute('data-open-title');
    var breadcrumb = document.querySelector('.m-breadcrumb');
    var footer = document.querySelector('footer');
    var main = document.querySelector('main');

    if (this.menu.hamburgerStateOpen === false) {
      item.classList.add('active');
      item.setAttribute('title', closeLabel);
      item.querySelector('.m-header__menu__hamburger__label').textContent = closeLabel;
      menumobile.nextElementSibling.querySelector('.m-header__menu__list').classList.add('opened');
      document.querySelector('html').style.overflow = 'hidden';
      this.menu.hamburgerStateOpen = true;
      new _Utils_1.Utils.AttributesUtils({
        el: footer,
        attrs: {
          'aria-hidden': 'false',
          'tabindex': '-1'
        }
      }).setAttributes();
      footer.style.visibility = 'hidden';
      new _Utils_1.Utils.AttributesUtils({
        el: main,
        attrs: {
          'aria-hidden': 'false',
          'tabindex': '-1'
        }
      }).setAttributes();
      main.style.visibility = 'hidden';

      if (breadcrumb !== null) {
        new _Utils_1.Utils.AttributesUtils({
          el: breadcrumb,
          attrs: {
            'aria-hidden': 'false',
            'tabindex': '-1'
          }
        }).setAttributes();
        breadcrumb.style.visibility = 'hidden';
      }

      if (this.search.searchHeader !== undefined && this.search.searchHeader.isOpen === true) {
        this.search.searchHeader.close();
      }

      if (this.langStateOpen === true) {
        this.langBtn.nextElementSibling.classList.toggle('opened');
        this.langStateOpen = false;
        this.langBtn.setAttribute('aria-expanded', 'false');
      }

      if (!_Utils_1.Utils.ViewportUtils.isDesktop()) {
        this.checkMenuPosition(this.menu.list);
      }
    } else {
      item.classList.remove('active');
      item.setAttribute('title', openLabel);
      item.querySelector('.m-header__menu__hamburger__label').textContent = openLabel;
      menumobile.nextElementSibling.querySelector('.m-header__menu__list').classList.remove('opened');
      document.querySelector('html').style.overflow = 'auto';
      this.menu.hamburgerStateOpen = false;
      new _Utils_1.Utils.AttributesUtils({
        el: footer,
        attrs: {
          'aria-hidden': 'false',
          'tabindex': ''
        }
      }).setAttributes();
      footer.style.visibility = 'visible';
      new _Utils_1.Utils.AttributesUtils({
        el: main,
        attrs: {
          'aria-hidden': 'false',
          'tabindex': ''
        }
      }).setAttributes();
      main.style.visibility = 'visible';

      if (breadcrumb !== null) {
        new _Utils_1.Utils.AttributesUtils({
          el: breadcrumb,
          attrs: {
            'aria-hidden': 'false',
            'tabindex': ''
          }
        }).setAttributes();
        breadcrumb.style.visibility = 'visible';
      }

      if (!_Utils_1.Utils.ViewportUtils.isDesktop()) {
        this.checkMenuPosition(this.menu.list);
      }
    }
  };

  Header.prototype.setAccessibilityAttrs = function (list, status) {
    list.forEach(function (item) {
      var el = item;
      el.querySelector('button').setAttribute('aria-hidden', status.toString());

      if (status === true) {
        el.querySelector('button').setAttribute('tabindex', '-1');
      } else {
        el.querySelector('button').removeAttribute('tabindex');
      }
    });
  };

  Header.prototype.focusBackBtn = function (el) {
    el.removeAttribute('tabindex');
    el.setAttribute('aria-hidden', 'false');
    setTimeout(function () {
      el.classList.add('is--focused');
      el.focus();
    }, 200);
  }; // Check Menu position depending on warnabbner & avoidlinks display


  Header.prototype.checkMenuPosition = function (item) {
    var avoidLinks = document.querySelector('.js-avoidlinks--displayed');
    var menuPosition;

    if (this.warnbanner !== null && this.warnbanner.stateOpen === true && this.isSticky === false && avoidLinks === null) {
      menuPosition = this.warnbanner.banner.clientHeight + this.header.clientHeight + 3;
      item.style.top = menuPosition.toString() + 'px';
    } else if (avoidLinks !== null && this.warnbanner.stateOpen === false && this.isSticky === false) {
      menuPosition = avoidLinks.clientHeight + this.header.clientHeight + 3;
      item.style.top = menuPosition.toString() + 'px';
    } else if (avoidLinks !== null && this.warnbanner.banner !== null && this.warnbanner.stateOpen === true && this.isSticky === false) {
      menuPosition = avoidLinks.clientHeight + this.warnbanner.banner.clientHeight + this.header.clientHeight + 3;
      item.style.top = menuPosition.toString() + 'px';
    } else {
      item.style.removeProperty('top');
    }
  }; // Submenu items animation


  Header.prototype.openPadding = function (item) {
    item.classList.add('moveleft');
  }; // Submenu items animation


  Header.prototype.closePadding = function (item) {
    item.classList.remove('moveleft');
  };

  Header.prototype.OpenMenu = function (item, level) {
    var levelObj = this.CheckLevel(level);
    item.classList.add('opened');
    levelObj.stateOpened = true;
    levelObj.itemOpened = item;
    new _Utils_1.Utils.AttributesUtils({
      el: item.querySelector('button'),
      attrs: {
        'aria-expanded': 'true',
        'aria-current': 'true'
      }
    }).setAttributes();
  };

  Header.prototype.CloseMenu = function (level) {
    var levelObj = this.CheckLevel(level);
    levelObj.itemOpened.classList.remove('opened');
    levelObj.stateOpened = false;
    new _Utils_1.Utils.AttributesUtils({
      el: levelObj.itemOpened.querySelector('button'),
      attrs: {
        'aria-expanded': 'false',
        'aria-current': 'false'
      }
    }).setAttributes();
    levelObj.itemOpened = undefined;
  };

  Header.prototype.CheckLevel = function (level) {
    switch (level) {
      case MenuLevels.Menu:
        return this.menu;

      case MenuLevels.SubMenu:
        return this.subMenu;

      case MenuLevels.SubList:
        return this.subList;
    }
  };

  Header.prototype.CreateLines = function (item) {
    var _this = this;

    var that = this;

    var runMenuLine = function runMenuLine() {
      return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              that.CreateMenuLine();
              return [4
              /*yield*/
              , new _Utils_1.Utils.PromiseUtils({
                item: that.menuHorizontalLine
              }).onceAnimationEnd()];

            case 1:
              _a.sent();

              return [2
              /*return*/
              ];
          }
        });
      });
    };

    var runVerticalLine = function runVerticalLine() {
      return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              return [4
              /*yield*/
              , runMenuLine()];

            case 1:
              _a.sent();

              that.CreateVerticalLine(false);
              return [4
              /*yield*/
              , new _Utils_1.Utils.PromiseUtils({
                item: that.subMenuVLine
              }).onceAnimationEnd()];

            case 2:
              _a.sent();

              return [2
              /*return*/
              ];
          }
        });
      });
    };

    var runSubMenuLine = function runSubMenuLine() {
      return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              return [4
              /*yield*/
              , runVerticalLine()];

            case 1:
              _a.sent();

              that.CreateSubmenuLine(item);
              return [4
              /*yield*/
              , new _Utils_1.Utils.PromiseUtils({
                item: that.subMenuVLine
              }).onceAnimationEnd()];

            case 2:
              _a.sent();

              return [2
              /*return*/
              ];
          }
        });
      });
    };

    runSubMenuLine();
  };

  Header.prototype.UpdateSubMenuLines = function () {
    var _this = this;

    var that = this;

    var removeSubMenuLine = function removeSubMenuLine() {
      return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
          that.RemoveLines([that.subMenuHLine]);
          return [2
          /*return*/
          ];
        });
      });
    };

    var updateVerticalLine = function updateVerticalLine() {
      return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              return [4
              /*yield*/
              , removeSubMenuLine()];

            case 1:
              _a.sent();

              that.CreateVerticalLine(false);
              return [2
              /*return*/
              ];
          }
        });
      });
    };

    var newSubMenuLine = function newSubMenuLine() {
      return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              return [4
              /*yield*/
              , updateVerticalLine()];

            case 1:
              _a.sent();

              that.CreateSubmenuLine(that.subMenu.itemOpened);
              return [2
              /*return*/
              ];
          }
        });
      });
    };

    newSubMenuLine();
  };

  Header.prototype.updateSubListLines = function (item) {
    var _this = this;

    var that = this;

    var updateVerticalLine = function updateVerticalLine() {
      return __awaiter(_this, void 0, void 0, function () {
        var submenuItemPos, itemPos, height;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              submenuItemPos = that.subMenu.itemOpened.getBoundingClientRect().top;
              itemPos = item.getBoundingClientRect().top;
              height = itemPos > submenuItemPos ? that.VerticalLinePosition(item).lineHeight : that.VerticalLinePosition(that.subMenu.itemOpened).lineHeight;
              that.CreateVerticalLine(true, height);
              return [4
              /*yield*/
              , height];

            case 1:
              _a.sent() !== 0 ? new _Utils_1.Utils.PromiseUtils({
                item: that.subMenuVLine
              }).onceAnimationEnd() : true;
              return [2
              /*return*/
              ];
          }
        });
      });
    };

    var subListLine = function subListLine() {
      return __awaiter(_this, void 0, void 0, function () {
        var submenuLine;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              return [4
              /*yield*/
              , updateVerticalLine()];

            case 1:
              _a.sent();

              submenuLine = new animatelines_1.AnimateLines({
                width: '20px',
                height: '1px',
                visibility: 'visible',
                htmlClass: 'transition-line-h',
                line: that.subListLine,
                left: '-40px'
              }).animate();
              return [2
              /*return*/
              ];
          }
        });
      });
    };

    subListLine();
  };

  Header.prototype.CreateVerticalLine = function (isSublist, height) {
    var that = this;
    var lineHeight;

    if (that.subMenu.itemOpened !== undefined) {
      lineHeight = isSublist === true ? height : that.VerticalLinePosition(that.subMenu.itemOpened).lineHeight;
    }

    var verticalLine = new animatelines_1.AnimateLines({
      width: '1px',
      height: lineHeight.toString().concat('px'),
      visibility: 'visible',
      htmlClass: 'transition-line-v',
      line: that.subMenuVLine
    }).animate();
  };

  Header.prototype.CreateSubmenuLine = function (item) {
    var width = this.SublinePosition(item).lineWidth > 0 ? this.SublinePosition(item).lineWidth : 15;
    var submenuLine = new animatelines_1.AnimateLines({
      width: width.toString().concat('px'),
      height: '1px',
      visibility: 'visible',
      htmlClass: 'transition-line-h',
      line: this.subMenuHLine,
      top: this.SublinePosition(item).posTop.toString().concat('px')
    }).animate();
  };

  Header.prototype.CreateMenuLine = function () {
    var that = this;
    var sublistpanel = this.menu.itemOpened.querySelector('.m-header__submenu__list__wrapper');
    var rectitem = this.menu.itemOpened.getBoundingClientRect();
    var rectsublistpanel = sublistpanel.getBoundingClientRect();
    var menu = this.menuHorizontalLine.parentElement;
    var itemWidth = this.menu.itemOpened.clientWidth / 2;
    var posItem = rectitem.left + itemWidth;
    var posRight = rectsublistpanel.right;
    var positive = posItem < posRight; // check if item is left or right side

    var startLinePos;
    var lineWidth;
    var lineWidthStr;

    if (!positive) {
      startLinePos = menu.clientWidth - (this.menu.itemOpened.offsetLeft + itemWidth);
      menu.classList.add('reverse');
      this.menuReverse = true;
      this.menuHorizontalLine.style.marginRight = startLinePos.toString().concat('px');
      lineWidth = Math.abs(posRight - posItem);
      lineWidthStr = lineWidth.toString().concat('px');
    } else {
      this.menuReverse === false;
      this.menuHorizontalLine.parentElement.classList.remove('reverse');
      startLinePos = this.menu.itemOpened.offsetLeft + itemWidth;
      this.menuHorizontalLine.style.marginLeft = startLinePos.toString().concat('px');
      lineWidth = posRight - posItem;
      lineWidthStr = lineWidth.toString().concat('px');
    }

    var menuLine = new animatelines_1.AnimateLines({
      width: lineWidthStr,
      height: '1px',
      visibility: 'visible',
      htmlClass: 'transition-line-h',
      line: that.menuHorizontalLine
    }).animate();
  };

  Header.prototype.SublinePosition = function (item) {
    var spanWidth;
    var posTop;
    var lineWidth;
    var line;
    var itemWidth = item.clientWidth;
    var span = item.querySelector('.a-navigation__submenu__item__label');

    if (span !== null) {
      spanWidth = span.offsetWidth;
      line = {
        posTop: item.offsetTop + item.offsetHeight / 2,
        lineWidth: itemWidth - spanWidth - 60
      };
    } else {
      line = {
        posTop: 0,
        lineWidth: 0
      };
    }

    return line;
  };

  Header.prototype.VerticalLinePosition = function (item) {
    var posBottom = item.offsetTop;
    var posTop = item.offsetHeight / 2;
    var line = {
      lineHeight: posTop + posBottom + 3
    };
    return line;
  };

  Header.prototype.RemoveLines = function (items) {
    items.forEach(function (item) {
      if (item !== undefined) {
        var remove = new animatelines_1.AnimateLines({
          width: '0',
          height: '1px',
          visibility: 'hidden',
          htmlClass: 'transition-line-h',
          line: item
        }).animate();
      }

      item = undefined;
    });
    this.menuReverse === false ? this.menuHorizontalLine.parentElement.classList.remove('reverse') : false;
  };

  return Header;
}();

exports.Header = Header;

},{"../../utils/_Utils":102,"../search/search":90,"../warnbanner":100,"./animatelines":78,"./connect":79,"./headerlinks":81,"./menu":83,"./sublist":85,"./submenu":86}],81:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.HeaderLinks = void 0;

var _Utils_1 = require("../../utils/_Utils");

var HeaderLinks =
/** @class */
function () {
  function HeaderLinks() {
    this.header = document.getElementById('header');

    if (this.header !== null) {
      this.headerlinks = this.header.querySelector('.m-header__links');
      this.headerlinksItem = this.headerlinks.children;

      if (this.headerlinksItem.length <= 1) {
        this.wrapper = this.header.querySelector('.o-header__itemwrapper');
        this.vp = new _Utils_1.ViewportDetect();
        this.events();
      }
    }
  }

  HeaderLinks.prototype.addWrapper = function () {
    this.wrapper.classList.add('o-header__itemwrapper--small');
  };

  HeaderLinks.prototype.removeWrapper = function () {
    this.wrapper.classList.remove('o-header__itemwrapper--small');
  };

  HeaderLinks.prototype.events = function () {
    var _that = this;

    document.addEventListener('DOMContentLoaded', function () {
      // wait for ViewportDetect to be added to dom
      if (_that.vp.getCurrentVp() === 'xs') {
        _that.addWrapper();
      }
    });
    window.addEventListener('resize', function () {
      _Utils_1.Utils.LegacyUtils.waitForFinalEvent(function () {
        if (_that.vp.getCurrentVp() === 'xs') {
          _that.addWrapper();
        } else {
          _that.removeWrapper();
        }
      }, 100, 'resizeHeaderLang');
    });
  };

  return HeaderLinks;
}();

exports.HeaderLinks = HeaderLinks;

},{"../../utils/_Utils":102}],82:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.Lang = void 0;

var Lang =
/** @class */
function () {
  function Lang() {
    this.header = document.getElementById('header');
    this.langBtn = this.header.querySelector('.m-header__lang__btn');
    this.search = document.querySelector('.m-searchbar__opener');
    this.menu = document.querySelector('.a-navigation__menu__item__label');

    if (this.langBtn) {
      this.nextLangBtn = this.header.querySelector('.m-header__lang__link');
    }

    this.langStateOpen = false;
  }

  Lang.prototype.init = function () {
    this.events();
  };

  Lang.prototype.events = function () {
    var that = this;

    if (this.langBtn) {
      this.langBtn.addEventListener('click', function () {
        that.toggle();
      });
      this.langBtn.addEventListener('keydown', function (e) {
        var isTab = e.which === 9 || e.key === 'Tab';
        var isEnter = e.which === 13 || e.key === 'Enter';
        var isSpace = e.which === 32 || e.key === 'Space';
        var nextBtn = this.nextElementSibling;

        if (isEnter || isSpace) {
          e.preventDefault();
          that.toggle();
        }

        if (isTab && !e.shiftKey) {
          if (nextBtn.classList.contains('opened')) {
            that.focusNext();
          }
        }

        if (isTab && e.shiftKey) {
          if (that.langStateOpen === true) {
            that.toggle();
          }

          that.focusSearch();
        }
      });
      this.nextLangBtn.addEventListener('keydown', function (e) {
        var isTab = e.which === 9 || e.key === 'Tab';

        if (isTab && !e.shiftKey) {
          if (this.classList.contains('opened')) {
            that.toggle();
            that.focusMenu();
          }
        }
      });
    }
  };

  Lang.prototype.toggle = function () {
    this.nextLangBtn.classList.toggle('opened');
    this.langStateOpen = this.langStateOpen === false ? true : false;

    if (this.langStateOpen === false) {
      this.langBtn.setAttribute('aria-expanded', 'false');
      this.langBtn.querySelector('svg').style.transform = 'rotate(0deg)';
    } else {
      this.langBtn.setAttribute('aria-expanded', 'true');
      this.langBtn.querySelector('svg').style.transform = 'rotate(180deg)';
    }
  };

  Lang.prototype.focusSearch = function () {
    var _that = this;

    setTimeout(function () {
      _that.nextLangBtn.classList.remove('is--focused');

      _that.search.focus();

      _that.search.classList.add('is--focused');
    }, 300);
  };

  Lang.prototype.focusMenu = function () {
    var _that = this;

    setTimeout(function () {
      _that.menu.focus();

      _that.menu.classList.add('is--focused');
    }, 300);
  };

  Lang.prototype.focusNext = function () {
    var _that = this;

    setTimeout(function () {
      _that.nextLangBtn.focus();

      _that.nextLangBtn.classList.add('is--focused');
    }, 300);
  };

  return Lang;
}();

exports.Lang = Lang;

},{}],83:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.Menu = void 0;

var _Utils_1 = require("../../utils/_Utils");

var Menu =
/** @class */
function () {
  function Menu(_header) {
    this.header = _header;

    if (this.header !== null && this.header !== undefined) {
      this.item = this.header.querySelectorAll('.a-navigation__menu__item');
      this.list = this.header.querySelector('.m-header__menu__list');
      this.itemOpened;
      this.stateOpened = false;
      this.hamburger = this.header.querySelector('.m-header__menu__hamburger');
      this.hamburgerStateOpen = false;
      this.focusables = '.o-metanavigation__trigger, .m-header__links__item, .a-navigation__menu__item__label, .a-navigation__menu__item__link, .m-header__menu__hamburger';
      this.isHomePage = new _Utils_1.Utils.PageUtils().IsHomePage();

      if (this.isHomePage === false) {
        this.focusables = this.focusables.concat(', .js-logo-type');
      }
    }
  }

  return Menu;
}();

exports.Menu = Menu;

},{"../../utils/_Utils":102}],84:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.Metanavigation = void 0;

var _Utils_1 = require("../../utils/_Utils");

var warnbanner_1 = require("../warnbanner");

var Metanavigation =
/** @class */
function () {
  function Metanavigation() {
    this.header = document.getElementById('header');
    this.metanav = this.header.querySelector('.o-metanavigation');
    this.metanavItemBoxList = this.header.querySelectorAll('.m-metanavigation__box');
    this.metanavBtnList = this.header.querySelectorAll('.js-metanavigation__box__btn');
    this.metanavItemList = this.header.querySelectorAll('.m-metanavigation__box__list > li > a');
    this.metanavTrigger = this.header.querySelector('.o-metanavigation__trigger');
    this.metanavClose = this.header.querySelector('.o-metanavigation__close');
    this.backBtnList = this.metanav.querySelectorAll('.m-header__panel__back');
    this.itemOpened = undefined;
    this.metanavOpened = false;
    this.submetanavOpened = false;
    this.WarnBanner = new warnbanner_1.WarnBanner();
  }

  Metanavigation.prototype.init = function () {
    this.events();
  };

  Metanavigation.prototype.events = function () {
    var that = this;
    var warbanner = document.querySelector('.o-warnbanner');
    this.metanavTrigger.addEventListener('click', function () {
      this.nextElementSibling.classList.add('opened');
      that.metanavOpened = true;
      document.querySelector('html').style.overflow = 'hidden';
      this.parentElement.setAttribute('aria-expanded', 'true');
      that.FocusBtnClose();

      if (document.body.contains(warbanner) && sessionStorage.getItem('lbp.warnbanner') === null) {
        that.WarnBanner.Close();
      }
    });
    this.metanavClose.addEventListener('click', function () {
      that.CloseMetanav();
      that.FocusBtnOpen();

      if (document.body.contains(warbanner) && sessionStorage.getItem('lbp.warnbanner') === null) {
        that.WarnBanner.Open();
      }
    });
    this.metanavItemBoxList.forEach(function (item) {
      item.addEventListener('click', function (e) {
        var htmltarget = e.target;
        var isChild = htmltarget.parentElement.isEqualNode(this);

        if (htmltarget.isEqualNode(this) || isChild) {
          e.preventDefault();
          var htmltarget_1 = item;
          that.OpenMenu(htmltarget_1);
        }
      });
    });
    this.backBtnList.forEach(function (item) {
      return item.addEventListener('click', function (e) {
        var htmltarget = e.target;

        if (htmltarget.isEqualNode(this)) {
          that.CloseMenu();
          that.submetanavOpened = false;
          that.setAccessibilityAttrs(that.metanavBtnList, that.submetanavOpened);
          var parent_1 = this.closest('.m-metanavigation__box').querySelector('button');
          setTimeout(function () {
            parent_1.classList.add('is--focused');
            parent_1.focus();
          }, 300);
        }
      });
    });
    this.metanavBtnList.forEach(function (item) {
      item.addEventListener('click', function (e) {
        var htmltarget = e.target;
        var nodesEqual = htmltarget.isEqualNode(this) || htmltarget.parentElement.isEqualNode(this);

        if (nodesEqual) {
          that.submetanavOpened = true;
          that.setAccessibilityAttrs(that.metanavBtnList, that.submetanavOpened);
          var backBtn_1 = htmltarget.parentElement.querySelector('.m-header__panel__back');
          setTimeout(function () {
            backBtn_1.classList.add('is--focused');
            backBtn_1.focus();
          }, 200);
        }
      });
    }); // Accessibility events

    this.metanavTrigger.addEventListener('keydown', function (e) {
      var htmltarget = e.target;
      var key = e;
      var isEnter = key.which === 13 || key.key === 'Enter';
      var isSpace = key.which === 32 || key.key === 'Space';

      if ((isSpace || isEnter) && htmltarget.isEqualNode(this)) {
        htmltarget.click();
      }
    });
    this.metanavClose.addEventListener('keydown', function (e) {
      var key = e;
      var isEnter = key.which === 13 || key.key === 'Enter';
      var isSpace = key.which === 32 || key.key === 'Space';
      var isTab = key.which === 9 || key.key === 'Tab';

      if (isEnter || isSpace) {
        that.CloseMetanav();
      }

      if (isTab && key.shiftKey || isTab) {
        e.preventDefault();
        var focusableSelectors = void 0;
        this.classList.remove('is--focused');

        if (isTab && !key.shiftKey) {
          var firstItem = that.metanavBtnList[0];
          firstItem.classList.add('is--focused');
        }

        if (that.submetanavOpened === false) {
          focusableSelectors = !_Utils_1.Utils.ViewportUtils.isDesktop() ? '.js-metanavigation__box__btn' : '.m-metanavigation__box__link, .o-metanavigation__close';
        } else {
          focusableSelectors = !_Utils_1.Utils.ViewportUtils.isDesktop() ? '.m-metanavigation__box.opened .m-header__panel__back, .m-metanavigation__box.opened .a-navigation__submenu__item > a' : '.m-metanavigation__box__link, .o-metanavigation__close';
        }

        new _Utils_1.Utils.FocusUtils({
          item: this.closest('.o-metanavigation'),
          event: e,
          focusableSelectors: focusableSelectors
        }).setFocus();
      }
    });
    this.metanavBtnList.forEach(function (item) {
      item.addEventListener('keydown', function (e) {
        var key = e;
        var htmltarget = e.target;
        var isTab = key.which === 9 || key.key === 'Tab';
        var isEnter = key.which === 13 || key.key === 'Enter';
        var isSpace = key.which === 32 || key.key === 'Space';
        var nodesEqual = htmltarget.isEqualNode(this) || htmltarget.parentElement.isEqualNode(this);

        if ((isSpace || isEnter) && nodesEqual) {
          this.click();
          that.submetanavOpened = false;
          that.setAccessibilityAttrs(that.metanavBtnList, that.submetanavOpened);
        }

        if (isTab && _Utils_1.Utils.ViewportUtils.isMobile() && nodesEqual) {
          new _Utils_1.Utils.FocusUtils({
            item: that.metanav,
            event: e,
            focusableSelectors: '.js-metanavigation__box__btn, .o-metanavigation__close'
          }).setFocus();
        }
      });
    });
    this.metanavItemList.forEach(function (item) {
      item.addEventListener('keydown', function (e) {
        var focusableSlectors;
        var parentItem;
        var key = e;
        var isTab = key.which === 9 || key.key === 'Tab';

        if (isTab) {
          if (_Utils_1.Utils.ViewportUtils.isDesktop()) {
            focusableSlectors = '.o-metanavigation a, .o-metanavigation__close';
            parentItem = that.metanav;
          } else {
            focusableSlectors = '.m-metanavigation__box.opened .a-navigation__submenu__item > a, .m-metanavigation__box.opened .m-header__panel__back, .o-metanavigation__close';
            parentItem = that.metanav;
          }

          new _Utils_1.Utils.FocusUtils({
            item: parentItem,
            event: e,
            focusableSelectors: focusableSlectors
          }).setFocus();
        }
      });
    });
    this.backBtnList.forEach(function (item) {
      item.addEventListener('keydown', function (e) {
        var key = e;
        var htmltarget = key.target;
        var isEnter = key.which === 13 || key.key === 'Enter';
        var isSpace = key.which === 32 || key.key === 'Space';

        if ((isEnter || isSpace) && htmltarget.isEqualNode(this)) {
          e.preventDefault();
          that.submetanavOpened = false;
          that.setAccessibilityAttrs(that.metanavBtnList, that.submetanavOpened);
          that.CloseMenu();
        }
      });
    });
    document.addEventListener('keydown', function (e) {
      var key = e;
      var isEscape = key.key === 'Escape' || key.key === 'Esc' || key.keyCode === 27;

      if (isEscape && that.metanavOpened === true) {
        that.CloseMetanav();
        that.FocusBtnOpen();
      }
    });
  };

  Metanavigation.prototype.CloseMetanav = function () {
    this.metanav.querySelector('.o-metanavigation__panel').classList.remove('opened');
    document.querySelector('html').style.overflow = 'auto';
    this.metanav.setAttribute('aria-expanded', 'false');
    this.metanavOpened = false;

    if (this.itemOpened !== undefined) {
      this.CloseMenu();
      this.submetanavOpened = false;
    }
  };

  Metanavigation.prototype.OpenMenu = function (item) {
    item.classList.add('opened');
    this.itemOpened = item;
    item.querySelector('.js-metanavigation__box__btn').setAttribute('aria-expanded', 'true');
  };

  Metanavigation.prototype.CloseMenu = function () {
    this.itemOpened.classList.remove('opened');
    this.itemOpened.querySelector('.js-metanavigation__box__btn').setAttribute('aria-expanded', 'false');
    this.itemOpened = undefined;
  };

  Metanavigation.prototype.FocusBtnClose = function () {
    var that = this;
    setTimeout(function () {
      that.metanavClose.focus();
      that.metanavClose.classList.add('is--focused');
    }, 300);
  };

  Metanavigation.prototype.FocusBtnOpen = function () {
    var that = this;
    setTimeout(function () {
      that.metanavTrigger.focus();
      that.metanavTrigger.classList.add('is--focused');
    }, 300);
  };

  Metanavigation.prototype.setAccessibilityAttrs = function (list, status) {
    list.forEach(function (item) {
      var el = item;

      if (status === true) {
        new _Utils_1.Utils.AttributesUtils({
          el: el,
          attrs: {
            'aria-hidden': status,
            'tabindex': '-1'
          }
        }).setAttributes();
      } else {
        el.removeAttribute('tabindex');
      }
    });
  };

  return Metanavigation;
}();

exports.Metanavigation = Metanavigation;

},{"../../utils/_Utils":102,"../warnbanner":100}],85:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.SubList = void 0;

var _Utils_1 = require("../../utils/_Utils");

var SubList =
/** @class */
function () {
  function SubList() {
    this.header = document.getElementById('header');

    if (this.header !== null) {
      this.panel = document.querySelectorAll('.m-header__sublist');
      this.item = this.header.querySelectorAll('.a-navigation__sublist__item');
      this.itemOpened;
      this.stateOpened = false;
      this.focusables = '.m-header__menu__hamburger, .o-metanavigation__trigger, .m-header__links__item, .a-navigation__submenu__item.opened .m-header__panel__back.sublist, .a-navigation__submenu__item.opened .a-navigation__sublist__item a';
      this.isHomePage = new _Utils_1.Utils.PageUtils().IsHomePage();

      if (this.isHomePage === false) {
        this.focusables = this.focusables.concat(', .js-logo-type');
      }
    }
  }

  return SubList;
}();

exports.SubList = SubList;

},{"../../utils/_Utils":102}],86:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.SubMenu = void 0;

var _Utils_1 = require("../../utils/_Utils");

var SubMenu =
/** @class */
function () {
  function SubMenu() {
    this.header = document.getElementById('header');

    if (this.header !== null) {
      this.menu = document.getElementById('headermenu');
      this.item = this.menu.querySelectorAll('.a-navigation__submenu__item');
      this.titles = this.header.querySelectorAll('.m-header__submenu__title');
      this.pushLink = this.menu.querySelectorAll('.m-header__submenu__push a');
      this.assistanceLink = this.menu.querySelectorAll('.m-header__submenu__card');
      this.itemOpened;
      this.stateOpened = false;
      this.focusables = '.o-metanavigation__trigger, .m-header__links__item, li.opened .m-header__panel__back.submenu, li.opened .a-navigation__submenu__item__label, li.opened .a-navigation__submenu__item__link , m-header__menu__hamburger, li.opened .m-header__submenu__card, li.opened .m-header__submenu__push a';

      if (this.isHomePage === false) {
        this.focusables.concat('.js-logo-type');
      }

      this.events();
    }
  }

  SubMenu.prototype.events = function () {
    var that = this;
    this.pushLink.forEach(function (item) {
      item.addEventListener('keydown', function (e) {
        var htmlTarget = e.target;
        var keybordEvent = e;
        var isTab = keybordEvent.which === 9 || keybordEvent.key === 'Tab';

        if (htmlTarget.isEqualNode(this) && isTab) {
          if ((_Utils_1.Utils.ViewportUtils.isMobile() || _Utils_1.Utils.ViewportUtils.isTablet()) && isTab) {
            new _Utils_1.Utils.FocusUtils({
              item: that.header,
              event: keybordEvent,
              focusableSelectors: that.focusables
            }).setFocus();
          }
        }
      });
    });
    this.assistanceLink.forEach(function (item) {
      item.addEventListener('keydown', function (e) {
        var htmlTarget = e.target;
        var keybordEvent = e;
        var isTab = keybordEvent.which === 9 || keybordEvent.key === 'Tab';

        if (htmlTarget.isEqualNode(this) || htmlTarget.closest('a').isEqualNode(this) && isTab) {
          if (_Utils_1.Utils.ViewportUtils.isDesktop() && isTab) {
            console.log('test');
          }

          if ((_Utils_1.Utils.ViewportUtils.isMobile() || _Utils_1.Utils.ViewportUtils.isTablet()) && isTab) {
            new _Utils_1.Utils.FocusUtils({
              item: that.header,
              event: keybordEvent,
              focusableSelectors: that.focusables
            }).setFocus();
          }
        }
      });
    });
  };

  return SubMenu;
}();

exports.SubMenu = SubMenu;

},{"../../utils/_Utils":102}],87:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.IframeResizer = void 0;

var IframeResizer =
/** @class */
function () {
  function IframeResizer() {
    this.iframeAttribute = document.querySelectorAll('iframe[data-fluid-iframe]');
    this.options = {
      checkOrigin: false
    };
  }

  IframeResizer.prototype.init = function () {
    var _that = this;

    this.iframeAttribute.forEach(function (element) {
      var item = element;
      var manualHeight = item.getAttribute('data-height');

      if (!manualHeight) {
        iFrameResize355(_that.options, element);
      }
    });
  };

  return IframeResizer;
}();

exports.IframeResizer = IframeResizer;

},{}],88:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.OptinButton = void 0;

var eventUtils_1 = require("../utils/eventUtils");

var OptinButton =
/** @class */
function () {
  function OptinButton() {
    this.config = {
      enableTitleAttr: 'data-aria-label'
    };
  }

  OptinButton.prototype.init = function () {
    this.setAllDisabled();
    this.events();
  };

  OptinButton.prototype.events = function () {
    var _that = this;

    eventUtils_1.EventUtils.setDocEvent('input', '.o-optin .a-checkbox input', function (target) {
      _that.toggle(target);
    });
    eventUtils_1.EventUtils.setDocEvent('click', '.o-optin a[href]', function (target, event) {
      //if button is disable, prevent his click
      if (target.getAttribute('aria-disabled') === 'true') {
        event.preventDefault();
      }
    });
  };
  /** toogle
   *  Store link title and remplace it with disable title
   * @param {HTMLInputElement} checkbox
   */


  OptinButton.prototype.toggle = function (checkbox) {
    //if checked disable, else enable
    if (checkbox.checked) {
      this.enable(checkbox.closest('.o-optin'));
    } else {
      this.disable(checkbox.closest('.o-optin'));
    }
  };
  /** enable
   *
   * @param {HTMLElement} parent optin element
   */


  OptinButton.prototype.enable = function (parent) {
    var _button = parent.querySelector('.m-button a[href]');

    if (_button !== null) {
      _button.removeAttribute('aria-disabled');

      _button.removeAttribute('aria-label');
    }
  };
  /** disable
   *
   * @param {HTMLElement} parent optin element
   */


  OptinButton.prototype.disable = function (parent) {
    var _button = parent.querySelector('.m-button a[href]');

    if (_button !== null) {
      var _disableTitle = _button.getAttribute(this.config.enableTitleAttr);

      _button.setAttribute('aria-disabled', 'true');

      _button.setAttribute('aria-label', _disableTitle);
    }
  };
  /** setAllDisableLabels
   *  Set all disable label on page load
   */


  OptinButton.prototype.setAllDisabled = function () {
    var _that = this,
        optinList = document.querySelectorAll('.o-optin');

    optinList.forEach(function (optin) {
      _that.disable(optin);
    });
  };

  return OptinButton;
}();

exports.OptinButton = OptinButton;

},{"../utils/eventUtils":109}],89:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.PrivacyConsent = void 0;

var _Utils_1 = require("../utils/_Utils");

var PrivacyConsent =
/** @class */
function () {
  function PrivacyConsent() {
    this.checkboxes = document.querySelectorAll('[data-privacy-consent]');
    this.cookieValues = ['optin', 'exempt'];
  }

  PrivacyConsent.prototype.init = function () {
    this.events();
  };

  PrivacyConsent.prototype.events = function () {
    var _that = this;

    _that.checkboxes.forEach(function (element) {
      element.addEventListener('click', function (e) {
        var input = e.target;
        var inputValue = input.checked;

        if (inputValue === true) {
          tc_events_global(this, 'at_optin', {});
        } else {
          tc_events_global(this, 'at_optout', {});
        }
      });
    });

    document.addEventListener('DOMContentLoaded', function () {
      _that.checkboxes.forEach(function (element) {
        var input = element;

        var tcCookie = _Utils_1.Utils.Cookie.getCookie('tc_at_cm');

        if (tcCookie === undefined || _that.cookieValues.find(function (element) {
          return element.indexOf(tcCookie) > -1;
        })) {
          _that.check(input);
        } else if (tcCookie === 'optout') {
          _that.unCheck(input);
        }
      });
    });
  };

  PrivacyConsent.prototype.check = function (input) {
    input.checked = true;
  };

  PrivacyConsent.prototype.unCheck = function (input) {
    input.checked = false;
  };

  return PrivacyConsent;
}();

exports.PrivacyConsent = PrivacyConsent;

},{"../utils/_Utils":102}],90:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.Search = void 0;

var searchHeader_1 = require("./searchHeader");

var searchInput_1 = require("./searchInput");

var searchResult_1 = require("./searchResult");

var searchHero_1 = require("./searchHero");

var searchBar_1 = require("./searchBar");

var Search =
/** @class */
function () {
  function Search() {
    this.config = {
      inputSelector: '[data-lbp-search-input]',
      resultSelector: '[data-lbp-search-result]',
      storageKey: 'LBP-SEARCH'
    };
    this.header = document.getElementById('header');
    this.searchBar = document.querySelector('.o-searchbar');
    this.hero = document.querySelector('.js-herobanner__searchpage');

    if (this.header !== null && this.header !== undefined) {
      var wrapper = this.header.querySelector('.m-searchbar');
      this.searchHeader = new searchHeader_1.SearchHeader(wrapper, this);
      this.searchInputHeader = new searchInput_1.SearchInput(wrapper, this);
    }

    if (this.hero !== null && this.hero !== undefined) {
      var herowrapper = this.hero.querySelector('.m-searchbar__form');
      this.searchHero = new searchHero_1.SearchHero(herowrapper, this);
    }

    if (this.searchBar !== null && this.searchBar !== undefined) {
      var searchbarWrapper = this.searchBar.querySelector('.m-searchbar__form');
      this.searchBarObj = new searchBar_1.SearchBar(searchbarWrapper, this);
    } //if is page result && local storage


    if (document.querySelector(this.config.resultSelector) !== null) {
      this.searchResult = new searchResult_1.SearchResult(this);
      this.searchResult.readStoredSearchValue();
      this.searchResult.populateSearchFields();
    }
  }

  return Search;
}();

exports.Search = Search;

},{"./searchBar":91,"./searchHeader":92,"./searchHero":93,"./searchInput":94,"./searchResult":95}],91:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.SearchBar = void 0;

var SearchBar =
/** @class */
function () {
  function SearchBar(_searchWrapper, _parent) {
    this.parent = _parent;
    this.searchWrapper = _searchWrapper;
    this.searchInput = this.searchWrapper.querySelector('.m-searchbar__input');
    this.searchSubmit = this.searchWrapper.querySelector('.m-searchbar__submit');
    this.events();
  }

  SearchBar.prototype.events = function () {
    var that = this;
    this.searchSubmit.addEventListener('click', function (e) {
      e.preventDefault();
      that.search();
    });
  };

  SearchBar.prototype.search = function () {
    this.parent.searchInputHeader.search(this.searchInput.value);
  };

  return SearchBar;
}();

exports.SearchBar = SearchBar;

},{}],92:[function(require,module,exports){
"use strict";

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

exports.__esModule = true;
exports.SearchHeader = void 0;

var _Utils_1 = require("../../utils/_Utils");

var SearchHeader =
/** @class */
function () {
  function SearchHeader(_searchWrapper, _parent) {
    this.parent = _parent;
    this.searchWrapper = _searchWrapper;

    if (_searchWrapper === null) {
      return;
    }

    this.searchOpen = this.searchWrapper.querySelector('.m-searchbar__opener');
    this.searchClose = this.searchWrapper.querySelector('.m-searchbar__close__wrapper');
    this.searchForm = this.searchWrapper.nextElementSibling;
    this.searchInput = this.searchWrapper.nextElementSibling.querySelector('.m-searchbar__input');
    this.searchSubmit = this.searchWrapper.nextElementSibling.querySelector('.m-searchbar__submit');
    this.menu = document.getElementById('headermenu');
    this.closeIcon = '';
    this.isOpen = false;
    this.events();
  }

  SearchHeader.prototype.events = function () {
    var that = this;
    this.searchClose.addEventListener('click', function (e) {
      e.preventDefault();
      that.close();

      if (_Utils_1.Utils.ViewportUtils.isMobile()) {
        document.querySelector('html').style.overflow = 'auto';
      }
    });
    this.searchClose.addEventListener('keydown', function (e) {
      e.preventDefault();
      var isTab = e.which === 9 || e.key === 'Tab';
      var isEnter = e.which === 13 || e.key === 'Enter';
      var space = e.which === 32;

      if (isEnter || space) {
        that.close();
      }

      if (e.shiftKey && isTab) {
        that.searchSubmit.focus();
      } // TAB


      if (!e.shiftKey && isTab) {
        that.close();
        this.classList.remove('is--focused');
        var nextParent = that.searchWrapper.nextElementSibling;
        var nextChild = nextParent.querySelector('.m-header__links__item');
        nextChild.focus();
      }
    });
    this.searchSubmit.addEventListener('click', function (e) {
      e.preventDefault();
      that.search();
    });
    this.searchSubmit.addEventListener('keydown', function (e) {
      e.preventDefault();
      var isTab = e.which === 9 || e.key === 'Tab';
      var isEnter = e.which === 13 || e.key === 'Enter';
      var space = e.which === 32;

      if (isEnter || space) {
        e.preventDefault();
        that.search();
      }

      if (!e.shiftKey && isTab) {
        that.searchClose.focus();
      } else if (e.shiftKey && isTab) {
        that.searchInput.focus();
      }
    });
  };

  SearchHeader.prototype.search = function () {
    this.parent.searchInputHeader.search(this.searchInput.value);
  };

  SearchHeader.prototype.open = function (_search) {
    var _this = this;

    var ua = detect.parse(navigator.userAgent);
    var that = this;

    if (!_Utils_1.Utils.ViewportUtils.isMobile()) {
      var iconChange = function iconChange() {
        return __awaiter(_this, void 0, void 0, function () {
          return __generator(this, function (_a) {
            switch (_a.label) {
              case 0:
                this.searchOpen.classList.add('hidden');
                this.searchClose.classList.add('visible');
                return [4
                /*yield*/
                , new _Utils_1.Utils.PromiseUtils({
                  item: that.searchClose
                }).onceAnimationEnd()];

              case 1:
                _a.sent();

                return [2
                /*return*/
                ];
            }
          });
        });
      };

      var moveOverlay = function moveOverlay() {
        return __awaiter(_this, void 0, void 0, function () {
          return __generator(this, function (_a) {
            switch (_a.label) {
              case 0:
                this.searchWrapper.classList.add('opened');
                this.searchForm.querySelector('.m-searchbar__form__overlay').classList.add('moved');
                this.menu.classList.add('collapse');
                return [4
                /*yield*/
                , new _Utils_1.Utils.PromiseUtils({
                  item: that.searchForm.querySelector('.m-searchbar__form__overlay')
                }).onceAnimationEnd()];

              case 1:
                _a.sent();

                return [2
                /*return*/
                ];
            }
          });
        });
      };

      var displayItems = function displayItems() {
        return __awaiter(_this, void 0, void 0, function () {
          return __generator(this, function (_a) {
            this.searchForm.classList.add('visible');
            this.searchInput.classList.add('displayed');

            if (_Utils_1.Utils.ViewportUtils.isDesktop() || _Utils_1.Utils.ViewportUtils.isTablet()) {
              this.menu.querySelector('nav').style.visibility = 'hidden';
            }

            setTimeout(function () {
              that.searchInput.focus();
            }, 400);
            return [2
            /*return*/
            ];
          });
        });
      };

      if (ua.browser.family !== 'IE') {
        iconChange().then(moveOverlay).then(displayItems);
      } else {
        iconChange();
        moveOverlay();
        displayItems();
      }
    } else {
      this.searchWrapper.classList.add('opened');
      this.searchForm.classList.add('visible');
      setTimeout(function () {
        that.searchInput.focus();
      }, 400);
    }

    this.isOpen = true;

    if (_Utils_1.Utils.ViewportUtils.isMobile()) {
      var breadcrumb = document.querySelector('.m-breadcrumb');
      document.querySelector('main').style.visibility = 'hidden';
      document.querySelector('footer').style.visibility = 'hidden';
      breadcrumb.style.visibility = 'hidden';
    }
  };

  SearchHeader.prototype.close = function () {
    var _this = this;

    if (!_Utils_1.Utils.ViewportUtils.isMobile()) {
      this.searchForm.querySelector('.m-searchbar__form__overlay').classList.remove('moved');
      this.menu.classList.remove('collapse');

      var hideClose_1 = function hideClose_1() {
        return __awaiter(_this, void 0, void 0, function () {
          return __generator(this, function (_a) {
            switch (_a.label) {
              case 0:
                this.searchClose.classList.remove('visible');
                return [4
                /*yield*/
                , new _Utils_1.Utils.PromiseUtils({
                  item: this.searchClose
                }).onceAnimationEnd()];

              case 1:
                _a.sent();

                return [2
                /*return*/
                ];
            }
          });
        });
      };

      var showSearchOPen = function showSearchOPen() {
        return __awaiter(_this, void 0, void 0, function () {
          return __generator(this, function (_a) {
            switch (_a.label) {
              case 0:
                return [4
                /*yield*/
                , hideClose_1()];

              case 1:
                _a.sent();

                this.searchOpen.classList.remove('hidden');
                this.unfocus();
                return [2
                /*return*/
                ];
            }
          });
        });
      };

      showSearchOPen();
      this.searchWrapper.classList.remove('open');
      this.searchInput.classList.remove('displayed');
    }

    this.searchWrapper.classList.remove('opened');
    this.searchForm.classList.remove('visible');
    this.isOpen = false;

    if (_Utils_1.Utils.ViewportUtils.isDesktop() || _Utils_1.Utils.ViewportUtils.isTablet()) {
      this.menu.querySelector('nav').style.visibility = 'visible';
    } else {
      var breadcrumb = document.querySelector('.m-breadcrumb');
      document.querySelector('main').style.visibility = 'visible';
      document.querySelector('footer').style.visibility = 'visible';
      breadcrumb.style.visibility = 'visible';
    }
  };

  SearchHeader.prototype.unfocus = function () {
    this.searchClose.blur();
    var that = this; // setTimeout is firefox fix

    setTimeout(function () {
      that.searchOpen.classList.add('is--focused');
      that.searchOpen.focus();
    }, 200);
  };

  return SearchHeader;
}();

exports.SearchHeader = SearchHeader;

},{"../../utils/_Utils":102}],93:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.SearchHero = void 0;

var SearchHero =
/** @class */
function () {
  function SearchHero(_searchWrapper, _parent) {
    this.parent = _parent;
    this.searchWrapper = _searchWrapper;
    this.searchInput = this.searchWrapper.querySelector('.m-searchbar__input');
    this.searchSubmit = this.searchWrapper.querySelector('.m-searchbar__submit');
    this.events();
  }

  SearchHero.prototype.events = function () {
    var that = this;
    this.searchSubmit.addEventListener('click', function (e) {
      e.preventDefault();
      that.search();
    });
  };

  SearchHero.prototype.search = function () {
    this.parent.searchInputHeader.search(this.searchInput.value);
  };

  return SearchHero;
}();

exports.SearchHero = SearchHero;

},{}],94:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.SearchInput = void 0;

var SearchInput =
/** @class */
function () {
  function SearchInput(_searchWrapper, _parent) {
    this.parent = _parent;
    this.searchWrapper = _searchWrapper;

    if (_searchWrapper === null) {
      return;
    }

    this.searchInput = this.searchWrapper.nextElementSibling.querySelector(this.parent.config.inputSelector);
    this.profile = this.searchInput.getAttribute('data-profile');

    if (this.searchInput === null) {
      return;
    }

    this.searchUrl = this.searchInput.getAttribute('data-lbp-search-input');
    this.events();
  }

  SearchInput.prototype.events = function () {
    var _that = this;

    this.searchInput.addEventListener('keydown', function (e) {
      var isTab = e.which === 9 || e.key === 'Tab';
      var isEnter = e.which === 13 || e.key === 'Enter';
      var isEscape = e.which === 27 || e.key === 'Escape'; // ESCAPE
      // if (isEscape) {
      //     _that.closeAutoComplete();
      // }
      // ENTER

      if (isEnter) {
        _that.search(this.value);
      } //auto complete
      // if (!isEnter && !isTab && !isEscape) {
      //     _that.openAutoComplete(this.value);
      // }


      if (e.shiftKey && isTab) {
        _that.parent.searchHeader.close();
      }
    });
    document.addEventListener('DOMContentLoaded', function (event) {
      if (_that.parent.searchResult !== undefined) {
        _that.parent.searchResult.readStoredSearchValue();

        _that.parent.searchResult.populateSearchFields();
      }
    });
  };
  /**
   * Search value
   * @param {String} _value
   */


  SearchInput.prototype.search = function (_value) {
    if (_value !== undefined && _value !== '') {
      this.setSearchValue(_value);

      if (this.isCleanSearch(this.searchValue)) {
        this.storeSearchValue();
        this.redirectToResult();
      }
    }
  };
  /**
   * Redirect to result page
   */


  SearchInput.prototype.redirectToResult = function () {
    if (this.searchValue !== undefined && this.searchValue !== '') {
      window.location.href = this.searchUrl + this.getUrlParam();
    }
  };
  /**
   * return Search parameter in URl
   */


  SearchInput.prototype.getUrlParam = function () {
    if (this.searchValue !== null && this.searchValue !== undefined && this.profile === undefined && this.profile === null) {
      return '?q=' + this.searchValue;
    } else if (this.searchValue !== null && this.searchValue !== undefined && this.profile !== undefined && this.profile !== null) {
      return '?q=' + this.searchValue + '&profil=' + this.profile;
    } else {
      return '';
    }
  };
  /**
   * Open Autocomplete on input
   * @param {String} _value
   */


  SearchInput.prototype.openAutoComplete = function (_value) {
    //TODO
    throw new Error('Method openAutoComplete not implemented.');
  };
  /**
   * close Autocomplete
   */


  SearchInput.prototype.closeAutoComplete = function () {
    //TODO
    throw new Error('Method closeAutoComplete not implemented.');
  };
  /**
   * set search term from search input
   * @param {String} _value
   */


  SearchInput.prototype.setSearchValue = function (_value) {
    this.searchValue = _value;
  };
  /**
   * Store searchValue into local storage
   */


  SearchInput.prototype.storeSearchValue = function () {
    var jsonSearch = {
      searchValue: this.searchValue,
      profilValue: this.profile
    };
    localStorage.setItem(this.parent.config.storageKey, JSON.stringify(jsonSearch));
  };
  /**
   * Return true if search term cleared  for credit card, phone, client ref, mail
   * @param {String} _searchValue
   */


  SearchInput.prototype.isCleanSearch = function (_searchValue) {
    var _cleared = true;
    var creditCardRegExp = /(?:[0-9]{4}\s?){4}/g,
        phoneRegExp = /(\+?(00\s?)?33|0)(\s|\.|-|\/)?[0-9]((\s|\.|-|\/)?\d{2,3}){3,4}/g,
        refRegExp = /[0-9]{2,4}(\s|-)?((\s|-)?\d){3,9}(\w)*/g,
        mailRegExp = /[A-Z0-9._%+-]+\s?@[A-Z0-9.\s._%+-]+\.[A-Z0-9.]{2,12}/gi; // clear credit card number, phone number, clear client ref (id, password, account number, postal code) then clear email

    if (_searchValue.match(mailRegExp) !== null || _searchValue.match(creditCardRegExp) !== null || _searchValue.match(phoneRegExp) !== null || _searchValue.match(refRegExp) !== null) {
      _cleared = false;
    }

    return _cleared;
  };

  return SearchInput;
}();

exports.SearchInput = SearchInput;

},{}],95:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.SearchResult = void 0;

var SearchResult =
/** @class */
function () {
  function SearchResult(_parent) {
    this.parent = _parent;
    this.searchResultElement = document.querySelector(this.parent.config.resultSelector);
  }
  /**
   * Get searchValue from local storage
   */


  SearchResult.prototype.readStoredSearchValue = function () {
    var retrievedObject = localStorage.getItem(this.parent.config.storageKey);
    var url = window.location.search;
    var searchParam = url.match('(?!q=)[A-Z][a-z0-9]([^&]*)');
    var keyword;

    if (searchParam !== null) {
      keyword = searchParam[0];
    }

    if (retrievedObject !== null) {
      this.searchValue = JSON.parse(retrievedObject).searchValue;
      this.profilValue = JSON.parse(retrievedObject).profilValue; //remove search terme from local storage

      localStorage.removeItem(this.parent.config.storageKey); //if localstorage empty check url param keyword
    } else if (keyword !== null) {
      this.searchValue = keyword;
    }
  };
  /**
   * insert searchValue into search fields (header / herobanner)
   */


  SearchResult.prototype.populateSearchFields = function () {
    var _that = this;

    var InputList = document.querySelectorAll(this.parent.config.inputSelector);

    if (_that.searchValue !== undefined && _that.searchValue !== '') {
      //populate input field with search value
      InputList.forEach(function (field) {
        field.value = decodeURIComponent((_that.searchValue + '').replace(/\+/g, '%20'));
      }); //populate url with search parameter

      if (_that.profilValue === null) {
        window.history.pushState('', '', '?q=' + _that.searchValue);
      } else {
        window.history.pushState('', '', '?q=' + _that.searchValue + '&profil=' + _that.profilValue);
      } //TODO test if url has other parameters

    }
  };

  return SearchResult;
}();

exports.SearchResult = SearchResult;

},{}],96:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.Summary = void 0;

var _Utils_1 = require("../utils/_Utils");

var Summary =
/** @class */
function () {
  function Summary() {
    this.summary = document.getElementById('summary');

    if (this.summary !== undefined && this.summary !== null) {
      this.items = this.summary.querySelectorAll('.m-summary__list__item');
      this.sticky = false;
      this.sumPos = this.summary.getBoundingClientRect().top + window.scrollY;
      this.progressBar = this.summary.querySelector('.m-summary__scrollbar__thumb');
      this.anchors = [];
    }
  }

  Summary.prototype.init = function () {
    if (this.summary !== undefined && this.summary !== null && this.items.length > 0) {
      this.events();
      this.getAnchors();
      this.setPercentage();
    }
  };

  Summary.prototype.events = function () {
    var _that = this;

    this.items.forEach(function (item) {
      item.addEventListener('click', function (e) {
        e.preventDefault();
        var htmlTarget = e.target;
        new _Utils_1.Utils.ScrollUtils({
          el: _that.getAnchor(htmlTarget)
        }).scrollTo();

        _that.progress(htmlTarget);
      });
    });
    var lastScrollTop = 0;
    window.addEventListener('scroll', function (e) {
      var st = window.pageYOffset || document.documentElement.scrollTop;
      var scrollDirection = 'down'; //scroll DOWN

      if (st > lastScrollTop) {
        scrollDirection = 'down'; //scroll UP
      } else {
        scrollDirection = 'up';
      }

      if (st > _that.sumPos) {
        if (_that.sticky === false) {
          _that.summary.classList.add('m-summary--sticky');

          _that.sticky = true;
        }
      } else {
        _that.summary.classList.remove('m-summary--sticky');

        _that.sticky = false;
      }

      _that.checkItemsInWindow(scrollDirection, st); //update scroll position


      lastScrollTop = st <= 0 ? 0 : st;
    });
  }; // Set percentage postion for progressbar


  Summary.prototype.setPercentage = function () {
    this.items.forEach(function (item) {
      var htmlTarget = item;
      var pos = htmlTarget.getBoundingClientRect().right;
      var width = htmlTarget.clientWidth;
      var center = pos - width / 2;
      var windowW = window.innerWidth;
      var percent = center / windowW * 100;
      var link = htmlTarget.querySelector('a');

      if (link.getAttribute('data-percent') === null) {
        link.setAttribute('data-percent', percent.toString());
      }
    });
  };

  Summary.prototype.getAnchor = function (el) {
    var href = el.getAttribute('href');
    var anchorid = href.split('#')[1];
    var anchor = document.querySelector('[id="' + anchorid + '"]');
    return anchor;
  };

  Summary.prototype.getSummaryItem = function (el) {
    var id = el.getAttribute('id');
    var item = document.querySelector('[href=#"' + id + '"]');
    return item;
  };

  Summary.prototype.getAnchors = function () {
    var _that = this;

    this.items.forEach(function (item) {
      var htmlTarget = item;
      var link = htmlTarget.querySelector('a');

      _that.anchors.push(_that.getAnchor(link));
    });
  };

  Summary.prototype.checkItemsInWindow = function (direction, position) {
    var _that = this;

    this.anchors.forEach(function (item, index) {
      var id = item.getAttribute('id');

      if (_that.visibleOnScreen(item)) {
        var summaryItem = document.querySelector('a[href="#' + id + '"]');

        _that.progress(summaryItem);

        if (direction === 'down') {
          if (!_Utils_1.Utils.ViewportUtils.isDesktop()) {
            _that.getSlide(id, direction);
          }
        } else {
          if (!_Utils_1.Utils.ViewportUtils.isDesktop()) {
            _that.getSlide(id, direction);
          }
        }
      }

      if (position === 0) {
        _that.progress(document.querySelector('.o-header'));
      }
    });
  };

  Summary.prototype.visibleOnScreen = function (el) {
    var windowHeight = window.screen.height;
    var docViewTop = window.pageYOffset + windowHeight * 0.07;
    var docViewBottom = window.pageYOffset + windowHeight * 0.7;
    var elemTop = el.getBoundingClientRect().top + window.scrollY;
    return elemTop > docViewTop && elemTop < docViewBottom;
  }; // Get carousel slide on mobile/tablet on scroll


  Summary.prototype.getSlide = function (id, direction) {
    //Use jQuery because of owl-carousel jquery dependency
    var owl = $(this.summary).find('.owl-carousel');
    var inActiveSlide = owl.find('.owl-item').not('.active');
    var isInSlide = $(inActiveSlide).find('a[href="#' + id + '"]');

    if (isInSlide.length > 0) {
      owl.owlCarousel();
      direction === 'down' ? owl.trigger('next.owl.carousel') : owl.trigger('prev.owl.carousel');
    }
  }; // Set progress bar progression


  Summary.prototype.progress = function (el) {
    this.progressBar.style.width = el.getAttribute('data-percent') + '%';
  };

  return Summary;
}();

exports.Summary = Summary;

},{"../utils/_Utils":102}],97:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.Table = void 0;

var _Utils_1 = require("../utils/_Utils");

var Table =
/** @class */
function () {
  function Table() {
    this.item = document.querySelectorAll('.o-table');
    this.isOpc = false;
    this.scrollBarOPtions = {
      className: 'a-scrollbar--table',
      clipAlways: true,
      nativeScrollbarsOverlaid: {
        showNativeScrollbars: false,
        initialize: true
      },
      overflowBehavior: {
        x: 'scroll',
        y: 'hidden'
      },
      scrollbars: {
        visibility: 'auto',
        autoHide: 'never',
        autoHideDelay: 800,
        dragScrolling: true,
        clickScrolling: true,
        touchSupport: true,
        snapHandle: false
      },
      textarea: {
        dynWidth: false,
        dynHeight: false,
        inheritedAttrs: ['style', 'class']
      }
    };
  }

  Table.prototype.init = function () {
    if (this.item.length > 0) {
      this.events();
    }
  };

  Table.prototype.events = function () {
    var _that = this;

    document.addEventListener('DOMContentLoaded', function () {
      _that.item.forEach(function (element) {
        var table = element;
        var isSticky = table.getAttribute('is-sticky-table');
        var overlay = table.querySelector('.o-table__overlay');
        _that.isOpc = table.classList.contains('o-table--opc');

        var session = _that.getSessionStorageItem(table);

        _that.checkTableHeaders(table);

        _that.checkScrollableTable(table, session, isSticky, _that.isOpc);

        if (overlay !== undefined && overlay !== null) {
          overlay.addEventListener('click', function () {
            var style = getComputedStyle(this);

            if (style.display === 'flex') {
              var sessionId = 'lbp.tablesticky'.concat(table.getAttribute('id'));

              _that.allowStickyTable(table, sessionId, overlay, isSticky);
            }
          });
          overlay.addEventListener('keydown', function (e) {
            var isEnter = e.which === 32 || e.key === 'Enter';

            if (isEnter) {
              this.click();
            }
          });
        }

        window.addEventListener('resize', function () {
          _that.checkScrollableTable(table, session, isSticky, _that.isOpc);
        });
      });
    });
  };

  Table.prototype.getSessionStorageItem = function (el) {
    var itemId = el.getAttribute('id');
    var sessionId = 'lbp.tablesticky'.concat(itemId);
    return sessionStorage.getItem(sessionId);
  };

  Table.prototype.checkTableHeaders = function (el) {
    var firstRow = el.querySelector('tr:first-child');
    var isHead = firstRow.querySelector('[scope]');
    var rowHeight = firstRow.clientHeight.toString();
    var overlay = el.querySelector('.o-table__overlay');

    if (isHead && overlay !== null) {
      overlay.classList.add('o-table__overlay--col');
      overlay.style.top = rowHeight.concat('px');
    }
  };

  Table.prototype.allowStickyTable = function (el, id, overlay, sticky) {
    sessionStorage.setItem(id, '1');
    var session = sessionStorage.getItem(id);
    var links = el.querySelectorAll('a[href]');
    var table = el.querySelector('table');
    this.isOpc = table.classList.contains('o-table--opc');
    overlay.style.display = 'none';
    el.classList.remove('o-table--sticky--blocked');
    table.removeAttribute('aria-hidden');
    table.setAttribute('tabindex', '-1');
    setTimeout(function () {
      table.focus();
    }, 500);
    this.checkScrollableTable(el, session, sticky, this.isOpc);
    links.forEach(function (element) {
      var item = element;
      item.removeAttribute('tabindex');
    });
  };

  Table.prototype.checkScrollableTable = function (el, session, sticky, isOpc) {
    var width = el.querySelector('table').clientWidth;
    var links = el.querySelectorAll('a[href]');
    var parentWidth = el.clientWidth;

    if (isOpc === true && _Utils_1.Utils.ViewportUtils.isMobile()) {
      return;
    }

    if (width > parentWidth) {
      // Overlay is still visible
      if (session !== '1') {
        el.classList.add('o-table--sticky--blocked');
        el.querySelector('table').setAttribute('aria-hidden', 'true');
        links.forEach(function (element) {
          var item = element;
          item.setAttribute('tabindex', '-1');
        });
      } else {
        el.classList.add('o-table--scrollable');
        OverlayScrollbars(el, this.scrollBarOPtions);
      }

      if (sticky === 'true') {
        el.classList.add('o-table--sticky'); // Overlay is still visible

        if (session === '1') {
          var instance = OverlayScrollbars(el, this.scrollBarOPtions);
          instance.options({
            className: 'a-scrollbar--table--sticky',
            paddingAbsolute: true
          });
        }
      }
    }
  };

  return Table;
}();

exports.Table = Table;

},{"../utils/_Utils":102}],98:[function(require,module,exports){
"use strict";

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

exports.__esModule = true;
exports.Tabs = void 0;

var _Utils_1 = require("../utils/_Utils");

require("../../js/components/swipe.js");

var table_1 = require("./table");

var Tabs =
/** @class */
function () {
  function Tabs() {
    this.tab = document.querySelector('.o-tabs');

    if (this.tab !== undefined && this.tab !== null) {
      this.tablist = document.querySelectorAll('.o-tabs__tablist__item');
      this.posleft = 0;
      this.tabPosLeft = 0;
      this.underline = document.querySelector('.o-tabs__tablist__underline');
      this.table = new table_1.Table();
    }
  }

  Tabs.prototype.init = function () {
    if (this.tab !== undefined && this.tab !== null) {
      this.events();
    }
  };

  Tabs.prototype.events = function () {
    var _that = this;

    document.addEventListener('DOMContentLoaded', function () {
      console.log('loaded');
      var firstTab = document.querySelector('.o-tabs__tablist__item');

      var underline = _that.tab.querySelector('.o-tabs__tablist__underline');

      underline.style.width = firstTab.offsetWidth.toString() + 'px';
    });
    this.tablist.forEach(function (el) {
      var item = el;
      item.addEventListener('click', function () {
        var _this = this;

        var tabWrapper = item.closest('.o-tabs');

        var activateItem = function activateItem() {
          return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
              switch (_a.label) {
                case 0:
                  _that.setActiveTab(item, tabWrapper);

                  _that.moveUnderline(item);

                  return [4
                  /*yield*/
                  , new _Utils_1.Utils.PromiseUtils({
                    item: _that.underline
                  }).onceAnimationEnd()];

                case 1:
                  _a.sent();

                  return [2
                  /*return*/
                  ];
              }
            });
          });
        };

        var activePanel = function activePanel() {
          return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
              switch (_a.label) {
                case 0:
                  return [4
                  /*yield*/
                  , activateItem()];

                case 1:
                  _a.sent();

                  _that.getActivePanel(item, tabWrapper);

                  return [2
                  /*return*/
                  ];
              }
            });
          });
        };

        activePanel();
      });
      item.addEventListener('swiped', function (e) {
        var pos = item.parentElement.getBoundingClientRect().left;
        _that.tabPosLeft = 0;
        /* avoid swiping tabs further left if tabs is in initial position */

        if (pos <= 20) {
          if (e.detail.dir === 'right') {
            var calcPos = pos > 150;

            if (calcPos) {
              item.parentElement.style.transform = 'translateX(150px)';
            } else {
              item.parentElement.style.transform = 'none';
              item.parentElement.style.left = '0';
            }
          } else {
            item.style.removeProperty('left'); //allow swipe only if tabs element overflows outised screen

            if (_that.getPosition(item.parentElement)) {
              _that.posleft += -150; //limit swipe threshold

              if (_that.posleft < -400) {
                _that.posleft = -400;
              }

              item.parentElement.style.transform = 'translateX(' + _that.posleft.toString() + 'px)';
            }
          }
        }
      });
      window.addEventListener('resize', function () {
        _that.getTables(item);

        _that.moveUnderline(document.querySelector('.o-tabs__tablist__item--active'));
      });
    });
  };

  Tabs.prototype.moveTab = function (tab, wrapper, direction) {
    var list = wrapper.querySelector('.o-tabs__tablist');

    if (direction === 'left') {
      this.tabPosLeft += new _Utils_1.Utils.AttributesUtils({
        el: tab.parentElement
      }).getTranslateX() - (tab.getBoundingClientRect().left - 15);
      list.style.transform = 'translateX(' + this.tabPosLeft.toString() + 'px)';
    } else {
      this.tabPosLeft -= tab.getBoundingClientRect().left - 15;
      list.style.transform = 'translateX(' + this.tabPosLeft.toString() + 'px)';
    }
  };

  Tabs.prototype.getPosition = function (item) {
    var positionR = item.getBoundingClientRect().right;
    var positionL = item.getBoundingClientRect().left;
    var isOutLeft = positionL < 0;
    var isOutRight = positionR > window.innerWidth;

    if (isOutLeft) {
      return 'left';
    } else if (isOutRight) {
      return 'right';
    }
  };

  Tabs.prototype.setActiveTab = function (tab, wrapper) {
    var activeItem = wrapper.querySelector('.o-tabs__tablist__item--active');
    activeItem.classList.remove('o-tabs__tablist__item--active');
    activeItem.setAttribute('tabindex', '-1');
    tab.classList.add('o-tabs__tablist__item--active');
    tab.setAttribute('tabindex', '0');

    if (this.getPosition(tab)) {
      this.moveTab(tab, wrapper, this.getPosition(tab));
    }
  };

  Tabs.prototype.getActivePanel = function (tab, wrapper) {
    var tabPanels = wrapper.querySelectorAll('.o-tabs__tabpanel');
    this.close(tabPanels);
    this.open(tab, wrapper);
  };

  Tabs.prototype.open = function (tab, wrapper) {
    var id = tab.getAttribute('id');
    var target = wrapper.querySelector('.o-tabs__tabpanel[aria-labelledby="' + id + '"]');
    target.style.display = 'block';
    target.setAttribute('tabindex', '0');
    this.getTables(target);
    this.getOPcGraph(target);
  };

  Tabs.prototype.getTables = function (el) {
    var _this = this;

    var tables = el.querySelectorAll('.o-table');

    if (tables !== undefined && tables !== null) {
      tables.forEach(function (el) {
        var item = el;
        var isSticky = item.getAttribute('is-sticky-table');

        var session = _this.table.getSessionStorageItem(item);

        var isOpc = item.classList.contains('o-table--opc');

        _this.table.checkScrollableTable(item, session, isSticky, isOpc);
      });
    }
  };

  Tabs.prototype.getOPcGraph = function (el) {
    var graph = el.querySelector('.o-graph-opc');

    if (graph !== undefined && graph !== null && graph.querySelector('iframe') === null) {
      var c_event = new CustomEvent('trigger:opcgraph');
      document.dispatchEvent(c_event);
    }
  };

  Tabs.prototype.close = function (panels) {
    panels.forEach(function (el) {
      var item = el;
      item.style.display = 'none';
      item.setAttribute('tabindex', '-1');
    });
  };

  Tabs.prototype.moveUnderline = function (item) {
    var tabPos = this.tab.getBoundingClientRect().left;
    this.underline.style.width = item.offsetWidth.toString() + 'px';
    this.underline.style.left = (item.getBoundingClientRect().left - tabPos).toString() + 'px';
  };

  return Tabs;
}();

exports.Tabs = Tabs;

},{"../../js/components/swipe.js":64,"../utils/_Utils":102,"./table":97}],99:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.Tooltip = void 0;

var _Utils_1 = require("../utils/_Utils");

var Tooltip =
/** @class */
function () {
  function Tooltip() {
    this.tooltipsClick = document.querySelectorAll('[data-tippy-trigger-click]');
  }

  Tooltip.prototype.init = function () {
    this.hover();
    this.click();
    this.clickDocument();
    this.events();
  };

  Tooltip.prototype.hover = function () {
    var instance = tippy('[data-tippy-trigger]', {
      delay: 50,
      placement: 'bottom',
      theme: 'light',
      animation: 'fade',
      arrow: true,
      interactive: true,
      content: function content(reference) {
        var container = reference.nextElementSibling;
        return container.innerHTML;
      }
    });
  };

  Tooltip.prototype.click = function () {
    // tooltip on click
    tippy(document.querySelectorAll('[data-tippy-trigger-click]'), {
      appendTo: 'parent',
      delay: 400,
      trigger: 'click',
      placement: 'bottom',
      theme: 'light',
      animation: 'fade',
      arrow: true,
      interactive: true,
      aria: {
        content: 'describedby',
        expanded: 'auto'
      },
      onShow: function onShow(instance) {
        console.log('instance', instance);
      }
    });
  };

  Tooltip.prototype.clickDocument = function () {
    // tooltip on click & displayed bottom of the page
    this.instanceClick = tippy('[data-tippy-trigger-click-document]', {
      appendTo: function appendTo() {
        return document.body;
      },
      delay: 400,
      trigger: 'click',
      placement: 'bottom',
      theme: 'light',
      animation: 'fade',
      arrow: true,
      allowHTML: true,
      interactive: true,
      content: function content(reference) {
        var container = reference.nextElementSibling;
        return container.innerHTML;
      }
    });
  };

  Tooltip.prototype.events = function () {
    _Utils_1.Utils.EventUtils.setDocEvent('click', '[data-tippy-trigger-click]', function (target, event) {
      event.preventDefault();

      if (!_Utils_1.Utils.ViewportUtils.isMobile()) {
        if (!target.classList.contains('closed')) {
          target.classList.add('closed');
        } else {
          target.focus();
          target.classList.add('is--focused');
        }
      } else {
        var overlay = target.parentElement.querySelector('.o-overlay');
        var label = overlay.querySelector('label');
        var input = overlay.querySelector('input');
        overlay.style.display = 'inline-block';
        input.click();
        label.classList.add('is--focused');
        label.focus();
      }
    });

    _Utils_1.Utils.EventUtils.setDocEvent('keydown', '[data-tippy-trigger-click]', function (target, event) {
      var isEnter = event.which === 13 || event.key === 'Enter';
      var isTab = event.which === 9 || event.key === 'Tab';
      var acessibilityElement = target.querySelector('span.sr-only > span');
      var hideLabel = 'Masquer';
      var displayLabel = 'Afficher';

      if (!_Utils_1.Utils.ViewportUtils.isMobile() && isEnter) {
        if (!target.classList.contains('closed')) {
          acessibilityElement.textContent = displayLabel;
          setTimeout(function () {
            target.focus();
            target.classList.add('closed');
          }, 300);
        } else {
          acessibilityElement.textContent = hideLabel;
          setTimeout(function () {
            target.classList.remove('closed');
          }, 300);
        }

        setTimeout(function () {
          target.classList.add('is--focused');
        }, 300);
      }

      if (isTab) {
        var tippyroot = target.parentElement.querySelector('[data-tippy-root]');
        tippyroot.parentElement.removeChild(tippyroot);
        acessibilityElement.textContent = displayLabel;
      }
    });
  };

  return Tooltip;
}();

exports.Tooltip = Tooltip;

},{"../utils/_Utils":102}],100:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.WarnBanner = void 0;

var menu_1 = require("./header/menu");

var submenu_1 = require("./header/submenu");

var _Utils_1 = require("../utils/_Utils");

var WarnBanner =
/** @class */
function () {
  function WarnBanner() {
    this.banner = document.querySelector('.o-warnbanner');
    this.header = document.getElementById('header');
    this.menu = new menu_1.Menu(this.header);
    this.submenu = new submenu_1.SubMenu();
    this.stateOpen = false;

    if (this.banner === null) {
      return;
    }

    this.bannerCLose = this.banner.querySelector('.o-warnbanner__close');
    this.init();
  }

  WarnBanner.prototype.init = function () {
    this.SetDisplay();
    this.events();
  };

  WarnBanner.prototype.events = function () {
    var _that = this;

    this.bannerCLose.addEventListener('click', function () {
      _that.SetSession();

      _that.Close();
    });
    document.addEventListener('DOMContentLoaded', function () {
      if (_that.banner !== null && sessionStorage.getItem('lbp.warnbanner') === null) {
        _that.stateOpen = true;
      }
    });
  };

  WarnBanner.prototype.SetDisplay = function () {
    if (sessionStorage.getItem('lbp.warnbanner') !== null && !this.banner.classList.contains('editmode')) {
      this.Close();
    } else {
      this.banner.classList.remove('o-warnbanner--unchecked');
    }
  };

  WarnBanner.prototype.SetSession = function () {
    if (sessionStorage.getItem('lbp.warnbanner') === null) {
      sessionStorage.setItem('lbp.warnbanner', '1');
    }
  };

  WarnBanner.prototype.Close = function () {
    this.banner.classList.add('o-warnbanner--unchecked');
    this.bannerCLose.setAttribute('aria-hidden', 'true');
    this.stateOpen = false;

    if (!_Utils_1.Utils.ViewportUtils.isDesktop()) {
      this.menu.list.style.removeProperty('top');
      this.menu.list.querySelectorAll('.m-header__sublist__panel').forEach(function (item) {
        var itemHtml = item;
        itemHtml.style.removeProperty('top');
      });
    }
  };

  WarnBanner.prototype.Open = function () {
    this.banner.classList.remove('o-warnbanner--unchecked');
    this.bannerCLose.removeAttribute('aria-hidden');
    this.stateOpen = true;
  };

  return WarnBanner;
}();

exports.WarnBanner = WarnBanner;

},{"../utils/_Utils":102,"./header/menu":83,"./header/submenu":86}],101:[function(require,module,exports){
"use strict";

exports.__esModule = true; //Core-JS polyfill

require("core-js/modules/es.string.starts-with"); //legacy


require("../js/librairies/polyfill.js");

require("../js/librairies/utils.js");

require("../js/librairies/clamp.js");

require("../js/components/carousel.js");

require("../js/components/select.js");

require("../js/components/filter-newslist.js");

require("../js/components/newslist.js");

require("../js/components/opc/graph-opc.js");

require("../js/components/newsletter/newsletterPush.js");

require("../js/components/newsletter/newsletteriframe.js");

require("../js/components/filter.js");

require("../js/components/currencyconverter.js");

require("../js/components/swipe.js");

require("../js/components/opc/opc-selector.js");

var avoidLinks_1 = require("./components/avoidLinks");

var avoidlinks = new avoidLinks_1.AvoidLinks(); //utils

var _Utils_1 = require("./utils/_Utils");

var focus = new _Utils_1.Utils.FocusUtils({});
focus.init(); //Header

var header_1 = require("./components/header/header");

var metanavigation_1 = require("./components/header/metanavigation");

var lang_1 = require("./components/header/lang");

var hasHeader = document.getElementById('header');

if (hasHeader !== null) {
  var isSimplifiedHeader = document.getElementById('header').classList.contains('o-header--simplified');

  if (!isSimplifiedHeader) {
    var header = new header_1.Header();
    header.init();
    var metanav = new metanavigation_1.Metanavigation();
    metanav.init();
    var lang = new lang_1.Lang();
    lang.init();
  }
} // Components


var optinbutton_1 = require("./components/optinbutton");

var optinButton = new optinbutton_1.OptinButton();
optinButton.init();

var accordion_1 = require("./components/accordion");

var accordion = new accordion_1.Accordion();
accordion.init();

var consent_1 = require("./components/consent");

var consent = new consent_1.ConsentModal();
var consentPopin = document.getElementById('o-popin--consent');

if (consentPopin !== null) {
  consent.init();
}

var cvslogin_1 = require("./components/cvslogin");

var loginLayer = document.querySelector('.o-cvslogin');

if (loginLayer !== null) {
  var cvs = new cvslogin_1.CvsLogin();
  cvs.init();
}

var tooltip_1 = require("./components/tooltip");

var tooltip = new tooltip_1.Tooltip();
tooltip.init();

var table_1 = require("./components/table");

var table = new table_1.Table();
table.init();

var footnotes_1 = require("./components/footnotes");

var footnotes = new footnotes_1.Footnotes();
footnotes.init();

var privacyconsent_1 = require("./components/privacyconsent");

var privacy = new privacyconsent_1.PrivacyConsent();
privacy.init();

var summary_1 = require("./components/summary");

var summary = new summary_1.Summary();
summary.init();

var container_1 = require("./components/container");

var container = new container_1.Container();
container.init();

var decisiontree_1 = require("./components/decisiontree/decisiontree");

var tree = new decisiontree_1.DecisionTree();
tree.init();

var tabs_1 = require("./components/tabs");

var tabs = new tabs_1.Tabs();
tabs.init();

var iframeResizer_1 = require("./components/iframeResizer");

var iframe = new iframeResizer_1.IframeResizer();
iframe.init();

},{"../js/components/carousel.js":54,"../js/components/currencyconverter.js":55,"../js/components/filter-newslist.js":56,"../js/components/filter.js":57,"../js/components/newsletter/newsletterPush.js":58,"../js/components/newsletter/newsletteriframe.js":59,"../js/components/newslist.js":60,"../js/components/opc/graph-opc.js":61,"../js/components/opc/opc-selector.js":62,"../js/components/select.js":63,"../js/components/swipe.js":64,"../js/librairies/clamp.js":65,"../js/librairies/polyfill.js":66,"../js/librairies/utils.js":67,"./components/accordion":68,"./components/avoidLinks":69,"./components/consent":70,"./components/container":71,"./components/cvslogin":72,"./components/decisiontree/decisiontree":73,"./components/footnotes":77,"./components/header/header":80,"./components/header/lang":82,"./components/header/metanavigation":84,"./components/iframeResizer":87,"./components/optinbutton":88,"./components/privacyconsent":89,"./components/summary":96,"./components/table":97,"./components/tabs":98,"./components/tooltip":99,"./utils/_Utils":102,"core-js/modules/es.string.starts-with":53}],102:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.DatePickerUtils = exports.EmptyUtils = exports.OwlCarouselUtils = exports.SiblingsUtils = exports.ChildrenUtils = exports.CloneUtils = exports.ScrollUtils = exports.AttributesUtils = exports.PageUtils = exports.LegacyUtils = exports.PromiseUtils = exports.ViewportDetect = exports.ViewportUtils = exports.IconUtils = exports.FocusUtils = exports.EventUtils = exports.Cookie = exports.Utils = void 0;

var eventUtils_1 = require("./eventUtils");

exports.EventUtils = eventUtils_1.EventUtils;

var iconUtils_1 = require("./iconUtils");

exports.IconUtils = iconUtils_1.IconUtils;

var focusUtils_1 = require("./focusUtils");

exports.FocusUtils = focusUtils_1.FocusUtils;

var promiseUtils_1 = require("./promiseUtils");

exports.PromiseUtils = promiseUtils_1.PromiseUtils;

var cookieUtils_1 = require("./cookieUtils");

var viewportUtils_1 = require("./viewportUtils");

exports.ViewportUtils = viewportUtils_1.ViewportUtils;
exports.ViewportDetect = viewportUtils_1.ViewportDetect;

var pageUtils_1 = require("./pageUtils");

exports.PageUtils = pageUtils_1.PageUtils;

var attributesUtils_1 = require("./attributesUtils");

exports.AttributesUtils = attributesUtils_1.AttributesUtils;

var scrollUtils_1 = require("./scrollUtils");

exports.ScrollUtils = scrollUtils_1.ScrollUtils;

var cloneUtils_1 = require("./cloneUtils");

exports.CloneUtils = cloneUtils_1.CloneUtils;

var childrenUtils_1 = require("./childrenUtils");

exports.ChildrenUtils = childrenUtils_1.ChildrenUtils;

var siblingsUtils_1 = require("./siblingsUtils");

exports.SiblingsUtils = siblingsUtils_1.SiblingsUtils;

var owlCarousel_1 = require("./owlCarousel");

exports.OwlCarouselUtils = owlCarousel_1.OwlCarouselUtils;

var emptyUtils_1 = require("./emptyUtils");

exports.EmptyUtils = emptyUtils_1.EmptyUtils;

var datePicker_1 = require("./datePicker");

exports.DatePickerUtils = datePicker_1.DatePickerUtils;

var utils_1 = require("../../js/librairies/utils");

var LegacyUtils = {
  emptyString: utils_1.emptyString,
  waitForFinalEvent: utils_1.waitForFinalEvent
};
exports.LegacyUtils = LegacyUtils;
var Cookie = {
  deleteCookie: cookieUtils_1.deleteCookie,
  getCookie: cookieUtils_1.getCookie,
  setCookie: cookieUtils_1.setCookie
};
exports.Cookie = Cookie;
var Utils = {
  Cookie: Cookie,
  EventUtils: eventUtils_1.EventUtils,
  FocusUtils: focusUtils_1.FocusUtils,
  IconUtils: iconUtils_1.IconUtils,
  ViewportUtils: viewportUtils_1.ViewportUtils,
  ViewportDetect: viewportUtils_1.ViewportDetect,
  PromiseUtils: promiseUtils_1.PromiseUtils,
  LegacyUtils: LegacyUtils,
  PageUtils: pageUtils_1.PageUtils,
  AttributesUtils: attributesUtils_1.AttributesUtils,
  ScrollUtils: scrollUtils_1.ScrollUtils,
  CloneUtils: cloneUtils_1.CloneUtils,
  ChildrenUtils: childrenUtils_1.ChildrenUtils,
  SiblingsUtils: siblingsUtils_1.SiblingsUtils,
  OwlCarouselUtils: owlCarousel_1.OwlCarouselUtils,
  EmptyUtils: emptyUtils_1.EmptyUtils,
  DatePickerUtils: datePicker_1.DatePickerUtils
};
exports.Utils = Utils;

},{"../../js/librairies/utils":67,"./attributesUtils":103,"./childrenUtils":104,"./cloneUtils":105,"./cookieUtils":106,"./datePicker":107,"./emptyUtils":108,"./eventUtils":109,"./focusUtils":110,"./iconUtils":111,"./owlCarousel":112,"./pageUtils":113,"./promiseUtils":114,"./scrollUtils":115,"./siblingsUtils":116,"./viewportUtils":117}],103:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.AttributesUtils = void 0;

var AttributesUtils =
/** @class */
function () {
  function AttributesUtils(options) {
    this.options = options;
  }

  AttributesUtils.prototype.setAttributes = function () {
    var _this = this;

    Object.keys(this.options.attrs).forEach(function (key) {
      return _this.options.el.setAttribute(key, _this.options.attrs[key]);
    });
  };

  AttributesUtils.prototype.getTranslateX = function () {
    var style = window.getComputedStyle(this.options.el);
    var matrix = new WebKitCSSMatrix(style.transform);
    return matrix.m41;
  };

  return AttributesUtils;
}();

exports.AttributesUtils = AttributesUtils;

},{}],104:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.ChildrenUtils = void 0;

var ChildrenUtils =
/** @class */
function () {
  function ChildrenUtils(options) {
    this.options = options;
  }

  ChildrenUtils.prototype.toChildrenList = function () {
    var _this = this;

    var itemsArray = Array.from(this.options.wrapper.children); // make Array from his children

    var list = [];
    var map = itemsArray.map(function (item) {
      var element = item;

      if (element.classList.contains(_this.options.className)) {
        list.push(element);
      }
    });
    return list;
  };

  return ChildrenUtils;
}();

exports.ChildrenUtils = ChildrenUtils;

},{}],105:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.CloneUtils = void 0;

var CloneUtils =
/** @class */
function () {
  function CloneUtils(options) {
    this.options = options;
  }

  CloneUtils.prototype.toNodeList = function () {
    var fragment = document.createDocumentFragment();
    this.options.list.forEach(function (item) {
      fragment.appendChild(item.cloneNode());
    });
    return fragment.childNodes;
  };

  return CloneUtils;
}();

exports.CloneUtils = CloneUtils;

},{}],106:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.deleteCookie = exports.getCookie = exports.setCookie = void 0;
/*
 * General utils for managing cookies in Typescript.
 */

function setCookie(name, val, timevalue) {
  var date = new Date();
  var value = val; // Set it expire in 7 days

  date.setTime(date.getTime() + timevalue); // Set it

  document.cookie = name + '=' + value + '; expires=' + date.toUTCString() + '; path=/';
}

exports.setCookie = setCookie;

function getCookie(name) {
  var value = '; ' + document.cookie;
  var parts = value.split('; ' + name + '=');

  if (parts.length === 2) {
    return parts.pop().split(';').shift();
  }
}

exports.getCookie = getCookie;

function deleteCookie(name) {
  var date = new Date(); // Set it expire in -1 days

  date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000); // Set it

  document.cookie = name + '=; expires=' + date.toUTCString() + '; path=/';
}

exports.deleteCookie = deleteCookie;

},{}],107:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.DatePickerUtils = void 0;

var DatePickerUtils =
/** @class */
function () {
  function DatePickerUtils(options) {
    this.options = options;
  }

  DatePickerUtils.prototype.init = function () {
    $(this.options.selector).datepicker(this.options.datepickerOtions);
  };

  return DatePickerUtils;
}();

exports.DatePickerUtils = DatePickerUtils;

},{}],108:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.EmptyUtils = void 0;

var EmptyUtils =
/** @class */
function () {
  function EmptyUtils(options) {
    this.options = options;
  }

  EmptyUtils.prototype.empty = function () {
    while (this.options.wrapper.firstChild) {
      this.options.wrapper.removeChild(this.options.wrapper.firstChild);
    }
  };

  return EmptyUtils;
}();

exports.EmptyUtils = EmptyUtils;

},{}],109:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.EventUtils = void 0;
exports.EventUtils = {
  /**
   *  Delegate event from document
   *  (equivalent of jquery $(document).on(eventType, selector, callback);)
   * @param {EventType} eventType Type of event (click, keyup, mouseover...)
   * @param {String} selector Target Element selector
   * @param callback Function that will be executed when target found
   *
   * * Usage :
   *  this.utils.setDocEvent('click', '.selector a', function (target: HTMLElement, event: Event) {
   *      console.log('target', target, event);
   *      mymethod(target);
   *   });
   */
  setDocEvent: function setDocEvent(eventType, selector, callback) {
    document.addEventListener(eventType, function (event) {
      // loop parent nodes from the target to the delegation node
      for (var target = event.target; target && target !== this; target = target.parentNode) {
        var _targetElement = target;

        if (_targetElement.matches(selector)) {
          callback(target, event);
          break;
        }
      }
    }, false);
  }
};

},{}],110:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.FocusUtils = void 0;

var FocusUtils =
/** @class */
function () {
  function FocusUtils(options) {
    this.options = options;
  }

  FocusUtils.prototype.init = function () {
    this.events();
  };
  /**
   * Loop through itemlist and set focus on each element of the list on tab event.
   * At the end of the loop : restart tab navigation at index[0]
   */


  FocusUtils.prototype.setFocus = function () {
    var _this = this;

    this.options.event.preventDefault();
    var focusable;
    focusable = Array.from(this.options.item.querySelectorAll(this.options.focusableSelectors));
    var index = focusable.findIndex(function (f) {
      return f === _this.options.item.querySelector(':focus');
    });

    if (this.options.event.shiftKey === true) {
      index--;
    } else {
      index++;
    }

    if (index >= focusable.length) {
      index = 0;
    }

    if (index < 0) {
      index = focusable.length - 1;
    }

    focusable[index].focus();
  };
  /**
   * Add manual focus display in order to avoid focus state on click on non link elements
   */


  FocusUtils.prototype.events = function () {
    var tabpressed;
    document.addEventListener('keydown', function (e) {
      var isEnter = e.which === 13 || e.key === 'Enter';

      if (e.which !== 0 && !isEnter) {
        tabpressed = true;
      }
    });
    document.addEventListener('click', function () {
      var focused = document.querySelectorAll('.is--focused');

      if (tabpressed === false) {
        focused.forEach(function (item) {
          item.classList.remove('is--focused');
        });
      }

      tabpressed = false;
    });
    document.addEventListener('focusin', function (e) {
      var htmlTarget = e.target;

      if (tabpressed === true) {
        htmlTarget.classList.add('is--focused');
      }
    });
    document.addEventListener('focusout', function (e) {
      var htmlTarget = e.target;

      if (tabpressed === true) {
        htmlTarget.classList.remove('is--focused');
      }
    });
  };

  return FocusUtils;
}();

exports.FocusUtils = FocusUtils;

},{}],111:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.IconUtils = void 0;
exports.IconUtils = {
  /**
   * Return Icon string for render
   * @param {String} iconname
   */
  getNewIcon: function getNewIcon(iconname) {
    return "<svg viewBox=\"0 0 24 24\"\n                    aria-hidden=\"true\"\n                    focusable=\"false\"\n                    class=\"a-icon--s\">\n                    <use xlink:href=\"/etc.clientlibs/labanquepostale/commons/clientlibs/base/resources/svg-icons.svg#" + iconname + "\"></use>\n                </svg>";
  }
};

},{}],112:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.OwlCarouselUtils = void 0;

var OwlCarouselUtils =
/** @class */
function () {
  function OwlCarouselUtils(options) {
    this.options = options;
  }

  OwlCarouselUtils.prototype.init = function () {
    $(this.options.selector).owlCarousel(this.options.caourselOtions);
  };

  OwlCarouselUtils.prototype.destroy = function () {
    this.options.selector.owlCarousel('destroy');
  };

  return OwlCarouselUtils;
}();

exports.OwlCarouselUtils = OwlCarouselUtils;

},{}],113:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.PageUtils = void 0;

var PageUtils =
/** @class */
function () {
  function PageUtils() {
    this.header = document.getElementById('header');
    this.isHomePage = false;
  }

  PageUtils.prototype.IsHomePage = function () {
    var logo = this.header.querySelector('.js-logo-type');

    if (logo) {
      this.isHomePage = this.header.querySelector('.js-logo-type').tagName !== 'A' ? true : false;
    }

    return this.isHomePage;
  };

  return PageUtils;
}();

exports.PageUtils = PageUtils;

},{}],114:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.PromiseUtils = void 0;

var PromiseUtils =
/** @class */
function () {
  function PromiseUtils(options) {
    var _this = this;

    this.onceAnimationEnd = function () {
      return new Promise(function (resolve) {
        if (_this.options.item !== undefined) {
          _this.options.item.ontransitionend = function () {
            resolve();
          };
        }
      });
    };

    this.options = options;
  }

  return PromiseUtils;
}();

exports.PromiseUtils = PromiseUtils;

},{}],115:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.ScrollUtils = void 0;

var ScrollUtils =
/** @class */
function () {
  function ScrollUtils(options) {
    this.options = options;
    this.target = this.options.el;
  }

  ScrollUtils.prototype.scrollTo = function () {
    var _that = this;

    var summary = document.getElementById('summary');

    if (this.target) {
      var adaptSticky = summary !== undefined ? 215 : 80;
      var posTop = this.target.getBoundingClientRect().top + window.scrollY - adaptSticky;
      window.scroll({
        top: posTop,
        behavior: 'smooth',
        left: 0
      });
      setTimeout(function () {
        _that.target.focus();
      }, 1000);
    }
  };

  return ScrollUtils;
}();

exports.ScrollUtils = ScrollUtils;

},{}],116:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.SiblingsUtils = void 0;

var SiblingsUtils =
/** @class */
function () {
  function SiblingsUtils(options) {
    this.options = options;
  }

  SiblingsUtils.prototype.getNext = function () {
    var nextElem = this.options.el.nextElementSibling;

    if (nextElem && nextElem.matches(this.options.className)) {
      return nextElem;
    }

    return null;
  };

  SiblingsUtils.prototype.getPrev = function () {
    var prevEleme = this.options.el.previousElementSibling;

    if (prevEleme && prevEleme.matches(this.options.className)) {
      return prevEleme;
    }

    return null;
  };

  return SiblingsUtils;
}();

exports.SiblingsUtils = SiblingsUtils;

},{}],117:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.ViewportDetect = exports.ViewportUtils = void 0;
exports.ViewportUtils = {
  isDesktop: function isDesktop() {
    return document.body.clientWidth > 1023;
  },
  isTablet: function isTablet() {
    return document.body.clientWidth > 767 && document.body.clientWidth < 1024;
  },
  isMobile: function isMobile() {
    return document.body.clientWidth < 768;
  }
};

var ViewportDetect =
/** @class */
function () {
  function ViewportDetect() {
    this.currentViewport = '';
  }

  ViewportDetect.prototype.getCurrentVp = function () {
    var vpList = document.querySelector('#viewportDetect').childNodes;
    var that = this;
    vpList.forEach(function (item) {
      var itemHtml = item;
      var style = getComputedStyle(itemHtml);

      if (style.display === 'block') {
        that.currentViewport = itemHtml.getAttribute('data-viewport');
      }
    });
    return this.currentViewport;
  };

  return ViewportDetect;
}();

exports.ViewportDetect = ViewportDetect;

},{}]},{},[101])

//# sourceMappingURL=/apps/labanquepostale/commons/clientlibs/base/js/bundle.js.map

/*******************************************************************************
 * Copyright 2018 Adobe
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

/**
 * Element.matches()
 * https://developer.mozilla.org/enUS/docs/Web/API/Element/matches#Polyfill
 */
if (!Element.prototype.matches) {
    Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
}

// eslint-disable-next-line valid-jsdoc
/**
 * Element.closest()
 * https://developer.mozilla.org/enUS/docs/Web/API/Element/closest#Polyfill
 */
if (!Element.prototype.closest) {
    Element.prototype.closest = function(s) {
        "use strict";
        var el = this;
        if (!document.documentElement.contains(el)) {
            return null;
        }
        do {
            if (el.matches(s)) {
                return el;
            }
            el = el.parentElement || el.parentNode;
        } while (el !== null && el.nodeType === 1);
        return null;
    };
}

/*******************************************************************************
 * Copyright 2018 Adobe
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
(function() {
    "use strict";

    var dataLayerEnabled;
    var dataLayer;

    var NS = "cmp";
    var IS = "tabs";

    var keyCodes = {
        END: 35,
        HOME: 36,
        ARROW_LEFT: 37,
        ARROW_UP: 38,
        ARROW_RIGHT: 39,
        ARROW_DOWN: 40
    };

    var selectors = {
        self: "[data-" + NS + '-is="' + IS + '"]',
        active: {
            tab: "cmp-tabs__tab--active",
            tabpanel: "cmp-tabs__tabpanel--active"
        }
    };

    /**
     * Tabs Configuration
     *
     * @typedef {Object} TabsConfig Represents a Tabs configuration
     * @property {HTMLElement} element The HTMLElement representing the Tabs
     * @property {Object} options The Tabs options
     */

    /**
     * Tabs
     *
     * @class Tabs
     * @classdesc An interactive Tabs component for navigating a list of tabs
     * @param {TabsConfig} config The Tabs configuration
     */
    function Tabs(config) {
        var that = this;

        if (config && config.element) {
            init(config);
        }

        /**
         * Initializes the Tabs
         *
         * @private
         * @param {TabsConfig} config The Tabs configuration
         */
        function init(config) {
            that._config = config;

            // prevents multiple initialization
            config.element.removeAttribute("data-" + NS + "-is");

            cacheElements(config.element);
            that._active = getActiveIndex(that._elements["tab"]);

            if (that._elements.tabpanel) {
                refreshActive();
                bindEvents();
            }

            // Show the tab based on deep-link-id if it matches with any existing tab item id
            var deepLinkItemIdx = CQ.CoreComponents.container.utils.getDeepLinkItemIdx(that, "tabpanel");
            if (deepLinkItemIdx) {
                var deepLinkItem = that._elements["tab"][deepLinkItemIdx];
                if (deepLinkItem && that._elements["tab"][that._active].id !== deepLinkItem.id) {
                    navigateAndFocusTab(deepLinkItemIdx);
                }
            }

            if (window.Granite && window.Granite.author && window.Granite.author.MessageChannel) {
                /*
                 * Editor message handling:
                 * - subscribe to "cmp.panelcontainer" message requests sent by the editor frame
                 * - check that the message data panel container type is correct and that the id (path) matches this specific Tabs component
                 * - if so, route the "navigate" operation to enact a navigation of the Tabs based on index data
                 */
                CQ.CoreComponents.MESSAGE_CHANNEL = CQ.CoreComponents.MESSAGE_CHANNEL || new window.Granite.author.MessageChannel("cqauthor", window);
                CQ.CoreComponents.MESSAGE_CHANNEL.subscribeRequestMessage("cmp.panelcontainer", function(message) {
                    if (message.data && message.data.type === "cmp-tabs" && message.data.id === that._elements.self.dataset["cmpPanelcontainerId"]) {
                        if (message.data.operation === "navigate") {
                            navigate(message.data.index);
                        }
                    }
                });
            }
        }

        /**
         * Returns the index of the active tab, if no tab is active returns 0
         *
         * @param {Array} tabs Tab elements
         * @returns {Number} Index of the active tab, 0 if none is active
         */
        function getActiveIndex(tabs) {
            if (tabs) {
                for (var i = 0; i < tabs.length; i++) {
                    if (tabs[i].classList.contains(selectors.active.tab)) {
                        return i;
                    }
                }
            }
            return 0;
        }

        /**
         * Caches the Tabs elements as defined via the {@code data-tabs-hook="ELEMENT_NAME"} markup API
         *
         * @private
         * @param {HTMLElement} wrapper The Tabs wrapper element
         */
        function cacheElements(wrapper) {
            that._elements = {};
            that._elements.self = wrapper;
            var hooks = that._elements.self.querySelectorAll("[data-" + NS + "-hook-" + IS + "]");

            for (var i = 0; i < hooks.length; i++) {
                var hook = hooks[i];
                if (hook.closest("." + NS + "-" + IS) === that._elements.self) { // only process own tab elements
                    var capitalized = IS;
                    capitalized = capitalized.charAt(0).toUpperCase() + capitalized.slice(1);
                    var key = hook.dataset[NS + "Hook" + capitalized];
                    if (that._elements[key]) {
                        if (!Array.isArray(that._elements[key])) {
                            var tmp = that._elements[key];
                            that._elements[key] = [tmp];
                        }
                        that._elements[key].push(hook);
                    } else {
                        that._elements[key] = hook;
                    }
                }
            }
        }

        /**
         * Binds Tabs event handling
         *
         * @private
         */
        function bindEvents() {
            var tabs = that._elements["tab"];
            if (tabs) {
                for (var i = 0; i < tabs.length; i++) {
                    (function(index) {
                        tabs[i].addEventListener("click", function(event) {
                            navigateAndFocusTab(index);
                        });
                        tabs[i].addEventListener("keydown", function(event) {
                            onKeyDown(event);
                        });
                    })(i);
                }
            }
        }

        /**
         * Handles tab keydown events
         *
         * @private
         * @param {Object} event The keydown event
         */
        function onKeyDown(event) {
            var index = that._active;
            var lastIndex = that._elements["tab"].length - 1;

            switch (event.keyCode) {
                case keyCodes.ARROW_LEFT:
                case keyCodes.ARROW_UP:
                    event.preventDefault();
                    if (index > 0) {
                        navigateAndFocusTab(index - 1);
                    }
                    break;
                case keyCodes.ARROW_RIGHT:
                case keyCodes.ARROW_DOWN:
                    event.preventDefault();
                    if (index < lastIndex) {
                        navigateAndFocusTab(index + 1);
                    }
                    break;
                case keyCodes.HOME:
                    event.preventDefault();
                    navigateAndFocusTab(0);
                    break;
                case keyCodes.END:
                    event.preventDefault();
                    navigateAndFocusTab(lastIndex);
                    break;
                default:
                    return;
            }
        }

        /**
         * Refreshes the tab markup based on the current {@code Tabs#_active} index
         *
         * @private
         */
        function refreshActive() {
            var tabpanels = that._elements["tabpanel"];
            var tabs = that._elements["tab"];

            if (tabpanels) {
                if (Array.isArray(tabpanels)) {
                    for (var i = 0; i < tabpanels.length; i++) {
                        if (i === parseInt(that._active)) {
                            tabpanels[i].classList.add(selectors.active.tabpanel);
                            tabpanels[i].removeAttribute("aria-hidden");
                            tabs[i].classList.add(selectors.active.tab);
                            tabs[i].setAttribute("aria-selected", true);
                            tabs[i].setAttribute("tabindex", "0");
                        } else {
                            tabpanels[i].classList.remove(selectors.active.tabpanel);
                            tabpanels[i].setAttribute("aria-hidden", true);
                            tabs[i].classList.remove(selectors.active.tab);
                            tabs[i].setAttribute("aria-selected", false);
                            tabs[i].setAttribute("tabindex", "-1");
                        }
                    }
                } else {
                    // only one tab
                    tabpanels.classList.add(selectors.active.tabpanel);
                    tabs.classList.add(selectors.active.tab);
                }
            }
        }

        /**
         * Focuses the element and prevents scrolling the element into view
         *
         * @param {HTMLElement} element Element to focus
         */
        function focusWithoutScroll(element) {
            var x = window.scrollX || window.pageXOffset;
            var y = window.scrollY || window.pageYOffset;
            element.focus();
            window.scrollTo(x, y);
        }

        /**
         * Navigates to the tab at the provided index
         *
         * @private
         * @param {Number} index The index of the tab to navigate to
         */
        function navigate(index) {
            that._active = index;
            refreshActive();
        }

        /**
         * Navigates to the item at the provided index and ensures the active tab gains focus
         *
         * @private
         * @param {Number} index The index of the item to navigate to
         */
        function navigateAndFocusTab(index) {
            var exActive = that._active;
            navigate(index);
            focusWithoutScroll(that._elements["tab"][index]);

            if (dataLayerEnabled) {

                var activeItem = getDataLayerId(that._elements.tabpanel[index].dataset.cmpDataLayer);
                var exActiveItem = getDataLayerId(that._elements.tabpanel[exActive].dataset.cmpDataLayer);

                dataLayer.push({
                    event: "cmp:show",
                    eventInfo: {
                        path: "component." + activeItem
                    }
                });

                dataLayer.push({
                    event: "cmp:hide",
                    eventInfo: {
                        path: "component." + exActiveItem
                    }
                });

                var tabsId = that._elements.self.id;
                var uploadPayload = { component: {} };
                uploadPayload.component[tabsId] = { shownItems: [activeItem] };

                var removePayload = { component: {} };
                removePayload.component[tabsId] = { shownItems: undefined };

                dataLayer.push(removePayload);
                dataLayer.push(uploadPayload);
            }
        }
    }

    /**
     * Reads options data from the Tabs wrapper element, defined via {@code data-cmp-*} data attributes
     *
     * @private
     * @param {HTMLElement} element The Tabs element to read options data from
     * @returns {Object} The options read from the component data attributes
     */
    function readData(element) {
        var data = element.dataset;
        var options = [];
        var capitalized = IS;
        capitalized = capitalized.charAt(0).toUpperCase() + capitalized.slice(1);
        var reserved = ["is", "hook" + capitalized];

        for (var key in data) {
            if (data.hasOwnProperty(key)) {
                var value = data[key];

                if (key.indexOf(NS) === 0) {
                    key = key.slice(NS.length);
                    key = key.charAt(0).toLowerCase() + key.substring(1);

                    if (reserved.indexOf(key) === -1) {
                        options[key] = value;
                    }
                }
            }
        }

        return options;
    }

    /**
     * Parses the dataLayer string and returns the ID
     *
     * @private
     * @param {String} componentDataLayer the dataLayer string
     * @returns {String} dataLayerId or undefined
     */
    function getDataLayerId(componentDataLayer) {
        return Object.keys(JSON.parse(componentDataLayer))[0];
    }

    /**
     * Document ready handler and DOM mutation observers. Initializes Tabs components as necessary.
     *
     * @private
     */
    function onDocumentReady() {
      dataLayerEnabled = document.body.hasAttribute("data-cmp-data-layer-enabled");
      dataLayer = (dataLayerEnabled)? window.adobeDataLayer = window.adobeDataLayer || [] : undefined;

      var elements = document.querySelectorAll(selectors.self);
        for (var i = 0; i < elements.length; i++) {
            new Tabs({ element: elements[i], options: readData(elements[i]) });
        }

        var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
        var body = document.querySelector("body");
        var observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                // needed for IE
                var nodesArray = [].slice.call(mutation.addedNodes);
                if (nodesArray.length > 0) {
                    nodesArray.forEach(function(addedNode) {
                        if (addedNode.querySelectorAll) {
                            var elementsArray = [].slice.call(addedNode.querySelectorAll(selectors.self));
                            elementsArray.forEach(function(element) {
                                new Tabs({ element: element, options: readData(element) });
                            });
                        }
                    });
                }
            });
        });

        observer.observe(body, {
            subtree: true,
            childList: true,
            characterData: true
        });
    }

    if (document.readyState !== "loading") {
        onDocumentReady();
    } else {
        document.addEventListener("DOMContentLoaded", onDocumentReady);
    }

}());

